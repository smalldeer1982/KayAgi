---
title: "BZOJ2164 采矿"
layout: "post"
diff: 省选/NOI-
pid: P10599
tag: ['动态规划 DP', '线段树', '背包 DP', '树链剖分']
---
# BZOJ2164 采矿
## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。
## 题目描述

浩浩荡荡的 cg 大军发现了一座矿产资源极其丰富的城市，他们打算在这座城市实施新的采矿战略。

这个城市可以看成一棵有 $n$ 个节点的有根树，我们把每个节点用 $1$ 到 $n$ 的整数编号。为了方便起见，对于任何一个非根节点 $v$，它任何一个祖先的编号都严格小于 $v$。树上的每个节点表示一个矿点，每条边表示一条街道。

作为 cg 大军的一个小队长，你拥有 $m$ 个部下。你有一张二维的动态信息表，用 $T_{i,j}$ 表示第 $i$ 行第 $j$ 列的数据。当你被允许开采某个区域时，你可以将你的部下分配至各个矿点。在第 $i$ 个矿点安排 $j$ 个人可以获得 $T_{i,j}$ 单位的矿产。

允许开采的区域是这样描述的：给你一对矿点 $(u,v)$，保证 $v$ 是 $u$ 的祖先（这里定义祖先包括 $u$ 本身）；$u$ 为你控制的区域，可以在以 $u$ 为根的子树上任意分配部下；$u$ 到 $v$ 的简单路径（不包括 $u$ 但包括 $v$，若 $u=v$ 则包括 $u$）为探险路径，在该路径上你可以选择至多一个矿点安排部下。你这次开采的收益为安排有部下的矿点的收益之和。
## 输入格式

输入的第一行包含 $5$ 个正整数 $n,m,A,B,Q$。其中 $n$ 为矿点的个数，$m$ 为部下的数量。$A,B,Q$ 是与动态信息表有关的数据。

第二行包含 $n-1$ 个正整数，第 $i$ 个数为 $F_{i+1}$，表示节点 $i+1$ 的父亲。

接下来需要你用下文的方法依次生成 $n$ 组数据，每组数据共 $m$ 个。其中第 $i$ 组的 $m$ 个数据为信息表中第 $i$ 行的 $m$ 个数据。紧接着一行包含一个正整数 $C$，表示事件的数量。

最后给出 $C$ 行，每行描述一个事件。每个事件会先给出一个 $0$ 或 $1$ 的整数。如果该数为 $0$，则后面有一个正整数 $p$，表示动态信息表有更新，你需要生成一组 $m$ 个数据，来替换信息表中第 $p$ 行的 $m$ 个数据。如果该数为$1$，则后面有两个正整数 $u,v$，表示出现了一个你可以开采的区域，你需要回答这次开采的收益。同一行的各个数之间均用一个空格隔开，没有多余的空格和换行。

数据的生成方法如下：每次生成一组 $m$ 个从小到大排列的数据，替换动态信息表的一行。其中，从小到大第 $j$ 个数替换信息表中第 $j$ 列的数。调用以下代码 $m$ 次并排序得到一组数据。（注意可能会出现重复的数）

```
Function GetInt 

A←((A xor B)+(B div X)+(B * X))and Y 
B←((A xor B)+(A div X)+(A * X))and Y 

return (A xor B)mod Q 
```

其中 $A,B,Q$ 均用 $32$ 位有符号整数保存（C/C++ 的 signed long int 类型，pascal 的 longint 类型），$X=2^{16}$，$Y=2^{31}-1$，xor 为位异或运算，div 为整除运算，and 为位且运算，mod 为取余运算。由于只保留了低 $31$ 位，易得我们不用考虑数据的溢出问题。注意每次 $A$ 和 $B$ 都会被改变）
## 输出格式

对于每个开采事件（开头为 $1$ 的事件），输出一行一个整数，为每次的收益。
## 样例

### 样例输入 #1
```
10 5 1 2 10
1 1 3 3 4 4 6 6 9
4
1 6 3
1 9 1
0 1
1 1 1
```
### 样例输出 #1
```
11
9
12
```
## 提示

**【样例解释】**

最初的信息表如下：

| 0 | 1 | 1 | 2 | 2 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 5 | 7 | 7 | 9 |
| 1 | 2 | 3 | 4 | 5 |
| 0 | 1 | 2 | 4 | 5 |
| 2 | 4 | 7 | 8 | 8 |
| 0 | 2 | 3 | 8 | 9 |
| 1 | 3 | 5 | 6 | 8 |
| 3 | 3 | 3 | 7 | 8 |
| 0 | 1 | 2 | 3 | 9 |
| 0 | 0 | 1 | 4 | 4 |

变化后的第 $1$ 行，为：
```
1 1 1 4 7
```
第一次开采可以在矿点 $6,8,9,10$ 任意安排，可以在矿点 $3$ 或 $4$ 中选取一个安排开采。一种最优安排是在矿点 $6$ 安排 $4$人，在矿点 $8$ 安排 $1$ 人。第二次开采可以在矿点 $9$ 安排，可以在矿点 $6,4,3,1$ 中选择一个安排。一种最优安排是在矿点 $9$ 安排 $1$ 人，在矿点 $6$ 安排 $4$ 人。

**【数据范围】**

有 $50\%$ 的数据，对于满足 $2\leq i\leq n$ 的整数 $i$，$F_i=i-1$。这些数据中有 $40\%$ 的数据（即所有数据的 $20\%$）满足 $n\leq 500，m\leq 20，C\leq 500$。

除上述数据，另有 $40\%$ 的数据满足 $n\leq 500$，$m\leq 20$，$C\leq 500$。

对于 $100\%$ 的数据 $1\leq n\leq 20000$，$1\leq m\leq 50$，$1\leq C\leq 2000$。对于满足 $2\leq i\leq n$ 的整数 $i$，$1\leq F_i<i$。$1\leq A,B\leq 2^{31}-1$，$1\leq Q\leq 10000$。


---

---
title: "[USTCPC 2025] 送温暖"
layout: "post"
diff: 省选/NOI-
pid: P12038
tag: ['二分', '2025', '背包 DP', '双指针 two-pointer', '折半搜索 meet in the middle', '高校校赛']
---
# [USTCPC 2025] 送温暖
## 题目描述

克露丝卡尔酱听说大家都是经验丰富的信息竞赛老手，轻松暴力踩标算。为了让大家都体验一下暴力踩标算的乐趣，所以克露丝卡尔酱准备了一道简单的送温暖题：

给定一个 $n$ 个点的树，点 $i$ 的点权为 $a_i$，你需要从中选出一个连通块，使得它们的点权和模 $M$ 的余数最大。克露丝卡尔酱想知道这个点权和模 $M$ 的余数最大是多少。
## 输入格式

第一行两个正整数 $n$ $(1\leqslant n \leqslant 33)$ 和 $M$ $(2\leqslant M \leqslant 10^9)$。

为了方便输入，我们输入时假定以 $1$ 为根，但是请注意这是一棵无根树。

第二行有 $n - 1$ 个整数，第 $i$ 个整数表示第 $i + 1$ 个点的父节点 $f_{i + 1}$ $(1\leqslant f_{i+1} < i+1)$。

第三行有 $n$ 个整数，$a_1, \cdots, a_n$ $(0 \leqslant a_i < M)$ 表示每个点的点权。
## 输出格式

共一个整数表示答案。
## 样例

### 样例输入 #1
```
6 10
1 2 3 4 5
7 7 7 7 7 7
```
### 样例输出 #1
```
8
```
## 提示

这棵树是一条链 `1 - 2 - 3 - 4 - 5 - 6`。最优解为选择一条长度为 4 的链（例如 `1 - 2 - 3 - 4` 或者 `2 - 3 - 4 - 5` 等等），此时答案为 $4 \times 7 \equiv 8\pmod {10}$。


---

---
title: "[Math×Girl] 互质与整除"
layout: "post"
diff: 省选/NOI-
pid: P12470
tag: ['多项式', '数论', 'O2优化', '背包 DP', '生成函数', 'Dirichlet 卷积', '欧拉函数']
---
# [Math×Girl] 互质与整除
## 题目背景

>“还可以连接一个东西。”米尔嘉说，“$1$ 的原始 $n$ 次方根的个数是欧拉老师 $\varphi$ 函数的值。函数 $\varphi(n)$ 在 $1\le k<n$ 的范围内表示与 $n$ 互质的自然数的个数，也表示循环群的生成元的个数。”米尔嘉像是描绘 $\varphi$ 似地挥动手指，“最喜欢互质的尤里不在这里真可惜，今天你怎么没带她来？”  
>米尔嘉瞪我。

“互质？”米尔嘉看着窗外说，“我们来做道有趣的题吧！”  
## 题目描述

给定一个数 $n$，求出满足以下方程的 $x$ 的个数。
$$\varphi(x)\mid n$$

其中 $\mid$ 为整除符号，$a\mid b$ 表示 $a$ 整除 $b$。  
$\varphi(x)$ 为欧拉 $\varphi$ 函数，详见题目背景。
## 输入格式

本题有多组数据，第一行输入一个整数 $T$，表示数据组数。  

_米尔嘉已经帮你实现了 Pollard-Rho 算法，_  
所以输入给出的是 $n$ 的标准质因子分解形式 $n=\prod_{i=1}^s p_i^{\alpha_i}$。

对于每一组询问，我们首先给出一个整数 $s$。  
后面 $s$ 行每行两个整数表示 $p_i,\alpha_i$，保证 $p_i<p_{i+1}$。
## 输出格式

对于每组数据，一行输出一个数表示解的个数。  

_为了节约你的时间，米尔嘉已经封装好了 modint 以进行中国剩余定理合并答案。_  
所以输出对 $998244353$ 取模后的结果即可。  
## 样例

### 样例输入 #1
```
3
1
2 3
3
2 3
11 1
23 1
6
2 1
3 2
5 1
7 1
101 2
178187 1
```
### 样例输出 #1
```
14
53
53
```
## 提示

### 样例解释

质因数分解前 $n$ 分别为：  
$8,2024,1145141919810$

第一个例子中的 $14$ 个解是：  
$\varphi(15)=\varphi(16)=\varphi(20)=\varphi(24)=\varphi(30)=8\mid 8$  
$\varphi(5)=\varphi(8)=\varphi(10)=\varphi(12)=4\mid 8$  
$\varphi(3)=\varphi(4)=\varphi(6)=2\mid 8$  
$\varphi(1)=\varphi(2)=1\mid 8$

### 数据范围

| 子任务 | 分值 | 限制 |
| :----------: | :----------: | :----------: |
| $0$ | $10$ | $n\in[1,10^7]$ |
| $1$ | $10$ | $n\in[1,10^9]$ |
| $2$ | $20$ | $n\in[1,10^{12}]$ |
| $3$ | $20$ | $n\in[1,10^{14}]$ |
| $4$ | $20$ | $n\in[1,10^{16}]$ |
| $5$ | $20$ | - |

对于 $100\%$ 数据，保证 $T=5$，$n\in[1,10^{18}],s\ge 1$。 


---

---
title: "理解 加强版"
layout: "post"
diff: 省选/NOI-
pid: P12777
tag: ['2025', '洛谷原创', '背包 DP', '树形 DP']
---
# 理解 加强版
## 题目背景

> 「浅村同学对于我……」\
「**理解得太深了。**」\
——绫濑沙季
## 题目描述

沙季正在用悠太推荐的方法做现代文阅读练习。

有 $n$ 个历史事件，编号为 $1$ 至 $n$，其中每个历史事件可能有一个编号比它更小的前置事件，也可能没有。形式化地，对于事件 $i$，用 $p_i$ 表示其前置事件的编号，满足 $p_i<i$，若 $p_i=0$ 则表示它没有前置事件。

沙季有两种方式记起一个历史事件：回想和联想。如果她进行回想，那么她可以花费 $r_u$ 时间，直接记起任意一个历史事件 $u$；如果她进行联想，那么她可以选择任意一个已经记起来的事件 $u$，并花费 $t_v$ 时间记起一个满足 $p_v=u$ 的事件 $v$。

但是她的脑容量有限，因此她最多只能同时记起 $k$ 个事件。她已经记起来的事件可以选择在任意时刻忘记，忘记事件不需要花费时间。**她可以再次记起曾经忘记过的事件。**

现在，她有 $m$ 道阅读题，解决其中的第 $i$ 道题需要她记起事件 $x_i$，她可以在记起事件 $x_i$ 的时候立刻解决第 $i$ 道题目，花费的时间忽略不计。她想要知道她至少需要花费多少时间才能解决所有题目。
## 输入格式

第一行输入一个整数 $T$ 表示数据组数。

对于每组数据，第一行输入三个整数 $n,m,k$ 表示历史事件数量，阅读题的数量和她最多能够同时记起的事件数量。

第二行输入 $n$ 个整数，表示 $p_1,\dots,p_n$。

第三行输入 $n$ 个整数，表示 $r_1,\dots,r_n$。

第四行输入 $n$ 个整数，表示 $t_1,\dots,t_n$。保证 $p_i=0$ 时有 $t_i=0$。

第五行输入 $m$ 个整数，表示 $x_1,\dots,x_m$。
## 输出格式

对于每组数据，输出一行一个整数，表示为了解决所有问题至少需要花费的总时间。
## 样例

### 样例输入 #1
```
2
5 3 3
0 1 1 0 3
1 2 3 4 5
0 1 1 0 2
2 4 5
5 3 2
0 1 1 2 3
1 2 3 4 5
0 1 1 2 2
2 4 5

```
### 样例输出 #1
```
9
8

```
### 样例输入 #2
```
1
13 13 3
0 1 2 3 3 4 4 5 5 6 7 8 9
1 3 5 7 7 10 10 10 10 13 13 13 13
0 1 1 1 1 2 2 2 2 2 2 2 2
1 2 3 4 5 6 7 8 9 10 11 12 13

```
### 样例输出 #2
```
22

```
## 提示

对于所有数据，满足 $1\le T\le30$，$1\le n,m\le5000$，$1\le k\le5$，$0\le p_i<i$，$0\le r_i,t_i\le10^9$，$1\le x_i\le n$。


---

---
title: "[HNOI2007] 梦幻岛宝珠"
layout: "post"
diff: 省选/NOI-
pid: P3188
tag: ['动态规划 DP', '2007', '湖南', '背包 DP', '进制']
---
# [HNOI2007] 梦幻岛宝珠
## 题目描述

给你 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。

## 输入格式

输入文件中包含多组数据。每组数据的格式如下：

第一行是两个正整数 $n$ 和 $W$，分别表示宝石的数目和最多能带走的宝石重量。

接下来的 $n$ 行，每行有两个正整数 $w_i,v_i$，分别表示第 $i$ 颗宝石的重量和价值。

最后一组数据的后面有两个 $-1$，表示文件的结束。这两个 $-1$ 并不代表一组数据，你不需对这组数据输出结果。  

输入文件中数据的组数不超过 $20$。

## 输出格式

对于输入的每组数据，输出一个整数 $c$，表示小 P 最多能带走的宝石的总价值。  
每个结果整数 $c$ 单独占一行。

## 样例

### 样例输入 #1
```
4 10
8 9
5 8
4 6
2 5
4 13
8 9
5 8
4 6
2 5
16 75594681
393216 5533
2 77
32768 467
29360128 407840
112 68
24576 372
768 60
33554432 466099
16384 318
33554432 466090
2048 111
24576 350
9216 216
12582912 174768
16384 295
1024 76
-1 -1
```
### 样例输出 #1
```
14
19
1050650
```
## 提示

### 数据范围及约定

对于 $100\%$ 的数据，$1\le n \le 100$，$1\le W,w_i,v_i \le 2^{30}$。  
保证每个 $w_i$ 能写成 $a \times 2^b\space (a,b \in \mathbb N)$ 的形式，$a \leq 10$ , $b \leq 30$，且答案不超过 $2^{30}$。



---

---
title: "[APIO2008] 免费道路"
layout: "post"
diff: 省选/NOI-
pid: P3623
tag: ['2008', '并查集', 'APIO', 'Special Judge', '背包 DP', '生成树']
---
# [APIO2008] 免费道路
## 题目描述

 
新亚（New Asia）王国有 N 个村庄，由 M 条道路连接。其中一些道路是鹅卵石路，而其它道路是水泥路。保持道路免费运行需要一大笔费用，并且看上去 王国不可能保持所有道路免费。为此亟待制定一个新的道路维护计划。

国王已决定保持尽可能少的道路免费，但是两个不同的村庄之间都应该一条且仅由一条 且仅由一条免费道路的路径连接。同时，虽然水泥路更适合现代交通的需 要，但国王也认为走在鹅卵石路上是一件有趣的事情。所以，国王决定保持刚好 K 条鹅卵石路免费。

举例来说，假定新亚王国的村庄和道路如图 3(a)所示。如果国王希望保持两 条鹅卵石路免费，那么可以如图 3(b)中那样保持道路(1, 2)、(2, 3)、(3, 4)和(3, 5) 免费。该方案满足了国王的要求，因为：(1)两个村庄之间都有一条由免费道 路组成的路径；(2)免费的道路已尽可能少；(3)方案中刚好有两条鹅卵石道路 (2, 3)和(3, 4)

 ![](https://cdn.luogu.com.cn/upload/pic/4393.png) 

图 3: (a)新亚王国中村庄和道路的一个示例。实线标注的是水泥路，虚线标注 的是鹅卵石路。(b)一个保持两条鹅卵石路免费的维护方案。图中仅标出了免 费道路。


给定一个关于新亚王国村庄和道路的述以及国王决定保持免费的鹅卵石 道路数目，写一个程序确定是否存在一个道路维护计划以满足国王的要求，如果 存在则任意输出一个方案。

## 输入格式

输入第一行包含三个由空格隔开的整数：

N，村庄的数目(1≤N≤20,000)；

M，道路的数目(1≤M≤100,000)；

K，国王希望保持免费的鹅卵石道路数目(0≤K≤N - 1)。

此后 M 行述了新亚王国的道路，编号分别为 1 到 M。第(i+1)行述了第 i 条 道路的情况。用 3 个由空格隔开的整数述：

ui 和 vi，为第 i 条道路连接的两个村庄的编号，村庄编号为 1 到 N；

ci，表示第 i 条道路的类型。ci = 0 表示第 i 条道路是鹅卵石路，ci = 1 表 示第 i 条道路是水泥路。

输入数据保证一对村庄之间至多有一条道路连接

## 输出格式

如果满足国王要求的道路维护方案不存在，你的程序应该在输出第一行打印 no solution。 否则，你的程序应该输出一个符合要求的道路维护方案，也就是保持免费的 道路列表。按照输入中给定的那样输出免费的道路。如果有多种合法方案，你可 以任意输出一种。

## 样例

### 样例输入 #1
```
5 7 2 
1 3 0 
4 5 1 
3 2 0 
5 3 1 
4 3 0 
1 2 1 
4 2 1
```
### 样例输出 #1
```
3 2 0 
4 3 0 
5 3 1 
1 2 1 
```


---

---
title: "星空"
layout: "post"
diff: 省选/NOI-
pid: P3943
tag: ['O2优化', '背包 DP', '差分', '状压 DP']
---
# 星空
## 题目背景

pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv

```cpp
命运偷走如果只留下结果， 时间偷走初衷只留下了苦衷。
你来过，然后你走后，只留下星空。
```
## 题目描述

逃不掉的那一天还是来了，小 F 看着夜空发呆。

天上空荡荡的，没有一颗星星——大概是因为天上吹不散的乌云吧。

心里吹不散的乌云，就让它在那里吧，反正也没有机会去改变什么了。

小 C 拿来了一长串星型小灯泡，假装是星星，递给小 F，想让小 F 开心一点。不过，有着强迫症的小 F 发现，这串一共 $n$ 个灯泡的灯泡串上有 $k$ 个灯泡没有被点亮。小 F 决定和小 C 一起把这个灯泡串全部点亮。

不过，也许是因为过于笨拙，小 F 只能将其中连续一段的灯泡状态给翻转——点亮暗灯泡，熄灭亮灯泡。经过摸索，小 F 发现他一共能够翻转 $m$ 种长度的灯泡段中灯泡的状态。

小 C 和小 F 最终花了很长很长很长很长很长很长的时间把所有灯泡给全部点亮了。他们想知道他们是不是蠢了，因此他们找到了你，让你帮忙算算：在最优的情况下，至少需要几次操作才能把整个灯泡串给点亮？
## 输入格式

从标准输入中读入数据。

输入第 $1$ 行三个正整数 $n,k,m$。

输入第 $2$ 行 $k$ 个正整数，第 $i$ 个数表示第 $i$ 个被没点亮的灯泡的位置 $a_i$。

输入第 $3$ 行 $m$ 个正整数，第 $i$ 个数表示第 $i$ 种操作的长度 $b_i$。

保证所有 $b_i$ 互不相同；保证对于 $1\le i<k$，有 $a_i<a_{i+1}$；保证输入数据有解。
## 输出格式

输出标准输入中。

输出一行一个非负整数，表示最少操作次数。

## 样例

### 样例输入 #1
```
5 2 2 
1 5 
3 4
```
### 样例输出 #1
```
2   

```
## 提示

【样例 1 解释】

 ![](https://cdn.luogu.com.cn/upload/pic/9814.png) 

【数据范围与约定】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表

 ![](https://cdn.luogu.com.cn/upload/pic/9815.png) 

特殊性质：保证答案小于 4



---

---
title: "[SHOI2008] 循环的债务"
layout: "post"
diff: 省选/NOI-
pid: P4026
tag: ['动态规划 DP', '2008', '各省省选', '上海', '枚举', '背包 DP']
---
# [SHOI2008] 循环的债务
## 题目描述

Alice、Bob和Cynthia总是为他们之间混乱的债务而烦恼，终于有一天，他们决定坐下来一起解决这个问题。不过，鉴别钞票的真伪是一件很麻烦的事情，于是他们决定要在清还债务的时候尽可能少的交换现金。

比如说，Alice欠Bob 10元，而Cynthia和他俩互不相欠。现在假设Alice只有一张50元，Bob有3张10元和10张1元，Cynthia有3张20元。一种比较直接的做法是：Alice将50元交给Bob，而Bob将他身上的钱找给Alice，这样一共就会有14张钞票被交换。但这不是最好的做法，最好的做法是：Alice把50块给Cynthia，Cynthia再把两张20给Alice，另一张20给Bob，而Bob把一张10块给C，此时只有5张钞票被交换过。

没过多久他们就发现这是一个很棘手的问题，于是他们找到了精通数学的你为他们解决这个难题。

## 输入格式

输入的第一行包括三个整数：$x_1$、$x_2$、$x_3$（-1,000≤$x_1$，$x_2$，$x_3$≤1,000），其中

$x_1$代表Alice欠Bob的钱（如果$x_1$是负数，说明Bob欠了Alice的钱）

$x_2$代表Bob欠Cynthia的钱（如果$x_2$是负数，说明Cynthia欠了Bob的钱）

$x_3$代表Cynthia欠Alice的钱（如果$x_3$是负数，说明Alice欠了Cynthia的钱）

接下来有三行，每行包括6个自然数：

a100，a50，a20，a10，a5，a1

b100，b50，b20，b10，b5，b1

c100，c50，c20，c10，c5，c1

a100表示Alice拥有的100元钞票张数，b50表示Bob拥有的50元钞票张数，以此类推。另外，我们保证有a10+a5+a1≤30，b10+b5+b1≤30，c10+c5+c1≤30，而且三人总共拥有的钞票面值总额不会超过1,000。

## 输出格式

如果债务可以还清，则输出需要交换钞票的最少张数；如果不能还清，则输出“impossible”（注意单词全部小写，输出到文件时不要加引号）。

## 样例

### 样例输入 #1
```
10 0 0
0 1 0 0 0 0
0 0 0 3 0 10
0 0 3 0 0 0
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
-10 -10 -10
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
```
### 样例输出 #2
```
0
```
## 提示

对于30%的数据，$x_1$、$x_2$、$x_3$ ≤ |50|。
对于100%的数据，$x_1$、$x_2$、$x_3$ ≤ |1,000|。



---

---
title: "[JSOI2008] 魔兽地图"
layout: "post"
diff: 省选/NOI-
pid: P4037
tag: ['2008', '各省省选', '江苏', 'O2优化', '枚举', '背包 DP']
---
# [JSOI2008] 魔兽地图
## 题目描述

DotR (Defense of the Robots) Allstars是一个风靡全球的魔兽地图，他的规则简单与同样流行的地图DotA (Defense of the Ancients) Allstars。

DotR里面的英雄只有一个属性——力量。他们需要购买装备来提升自己的力量值，每件装备都可以使佩戴它的英雄的力量值提高固定的点数，所以英雄的力量值等于它购买的所有装备的力量值之和。装备分为基本装备和高级装备两种。基本装备可以直接从商店里面用金币购买，而高级装备需要用基本装备或者较低级的高级装备来合成，合成不需要附加的金币。装备的合成路线可以用一棵树来表示。

比如，Sange and Yasha的合成需要Sange,Yasha和Sange and Yasha Recipe Scroll三样物品。其中Sange又要用Ogre Axe, Belt of Giant Strength和 Sange Recipe Scroll合成。每件基本装备都有数量限制，这限制了你不能无限制地合成某些性价比很高的装备。

现在，英雄Spectre有M个金币，他想用这些钱购买装备使自己的力量值尽量高。你能帮帮他吗？他会教你魔法Haunt（幽灵附体）作为回报的。

## 输入格式

第一行包含两个整数，N (1 <= n <= 51) 和 m (0 <= m <= 2,000)。分别表示装备的种类数和金币数。装备用1到N的整数编号。

接下来的N行，按照装备1到装备n的顺序，每行描述一种装备。

每一行的第一个非负整数表示这个装备贡献的力量值。

接下来的非空字符表示这种装备是基本装备还是高级装备，A表示高级装备，B表示基本装备。如果是基本装备，紧接着的两个正整数分别表示它的单价（单位为金币）和数量限制（不超过100）。如果是高级装备，后面紧跟着一个正整数C，表示这个高级装备需要C种低级装备。后面的2C个数，依次描述某个低级装备的种类和需要的个数。

## 输出格式

第一行包含一个整数S，表示最多可以提升多少点力量值。

## 样例

### 样例输入 #1
```
10 59
5 A 3 6 1 9 2 10 1
1 B 5 3
1 B 4 3
1 B 2 3
8 A 3 2 1 3 1 7 1
1 B 5 3
5 B 3 3
15 A 3 1 1 5 1 4 1
1 B 3 5
1 B 4 3
```
### 样例输出 #1
```
33
```


---

---
title: "采摘毒瘤"
layout: "post"
diff: 省选/NOI-
pid: P4241
tag: ['枚举', '背包 DP']
---
# 采摘毒瘤
## 题目背景

Salamander见到路边有如此多的毒瘤，于是见猎心喜，从家里拿来了一个大袋子，准备将一些毒瘤带回家。

## 题目描述

路边共有$n$种不同的毒瘤，第$i$种毒瘤有$k_i$个，每个需要占据$d_i$的空间。Salamander的袋子能装下的最大体积为$m$。


Salamander是一个很贪心的人，不过他也**不要求**带尽可能多或是总体积尽可能大的毒瘤回家，他只要求袋子里**再也装不下剩余的任何一种毒瘤**。


Salamander想知道有多少种不同的装毒瘤的方案。两种方案不同当且仅当取的毒瘤种类不同或者至少有一种毒瘤取的数量不同。由于方案数可能太多，请输出答案对$19260817$取模后的结果。

## 输入格式

第一行包括两个正整数$n$、$m$，表示毒瘤的种类数和袋子的大小。

接下来的$n$行，每行两个正整数$k_i$、$d_i$，表示一种毒瘤。

## 输出格式

一行，表示不同的方案数对$19260817$取模后的结果。

## 样例

### 样例输入 #1
```
2 5
2 3
3 1
```
### 样例输出 #1
```
2
```
## 提示

###样例解释：

两种方案如下：

1.取1个第一种毒瘤和2个第二种毒瘤。

2.取3个第二种毒瘤。


$~$
$~$

对于10%的数据，$1\leq n,k_i,d_i\leq 10$，$1\leq m\leq 100$；

对于30%的数据，$1\leq n,k_i,d_i\leq 50$，$1\leq m\leq 5000$；

对于另外20%的数据，$k_i=1$；

对于100%的数据，$1\leq n,k_i,d_i\leq 500$，$1\leq m\leq 10^5$。



---

---
title: "付公主的背包"
layout: "post"
diff: 省选/NOI-
pid: P4389
tag: ['数学', 'O2优化', '背包 DP', '生成函数', '快速傅里叶变换 FFT']
---
# 付公主的背包
## 题目背景

付公主有一个可爱的背包qwq


## 题目描述

这个背包最多可以装 $10^5$ 大小的东西

付公主有 $n$ 种商品，她要准备出摊了

每种商品体积为 $v_i$，都有无限件

给定 $m$，对于 $s\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数

## 输入格式

第一行两个正整数 $n,m$。
第二行 $n$ 个正整数，表示每种商品的体积。

## 输出格式

输出 $m$ 行，第 $i$ 行代表 $s=i$ 时方案数，对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
2 4
1 2
```
### 样例输出 #1
```
1
2
2
3
```
## 提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n,m \le 3000$；  
对于 $60\%$ 的数据，纯随机生成；   
对于 $100\%$ 的数据， $1\le n,m \le 10^5$，$1\le v_i \le m$。


---

---
title: "[JSOI2018] 潜入行动"
layout: "post"
diff: 省选/NOI-
pid: P4516
tag: ['2018', '各省省选', '江苏', '背包 DP']
---
# [JSOI2018] 潜入行动
## 题目描述

外星人又双叒叕要攻打地球了，外星母舰已经向地球航行！这一次，``JYY`` 已经联系好了黄金舰队，打算联合所有 ``JSOIer`` 抵御外星人的进攻。

在黄金舰队就位之前，``JYY`` 打算事先了解外星人的进攻计划。现在，携带了监听设备的特工已经秘密潜入了外星人的母舰，准备对外星人的通信实施监听。

外星人的母舰可以看成是一棵 $n$ 个节点、 $n-1$ 条边的**无向树**，树上的节点用 $1,2,\cdots,n$ 编号。``JYY`` 的特工已经装备了隐形模块，可以在外星人母舰中不受限制地活动，可以神不知鬼不觉地在节点上安装监听设备。

如果在节点 $u$ 上安装监听设备，则 ``JYY`` 能够监听与 $u$ **直接相邻**所有的节点的通信。换言之，如果在节点 $u$ 安装监听设备，则对于树中每一条边 $(u,v)$ ，节点 $v$ 都会被监听。特别注意**放置在节点 $u$ 的监听设备并不监听 $u$ 本身的通信**，这是 ``JYY`` 特别为了防止外星人察觉部署的战术。

``JYY`` 的特工一共携带了 $k$ 个监听设备，现在 ``JYY`` 想知道，有多少种不同的放置监听设备的方法，能够使得母舰上**所有节点**的通信都被监听？为了避免浪费，**每个节点至多只能安装一个监听设备，且监听设备必须被用完**。

## 输入格式

输入第一行包含两个整数 $n,k$ ，表示母舰节点的数量 $n$ 和监听设备的数量 $k$ 。
接下来 $n-1$ 行，每行两个整数 $u,v$ $(1\le u,v\le n)$，表示树中的一条边。
## 输出格式

输出一行，表示满足条件的方案数。因为答案可能很大，你只需要输出答案 $\text{mod 1,000,000,007}$ 的余数即可。
## 样例

### 样例输入 #1
```
5 3
1 2
2 3
3 4
4 5
```
### 样例输出 #1
```
1
```
## 提示

**样例 1 解释**

样例数据是一条链 $1-2-3-4-5$ 。首先，节点 $2$ 和 $4$ 必须放置监听设备，否则 $1,5$ 将无法被监听（放置的监听设备无法监听它所在的节点）。剩下一个设备必须放置在 $3$ 号节点以同时监听 $2,4$ 。因此在 $2,3,4$ 节点放置监听设备是唯一合法的方案。

**数据范围**

存在 $10\%$ 的数据，$1 \le n \le 20$ ；

存在另外 $10\%$ 的数据，$1 \le n \le 100$ ；

存在另外 $10\%$ 的数据，$1 \le k \le 10$ ；

存在另外 $10\%$ 的数据，输入的树保证是一条链；

对于所有数据，$1\le n\le 10^5$​ ，$1\le k\le \min\{n,100\}$ 。


---

---
title: "Zrz_orz Loves Secondary Element"
layout: "post"
diff: 省选/NOI-
pid: P4866
tag: ['动态规划 DP', '枚举', '背包 DP']
---
# Zrz_orz Loves Secondary Element
## 题目背景

zrz_orz赘喜欢二次元辣！！
## 题目描述

众所周知的是，zrz_orz是全机房最强的死宅。~~他甚至使用嘴遁使得Samcompu不得不在自己的网站上挂上时崎狂三~~。(话说Samcompu好像醒悟了又把狂三给去掉了。)作为新一代死宅的一员，从电脑壁纸到输入法皮肤，到处都是二次元的痕迹。所以，他经常在梦里梦见一些二次元的角色。

zrz_orz的梦，是由$n$个点和$n-1$条边构成的连通图。其中有$m$个节点上有一个二次元的角色。对于zrz_orz来说，每一个二次元的角色都有一个对应的$pos_i$和$val_i$表示这个角色在图上的哪一个节点以及与之聊天对zrz_orz来说会增加多少愉悦值。(由于某种原因，聊天的过程可以不用计入时间。)可惜的是，zrz_orz每一次做梦都只会做$tim_i$个单位时间。现在请你告诉他，他每一次做梦最多能获得多少愉悦值。

注：

1.zrz_orz每一次做梦都只会从1号节点开始走！

2.每一次做梦后zrz_orz梦境中的图都不会改变！

**3.每一次做完梦之后zrz_orz就必须要回到1号节点，否则他就会迷失在梦境里！**
## 输入格式

第1行三个正整数$N$,$M$,$T$表示图的节点数、二次元角色的数量、做梦的天数。

接下来$N-1$行每行三个正整数$u_i$,$v_i$,$w_i$表示第$i$条边连接的两个节点以及zrz_orz走过这条边所花费的时间。

接下来$M$行每行两个正整数$pos_j$和$val_j$表示第$j$个二次元角色在节点上的位置以及能给zrz_orz带来的愉悦值。

接下来$T$行每行一个正整数$tim_k$表示第$k$天zrz_orz做梦的时间。
## 输出格式

一共$T$行。每一行包括一个正整数表示zrz_orz每天最多能获得的最大愉悦值。
## 样例

### 样例输入 #1
```
7 3 3
1 2 2
1 3 1
2 4 1
2 5 10
3 6 1
6 7 2
4 5
5 50
7 7
1
10
100

```
### 样例输出 #1
```
0
7
62
```
## 提示

![](https://cdn.luogu.com.cn/upload/pic/25600.png)

第一天哪里都去不了。

第二天1->3->6->7->6->3->1获得最大愉悦值为7。

第三天所有的地方都可以走一遍。

Subtask 1(20 pts): 

$ 1 \leqslant T \leqslant 10 \qquad 1 \leqslant N \leqslant 1000 \qquad 1 \leqslant M \leqslant 20 \qquad 1 \leqslant  tim_k \leqslant 1000$

Subtask 2(40 pts):

$ 1 \leqslant T \leqslant 10^5 \qquad 1 \leqslant N \leqslant 10^5 \qquad 1 \leqslant M \leqslant 20 \qquad 1 \leqslant  tim_k \leqslant 10^5$

Subtask 3(40 pts):

$ 1 \leqslant T \leqslant 5*10^4 \qquad 1 \leqslant N \leqslant 5000 \qquad 1 \leqslant M \leqslant 100 \qquad 1 \leqslant  tim_k \leqslant 100 \qquad 1 \leqslant w_i \leqslant 5$

For all test points:

$ 1 \leqslant pos_j,u_i,v_i \leqslant N \qquad 1 \leqslant \sum val_j \leqslant 2e9 \qquad 1 \leqslant w_i \leqslant 20 \qquad 1 \leqslant tim_k \leqslant 10^5 $

注意: 标记的分数就是这个Subtask的分数，每一个Subtask必须全对才能得分。Subtask 2的时限为1.5s。

$$ \color{white} \text{NOIP 2合1} $$


---

---
title: "[Cnoi2019] 青染之心"
layout: "post"
diff: 省选/NOI-
pid: P5391
tag: ['2019', 'O2优化', '背包 DP', '树链剖分']
---
# [Cnoi2019] 青染之心
## 题目背景

这里原本有着一个史诗般的可歌可泣的背景故事，可是这里空太小，写不下。
## 题目描述

Cirno 初始有一个空的物品序列，一个大小为 $V$ 的背包，现在你有 $q$ 个操作，分为两种：

- `add x y`：表示加入一种体积为 $x$, 价值为 $y$ 的物品到序列末尾。
- `erase`：表示删除序列末尾的物品。

在每个操作结束以后，你需要求出：

假设序列中的每种物品都有无穷多个，Cirno 的背包可以装下的物品最大价值和。
## 输入格式

第一行，两个整数，$q$，$V$ 分别表示操作数和背包大小。

以下 $q$ 行，每行一个操作。
## 输出格式

$q$ 行，每行表示每次操作后的答案。
## 样例

### 样例输入 #1
```
4 10
add 10 3
add 5 2
add 3 3
erase
```
### 样例输出 #1
```
3
4
9
4
```
## 提示

对于 $100\%$ 的数据 $1\le q, V, x, y \le 2\times10^4 $


---

---
title: "好吃的题目"
layout: "post"
diff: 省选/NOI-
pid: P6240
tag: ['O2优化', '分治', '背包 DP']
---
# 好吃的题目
## 题目背景

这是一道好吃的题目。
## 题目描述

有一条小吃街，从左到右依次排列着 $n$ 个商店，从 $1$ 开始标号。

第 $i$ 个商店会只出售一种小吃，热量为 $h_i$，美味度为 $w_i$。

现在有 $m$ 个吃货要来逛街，第 $i$ 个吃货会在 $[l_i,r_i]$ 的商店内寻找小吃，而且为了防止太胖，最多能摄入 $t_i$ 的热量。

小吃吃多了会腻，所以同一个商店的小吃只能吃一次。

现在每个吃货想知道自己最多能得到多少美味度。
## 输入格式

第一行为两个整数，分别表示 $n,m$。

第二行为 $n$ 个整数，第 $i$ 个整数表示 $h_i$。

第三行为 $n$ 个整数，第 $i$ 个整数表示 $w_i$。

第 $4$ 到第 $(m + 3)$ 行，每行三个整数，第 $(i + 3)$ 行的整数 $l_i, r_i, t_i$ 分别表示第 $i$ 个吃货的参数。

## 输出格式

对于每个吃货，输出一行一个整数，表示最大的美味度和。
## 样例

### 样例输入 #1
```
8 5
10 31 36 30 36 24 29 29
59 152 284 202 282 156 277 212
3 5 81
4 5 75
7 8 71
1 3 92
4 4 95

```
### 样例输出 #1
```
566
484
489
495
202
```
### 样例输入 #2
```
15 10
5 15 18 15 18 12 14 14 10 15 17 18 9 7 6 
11 31 26 34 19 17 15 25 11 34 18 26 21 8 11 
7 15 31
2 9 67
8 15 77
3 13 43
6 7 98
2 2 110
3 13 26
11 11 84
7 14 25
4 6 90
```
### 样例输出 #2
```
66
118
128
89
32
31
55
18
55
70
```
## 提示

#### 【样例输入输出解释】

**样例 1 解释**

对于第一组数据的第一个吃货，可以选择第 $3$ 个商店和第 $5$ 个商店。

摄入的热量为 $36+36=72\leq 81$，获得美味度为 $284+282=566$。

**样例 2 解释**

对于第二组数据的第一个吃货，可以选择第 $10$，第 $13$，第 $15$ 个商店。

摄入的热量为 $15+9+6=30\leq 31$，获得美味度为 $34+21+11=66$。

---

#### 【数据规模与约定】

- 对于 $30\%$ 的数据，满足 $n,m\leq 500$。
- 对于 $60\%$ 的数据，满足 $n\leq 4\times 10^4$，$m\leq 5000$。
- 对于 $100\%$ 的数据，满足 $1 \leq n\leq 4\times 10^4$，$1 \leq m\leq 2\times 10^5$，$1\leq l_i\leq r_i\leq n$，$1\leq h_i,t_i\leq 200$，$1\leq w_i\leq 10^7$。







---

---
title: "Shopping"
layout: "post"
diff: 省选/NOI-
pid: P6326
tag: ['点分治', '单调队列', 'O2优化', '背包 DP']
---
# Shopping
## 题目描述

马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。

第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $p$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $p$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。

这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？


## 输入格式

输入第一行一个正整数 $T$ ，表示测试数据组数。

对于每组数据，

第一行两个正整数 $n,m$  。

第二行 $n$ 个非负整数 $w_1,w_2...w_n$ 。

第三行 $n$ 个正整数 $c_1,c_2...c_n$ 。

第四行 $n$ 个正整数 $d_1,d_2...d_n$ 。

接下来 $n-1$ 行每行两个正整数 $u,v$ 表示 $u$ 和 $v$之间有一条道路。
## 输出格式

输出共 $T$ 行，每行一个整数，表示最大的喜爱度之和。
## 样例

### 样例输入 #1
```
1
3 2
1 2 3
1 1 1
1 2 1
1 2
1 3
```
### 样例输出 #1
```
4
```
## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1 \leq c_i \leq m$，$1\le d_i\le 2000$。

#### 说明

题目来源：BZOJ4182。


---

---
title: "[ICPC 2014 WF] Buffed Buffet"
layout: "post"
diff: 省选/NOI-
pid: P6893
tag: ['动态规划 DP', '2014', 'Special Judge', '背包 DP', 'ICPC']
---
# [ICPC 2014 WF] Buffed Buffet
## 题目描述

You are buying lunch at a buffet. A number of different dishes are available, and you can mix and match them to your heart’s desire. Some of the dishes, such as dumplings and roasted potatoes, consist of pieces of roughly equal size, and you can pick an integral number of such pieces (no splitting is allowed). Refer to these as “discrete dishes.” Other dishes, such as tzatziki or mashed potatoes, are fluid and you can pick an arbitrary real-valued amount of them. Refer to this second type as “continuous dishes.”

Of course, you like some of the dishes more than others, but how much you like a dish also depends on how much of it you have already eaten. For instance, even if you generally prefer dumplings to potatoes, you might prefer a potato over a dumpling if you have already eaten ten dumplings. To model this, each dish $i$ has an initial tastiness $t_ i$, and a rate of decay of the tastiness $\Delta t_ i$. For discrete dishes, the tastiness you experience when eating the $n^{th}$ item of the dish is $t_ i - (n-1)\Delta t_ i$. For continuous dishes, the tastiness you experience when eating an infinitesimal amount $d x$ grams of the dish after already having eaten $x$ grams is $(t_ i - x \Delta t_ i) d x$. In other words, the respective total amounts of tastiness you experience when eating $N$ items of a discrete dish or $X$ grams of a continuous dish are as follows:

$$\begin{aligned} \sum _{n=1}^{N} (t_ i - (n-1)\Delta t_ i) & &  \text {and} & & \int _{0}^ X (t_ i - x\Delta t_ i) dx  \end{aligned} $$

For simplicity, do not take into account that different dishes may or may not go well together, so define the total tastiness that you experience from a meal as the sum of the total tastinesses of the individual dishes in the meal (and the same goes for the weight of a meal – there are no food antiparticles in the buffet!).

You have spent days of painstaking research determining the numbers $t_ i$ and $\Delta t_ i$ for each of the dishes in the buffet. All that remains is to compute the maximum possible total tastiness that can be achieved in a meal of weight $w$. Better hurry up, lunch is going to be served soon!
## 输入格式

The input consists of a single test case. The first line of input consists of two integers $d$ and $w$ ($1 \le d \le {250}$ and $1 \le w \le {10\, 000}$), where $d$ is the number of different dishes at the buffet and $w$ is the desired total weight of your meal in grams.

Then follow $d$ lines, the $i^{th}$ of which describes the $i^{th}$ dish. Each dish description is in one of the following two forms:

A description of the form “D $w_ i$ $t_ i$ $\Delta t_ i$” indicates that this is a discrete dish where each item weighs $w_ i$ grams, with initial tastiness $t_ i$ and decay of tastiness $\Delta t_ i$.

A description of the form “C $t_ i$ $\Delta t_ i$” indicates that this is a continuous dish with initial tastiness $t_ i$ and decay of tastiness $\Delta t_ i$.

The numbers $w_ i$, $t_ i$, and $\Delta t_ i$ are integers satisfying $1 \le w_ i \le {10\, 000}$ and $0 \le t_ i, \Delta t_ i \le {10\, 000}$.
## 输出格式

Display the maximum possible total tastiness of a meal of weight $w$ based on the available dishes. Give the answer with a relative or absolute error of at most $10^{-6}$. If it is impossible to make a meal of total weight exactly $w$ based on the available dishes, display impossible.
## 样例

### 样例输入 #1
```
2 15
D 4 10 1
C 6 1

```
### 样例输出 #1
```
40.500000000

```
### 样例输入 #2
```
3 15
D 4 10 1
C 6 1
C 9 3

```
### 样例输出 #2
```
49.000000000

```
### 样例输入 #3
```
2 19
D 4 5 1
D 6 3 2

```
### 样例输出 #3
```
impossible

```
## 提示

Time limit: 3000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2014
## 题目翻译

### 题目描述

自助餐厅里有 $n$ 种食物，分为两大类，为 “离散食物”和“连续食物”。你可以通过吃食物来获得收益。

离散食物用 $(w,t_0,\Delta t)$ 描述。对于这种食物，你只能吃整数个，每个重为 $w$。吃的第一个收益为 $t_0$，后面每吃一个收益减少 $\Delta t$。具体的，吃的第 $i$ 个这种食物 （从 $1$ 开始标号），收益为 $t_0-(i-1)\Delta t$。

连续食物用 $(t_0,\Delta t)$ 描述。对于这种食物，你可以吃任意食物的重量。如果你吃的重量为 $w$，获得的收益是 $t_0w-\dfrac{1}{2}\Delta t w^2$。

你现在要吃重量和 **恰好** 为 $W$ 的食物。最大化你的收益。

### 数据范围

$n\le 250,W\le 10000$。

对于离散食物，满足 $1\le w\le 10000$。

对于所有食物，满足 $0\le t_0,t\le 10000$。

### 输入格式

第一行是 $n,W$，接下来每行先来一个字母，如果是 C 表示连续食物，后面跟两个数表示 $t_0,\Delta t$；如果是 D 表示离散食物，后面跟三个数，表示 $w,t_0,\Delta t$。

### 输出格式

一行一个数表示答案。相对或绝对误差不超过 $1e-6$。


---

---
title: "[yLOI2020] 牵丝戏"
layout: "post"
diff: 省选/NOI-
pid: P7097
tag: ['动态规划 DP', '博弈论', '2020', 'O2优化', '背包 DP']
---
# [yLOI2020] 牵丝戏
## 题目背景

> 风雪依稀秋白发尾， 灯火葳蕤，揉皱你眼眉。  
> 假如你舍一滴泪，假如老去我能陪。  
> 烟波里成灰，也去得完美。 

——银临 & Aki阿杰《牵丝戏》
## 题目描述

扶苏和扶咕咕最近在玩一款叫做「ddt」的游戏，因为玩「ddt」时一直在循环《牵丝戏》，所以想到牵丝戏就想到了这个游戏。

为了简化问题，我们认为这是一款一对一回合制游戏。双方玩家各有一个属性，被称为 delay 值，简称 $d$ 值。$d$ 值会根据回合中玩家使用的道具类型和数量来进行相应的增加。我们定义玩家 $x$ 的回合为玩家 $x$ 从发动攻击到结束的整个过程。**在玩家 $x$ 的回合中，只有玩家 $x$ 可以使用道具和发动攻击，并且玩家 $x$ 一定会发动攻击**。当一个玩家的回合结束以后，下一回合将是两个玩家中 $d$ 值**较小**的玩家的回合。当两个玩家的 $d$ 值相同时，因为扶苏氪金很多，下一回合一定是**扶苏的回合**。

这款游戏共有 $m$ 种道具，第 $i$ 种道具会将本回合的伤害增加**不计算其他道具的原始伤害**的 $\frac{k_i}{10^5}$ 倍，同时会增加 $p_i$ 点 $d$ 值。每回合**每种道具只能使用一次，本回合的道具不会对下回合产生伤害增益效果**。同时，每回合结束以后，发动攻击的玩家一定会增加 $w$ 点 $d$ 值。

而使用道具是受到双方 $d$ 值差限制的。具体的，任何回合所使用的道具应该满足本回合结束以后双方 $d$ 值（包括发动攻击的玩家一定增加的 $w$ 点 $d$ 值）之差的绝对值**不超过** $100$。一个显然的事实是，只要保证了 $w \le 100$，玩家就一定存在一种选择道具的方法（包括不选择），来满足这个限制。

例如，在扶咕咕的回合中，若她的原始伤害 $t=10^5$，初始时 $d$ 值 $d_0=3$，规定 $w=2$，她使用了两个道具，$k_1=114$，$k_2=514$，$p_1=19$，$p_2=81$，那么本回合她造成的伤害为 

$$t + t \times k_1 + t \times k_2 = 10^5 + 114 + 514 =  100628$$

她回合结束后的 $d$ 值为

$$d_0 + w + p_1 + p_2 = 3 + 2 + 19 + 81 = 105$$

而假如下回合还是她的回合，并且她没有使用道具，那么她下回合造成的伤害为 

$$t =  100000$$

她下回合结束后的 $d$ 值为 

$$105 + w = 105 + 2 = 107$$

现在扶苏和扶咕咕正在对战。给定游戏的道具列表，和他们的原始伤害、 $d$ 值。游戏一共会进行 $n$ 回合，不妨认为无论造成多大的伤害，双方都不会死亡。请你最大化「扶苏对扶咕咕造成的伤害 - 扶咕咕对扶苏造成的伤害」这个差的值。

当然，扶咕咕也会尽可能最大化「她对扶苏造成伤害 - 扶苏对她造成伤害」的值。不妨认为扶苏是 yLOI 世界中最聪明的男孩子，扶咕咕是 yLOI 世界中最聪明的女孩子，也就是**他们都会选择最优的策略来使用道具而不会出错**，题目所求即为在这种情况下伤害差的最大值。
## 输入格式

第一行有一个整数，表示该测试点所在的子任务编号 $T$。   
第二行有三个整数，分别表示游戏的回合数 $n$，游戏的装备数 $m$ 以及每回合固定增加的 $d$ 值 $w$。   
第三行有 $m$ 个整数，第 $i$ 个整数表示 $k_i$。   
第四行有 $m$ 个整数，第 $i$ 个整数表示 $p_i$。   
第五行有四个整数，依次表示扶苏的初始伤害 $x_a$，扶咕咕的初始伤害 $x_b$，扶苏的初始 $d$ 值 $d_a$，扶咕咕的初始 $d$ 值 $d_b$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
0
3 2 1
50 1
20 100
100000 200000 2 3
```
### 样例输出 #1
```
-52
```
## 提示

### 样例 1 解释

- 第一回合开始前，扶苏 $d$ 值为 $2$，扶咕咕 $d$ 值为 $3$，第一回合由扶苏出手。扶苏不使用道具，伤害为 $100000$，$d$ 值增加 $1$，总伤害差为 $100000$。
- 第一回合结束后，双方 $d$ 值均为 $3$，第二回合由扶苏出手。扶苏使用第一个道具，伤害为 $100050$，$d$ 值增加 $21$，总伤害差为 $200050$。
- 第二回合结束后，扶苏 $d$ 值为 $24$，扶咕咕 $d$ 值为 $3$，第三回合由扶咕咕出手。扶咕咕使用 $1$ 、 $2$ 两个道具，伤害为 $200102$，$d$ 值增加 $121$，总伤害差为 $-52$。这回合结束后，双方 $d$ 值差恰好为 $100$，符合要求。

### 数据规模与约定


**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$10$ 分）：保证 $m=0$。
- 子任务 $3$（$15$ 分）：保证 $n,m \le 5$。
- 子任务 $4$（$20$ 分）：保证 $n \le 3$。
- 子任务 $5$（$20$ 分）：保证 $m \le 10$。
- 子任务 $6$（$30$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^3$，$0 \le m \le 10^5$，$1 \le p_i,w \le 100$，$1 \le x_a,x_b,k_a,d_a,d_b \le 10^9$，$x_a$ 与 $x_b$ 是 $10^5$ 的倍数，$1 \le |d_a-d_b| \le 100$。

### 提示

共有 4 个样例文件，请见附加文件中的 opera.zip。  
对于样例 2，满足 $m = 0$。  
对于样例 3，满足 $n \leq 3$。


---

---
title: "[THUPC 2017] 钦妹的玩具商店"
layout: "post"
diff: 省选/NOI-
pid: P7432
tag: ['动态规划 DP', '2017', 'O2优化', '背包 DP', '分块', 'THUPC']
---
# [THUPC 2017] 钦妹的玩具商店
## 题目描述

钦妹和弗雷兹在 C 市有一个玩具店，店里有 $n$ 种玩具，编号依次为 $1,2,...,n$，第 $i$ 件玩具的单价为 $c_i$ 元，一个该玩具提供的愉悦度为  $v_i$。

突然有一天，C 市来了 $m$ 个小朋友。据可靠消息，接下来 $Q$ 天，这些小朋友每天都会来店里买东西，其中第 $i$ 个小朋友每天都会带 $i$ 元  （$1\le i\le m$）。

由于某些玩具不是很优秀，所以每天都会有不同的玩具被禁止出售给小朋友。具体来说，在第 $i$ 天，编号在区间 $[l_i,r_i]$ 内的物品小朋友是不能购买的。

除此之外，为了防止小朋友们太愉悦，每件玩具都有一个限购件数  $t_i$。也就是说，对于第 $i$ 种玩具，每个小朋友在每一天的购买件数都必须为不超过 $t_i$ 的非负整数。

现在，对于每一天，你想知道：所有小朋友所能获得的最大愉悦度之和（对 $10^8+7$ 取模）；所有小朋友所能获得的最大愉悦度的异或和（异或运算是 $\operatorname{xor}$ 运算，即 C++/Java/Python 中的 `^` 运算）。

本题强制在线，具体规则在输入描述中体现。
## 输入格式

从标准输入读入数据。

输入包含多组数据。第一行有一个整数  $T$，表示测试数据的组数，对于每组数据：

第一行输入三个整数 $n,m,Q$ 分别表示玩具数目、小朋友的数目以及天数。

第二行 $n$ 个非负整数，分别描述每件玩具的单价  $c_1,c_2,...,c_n$。

第三行 $n$ 个非负整数，分别描述每件玩具的愉悦度 $v_1,v_2,...,v_n$ 。

第四行 $n$ 个非负整数，分别描述每件玩具的限购次数  $t_1,t_2,...,t_n$。

第五行到第 $Q+4$ 行，每行两个描述区间的参数  $x,y$。第  行和前一天的答案共同描述了第 $i$ 天禁止购买的编号区间，假设前一天的最大愉悦度之和为 $\operatorname{lastans}$ ，那么当天的 $l_i,r_i$ 满足下式：
$$l_i=\min((x+\operatorname{lastans}-1)\bmod n+1,(y+\operatorname{lastans}-1\bmod n+1))$$
$$r_i=\max((x+\operatorname{lastans}-1)\bmod n+1,(y+\operatorname{lastans}-1\bmod n+1))$$
在第一天时，我们认为 $\operatorname{lastans}=0$ 。保证  $1\le x,y\le n$。
## 输出格式

输出到标准输出。

对于每一组数据，输出 $Q$ 行，每行 $2$ 个整数，依次表示所有小朋友能够获得的最大愉悦度之和（对 $10^8+7$ 取模）以及异或和。
## 样例

### 样例输入 #1
```
2
3 10 3
2 3 3
20 50 24
3 1 10
1 1
2 2
3 3
2 7 3
6 7
1 2
1 1
1 1
2 2
1 2
```
### 样例输出 #1
```
568 120
660 20
660 20
2 2
2 0
0 0
```
## 提示

对于所有的数据，$1\le n,m,Q,c_i,t_i\le 10^3$，$1\le v_i\le 2.5\times 10^5$，$\sum n,\sum m,\sum Q\le 10^4$。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。


---

---
title: "「Wdsr-2.5」未来水妖集市"
layout: "post"
diff: 省选/NOI-
pid: P7507
tag: ['2021', '洛谷原创', 'O2优化', '背包 DP', '分块']
---
# 「Wdsr-2.5」未来水妖集市
## 题目背景

每年，河城荷取（河童）都要为未来水妖集市准备展品，以及用于销售的商品。于是河童会生产大批量的产品。

为了提高生产效率，河童决定搭建一条生产线。具体而言，河童会利用她的机械臂，构建出一长串的机器。每个机器只会对原材料进行若干次加工，最终输出成品。

由于河童需要调试设备，于是机械臂每次操作后，河童会用一些询问确定这条生产线目前的性能如何。为了顺利完成生产任务，河童找到了你，希望你写一个程序告诉她每次操作后生产线的性能。
## 题目描述

初始时原材料会有一个初始权值 。然后它会经过若干个机器的加工，花费若干点**加工指数**，得到最终产品。

河童的机器有两种：

- 0 型：每次加工花费 $v_i$ 的加工指数，让材料的附加值增加 $w_i$ 。材料经过时**最多只能加工一次**。
- 1 型：每次加工花费 $v_i$ 的加工指数，让材料的附加值增加 $w_i$ 。材料经过时**加工次数无限制**。

现在河童会利用一个机械臂来设计这套工艺流程。初始时，流水线上没有一台机器，机械臂放在位置 $0$。机器的位置编号是从 $1$ 开始的。现在河童会告诉你加工指数的最大值 $v$ ，然后她会下达 $q$ 个命令。不妨设每个指令执行前，机械臂的位置在 $p$ 。

每个指令的格式为 $\colorbox{#f0f0f0}\verb!opt ti vi wi xi yi!$ ，其中 $opt$ 表示操作的种类。共有如下几种：

1. **右移**：将机械臂向右移动一格，即 $p\gets p+1$。
2. **左移**：将机械臂向左移动一格，即 $p\gets p-1$。
3. **插入机器**：在机械臂当前位置插入一个机器，它的类型为 $t_i$ ，每次消耗的加工指数为 $v_i$ ，材料的附加值会增加 $w_i$ ，插入的机器的位置为 $p+1$ 。机械臂位置不变，但是被插入的机器右侧的机器都会向右移动一格。
4. **删除机器**：在机械臂当前位置移除一个机器，移除的机器位置为 $p+1$ 。移除机器后机械臂位置不变，但是被移除的机器右侧的机器都会向左移动一格。
5. **修改机器**：在机械臂当前位置修改一个机器的参数。即修改的机器的位置为 $p+1$ 。

对于操作 1, 2, 4，请忽略参数 $\colorbox{#f0f0f0}\verb!ti vi wi!$ 。

每次操作完，河童会询问你，如果一个初始权值为 $x_i$ 的物品从左侧起第一个机器进去，直到从右边机器出来，依次加工，消耗最多 $y_i$ 点加工点数（ $y_i\le v$ ），这个物品可以获得的最大权值。特别地，如果此时没有一台机器，此物品权值不变。

假设某一时刻共有 $u$ 台机器，那么数据保证在此时刻机械臂的位置必然在 $[0,u]$ 内。
## 输入格式

第一行两个正整数 $q,v$ ，含义如题面所述。

接下来 $q$ 行，每行 $6$ 个正整数 $opt',t_i',v_i',w_i',x_i',y_i'$ 。你需要**将它们分别异或上** $\boldsymbol{last}$ 来获得真实的 $opt,t_i,v_i,w_i,x_i,y_i$ 。其中 $last$ 为上次输出的结果。特别地，初始时 $last=0$ 。
## 输出格式

输出共 $q$ 行，每行一个正整数，表示每次询问的答案。
## 样例

### 样例输入 #1
```
6 10
3 0 4 5 1000 7
1004 1005 1004 1004 5 997
1006 1004 1000 999 5 999
1017 1021 1023 1023 20 1019
1012 1009 1009 1009 24 1018
1007 1004 1004 1004 5 997

```
### 样例输出 #1
```
1005
1005
1020
1008
1005
1005

```
## 提示

#### 样例 1 说明

解码后的输入数据：

```plain
6 10
3 0 4 5 1000 7
1 0 1 1 1000 8
3 1 5 10 1000 10
5 1 3 3 1000 7
4 1 1 1 1000 10
2 1 1 1 1000 8
```

#### 样例 2, 3

见下发附件。

#### 数据规模与约定

- 对于 $10\%$ 的数据，满足 $q,v\le 10$ 。
- 对于另外 $20\%$ 的数据，满足 $v\le 100$ 。
- 对于另外 $20\%$ 的数据，满足 $q,v\le 2\times 10^3$ 。
- 对于 $100\%$ 的数据， 满足 $1\le q\le 3\times 10^4;1\le v\le 2\times 10^4;1\le x_i,y_i,w_i\le 4\times 10^4$ 。


---

---
title: "[THUPC 2021] 混乱邪恶"
layout: "post"
diff: 省选/NOI-
pid: P7606
tag: ['2021', 'O2优化', '背包 DP', '随机化', 'THUPC']
---
# [THUPC 2021] 混乱邪恶
## 题目背景

出题人分为 $9$ 种阵营：守序善良、守序中立、守序邪恶、中立善良、绝对中立、中立邪恶、混乱善良、混乱中立和混乱邪恶。真正的出题人，就要能够在阵营之间不断切换，而又不迷失在境界之中。

境界是一个无限大的三角形网格。网格如下图，每个交叉点都有 $6$ 个相邻的交叉点。你从某一个交叉点出发，每次给一个出题 idea 设定风格都会使你在境界中移动一步。

![](https://cdn.luogu.com.cn/upload/image_hosting/dwgwh04i.png)
## 题目描述

每个出题人都有一个守序指数 $L$ 和善良指数 $G$。对于一个 idea，从题面、样例或数据范围的角度，可以从 $6$ 个方向中选择恰好一个作为这个 idea 对应的题目的特有风格，同时会在境界中沿着所选的箭头方向移动一步：

![](https://cdn.luogu.com.cn/upload/image_hosting/5k7jqygw.png)

你现在一共有 $n$ 个 idea，你知道你给每个 idea 设定某一个风格时你的 $L$ 指数和 $G$ 指数的变化。具体地，对于第 $i$ 个idea有 $12$ 个参数 $tl_{i,l},tl_{i,g},l_{i,l},l_{i,g},bl_{i,l},bl_{i,g},br_{i,l},br_{i,g},r_{i,l},r_{i,g},tr_{i,l},tr_{i,g}$：

如果选择“简洁的题面”，那么 $L$ 变成 $L+tl_{i,l}$，$G$ 变成 $G+tl_{i,g}$；

如果选择“平凡无用的样例”，那么 $L$ 变成 $L+l_{i,l}$，$G$ 变成 $G+l_{i,g}$；

如果选择“宽松的数据范围”，那么 $L$ 变成 $L+bl_{i,l}$，$G$ 变成 $G+bl_{i,g}$；

如果选择“复杂的题面”，那么 $L$ 变成 $L+br_{i,l}$，$G$ 变成 $G+br_{i,g}$；

如果选择“无私馈赠的样例”，那么 $L$ 变成 $L+r_{i,l}$，$G$ 变成 $G+r_{i,g}$；

如果选择“松松松的数据范围”，那么 $L$ 变成 $L+tr_{i,l}$，$G$ 变成 $G+tr_{i,g}$。

这里所有的加法都在模 $p$ 意义下进行。

进入混乱邪恶阵营的要求很苛刻，需要 $L$ 恰好等于 $L^*$ 且 $G$ 恰好等于 $G^*$。

你的 $L$ 指数和 $G$ 指数开始时都为 $0$。请问是否存在一种设定风格的方式使得设定完全部 $n$ 个 idea 的风格后你仍在境界中原来的位置，但是能够进入混乱邪恶阵营。
## 输入格式

第一行两个正整数 $n,p$。

接下来 $n$ 行，每行 $12$ 个非负整数 $tl_{i,l},tl_{i,g},l_{i,l},l_{i,g},bl_{i,l},bl_{i,g},br_{i,l},br_{i,g},r_{i,l},r_{i,g},tr_{i,l},tr_{i,g}$。参数的顺序与题目描述中的一致，无需额外检查。

最后一行两个非负整数 $L^*,G^*$。
## 输出格式

如果能，输出一行 `Chaotic Evil`。

如果不能，输出一行 `Not a true problem setter`。
## 样例

### 样例输入 #1
```
3 10
3 5 1 4 9 3 0 0 0 0 0 0
0 0 0 0 0 0 3 5 1 4 9 3
3 5 1 4 9 3 3 5 1 4 9 3
3 2

```
### 样例输出 #1
```
Chaotic Evil

```
## 提示

**【样例解释】**

给第 $1$ 个 idea 设定风格为”简洁的题面“，此时你的守序指数为 $0+3=3$，善良指数为 $0+5=5$。你往左上方移动一步。

给第 $3$ 个 idea 设定风格为”宽松的数据范围“，此时你的守序指数为 $3+9=2$，善良指数为 $5+3=8$。你往左下方移动一步。

给第 $2$ 个 idea 设定风格为”无私馈赠的样例“，此时你的守序指数为 $2+1=3$，善良指数为 $8+4=2$。你往右边移动一步。此时你回到了原点并且守序指数为 $3$，善良指数为 $2$。所以你可以进入混乱邪恶阵营。

**【数据范围】**

保证 $1 \le n \le 100$，$1 \le p \le 100$。

保证其他输入数据在 $0$ 到 $p-1$ 之间。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_1/tree/master](https://github.com/yylidiw/thupc_1/tree/master) 查看。


---

---
title: "[JRKSJ R7] 茎"
layout: "post"
diff: 省选/NOI-
pid: P8935
tag: ['2023', '洛谷原创', 'O2优化', '背包 DP', '树形 DP']
---
# [JRKSJ R7] 茎
## 题目描述

你有一棵 $n$ 个点的根节点为 $1$ 的有根树，现在你要对这棵树进行剪枝，每次你可以选择一个还未被剪掉的节点 $u$ 进行操作，然后剪掉 $u$ 的子树所有点（包括 $u$）。当且仅当你剪掉 $1$ 时，操作停止。  

你知道 $1$ 到 $x$ 这条路径是这棵树的茎，需要特殊处理。所以你需要在第 $k$ 次剪枝时对 $x$ 进行操作，而非仅仅将其剪掉，即你不能在第 $k$ 次及以前对其祖先进行操作使其被连带剪掉。 

求有多少种不同的操作序列，两个操作序列不同当且仅当长度不同或存在一次操作 $i$ 使得两操作序列在第 $i$ 次时选择的 $u$ 不同。输出答案模 $10^9+7$。
## 输入格式

第一行三个数 $n,k,x$。  
接下来 $n-1$ 行每行两个数 $u,v$，代表树上的一条边 $(u,v)$。
## 输出格式

一个数表示答案对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
3 2 2
1 2
1 3
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
5 2 4
1 2
1 3
2 4
2 5
```
### 样例输出 #2
```
9
```
### 样例输入 #3
```
5 1 4
1 2
1 3
2 4
2 5
```
### 样例输出 #3
```
12
```
## 提示

### 样例解释

对于样例 $1$，只有一种操作方法满足条件，第一次操作 $3$，第二次操作 $2$，第三次操作 $1$。  

对于样例 $2$，满足条件的操作序列：$\{3,4,1\},\{3,4,2,1\},\{3,4,5,1\},\{3,4,5,2,1\},\\ \{5,4,1\},\{5,4,2,1\},\{5,4,2,3,1\},\{5,4,3,1\},\{5,4,3,2,1\}$。

### 数据规模
本题采用捆绑测试。

|$\text{Subtask}$|$n\le$|特殊性质|$\text{Score}$|
|:-:|:-:|:-:|:-:|
|$1$|$7$|无|$5$|
|$2$|$17$|无|$10$|
|$3$|$50$|$\text A$|$5$|
|$4$|$50$|无|$15$|
|$5$|$500$|$\text A$|$5$|
|$6$|$500$|$\text B$|$5$|
|$7$|$500$|$\text C$|$10$|
|$8$|$500$|无|$45$|

特殊性质 $\text A$：保证 $k=1$。\
特殊性质 $\text B$：保证 $x=1$。\
特殊性质 $\text C$：保证 $\forall i\in[1,n-1],i$ 与 $i+1$ 有边。

对于 $100\%$ 的数据，$1\le k,x\le n\le 500$。  



---

---
title: "[福建省队集训2019] 最大权独立集问题"
layout: "post"
diff: 省选/NOI-
pid: P9111
tag: ['2019', '福建', 'O2优化', '背包 DP', '树形 DP']
---
# [福建省队集训2019] 最大权独立集问题
## 题目描述

E.Space 喜欢出最大权独立集问题。

接下来，他还想出 $n$ 道最大权独立集问题。

E.Space 有 $n$ 个 AI，编号为 $1\sim n$。

开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \le i \le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。

E.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。

在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。

如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。

如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。

由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。

他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。
## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个整数，第 $i$ 个表示 $d_i$。

第三行 $n-1$ 个整数，第 $i$ 个表示 $c_{i+1}$。
## 输出格式

一行一个整数，表示最大的难度之和。
## 样例

### 样例输入 #1
```
4
1 10 3 5
1 2 3

```
### 样例输出 #1
```
52

```
### 样例输入 #2
```
4
1 -2 5 5
1 2 2

```
### 样例输出 #2
```
27

```
## 提示

### 【样例解释 1】

一种最优的出题方案如下：

1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。

2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。

3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。

4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $10+13+11+18=52$。

### 【样例解释 2】

一种最优的出题方案如下：

1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。

2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。

3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。

4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $5+5+8+9=27$。

### 【数据范围】

保证 $\left|d_i\right| \le 10^9$，$1 \le c_i \lt i$，$1\le n \le 400$。

**本题采用捆绑测试。**

对于编号为奇数的子任务，保证 $d_i \ge 0$。

子任务 $1,2$（$11 \times 2 = 22$ 分）：
$n \le 9$。

子任务 $3,4$（$10 \times 2 = 20$ 分）：
$n \le 19$。

子任务 $5,6$（$7 \times 2 = 14$ 分）：
$n \le 50$，$c_i = i-1$。

子任务 $7,8$（$10 \times 2 = 20$ 分）：
$c_i=i-1$。

子任务 $9,10$（$5 \times 2 = 10$ 分）：
$n \le 50$。

子任务 $11,12$（$7 \times 2 = 14$ 分）：
无特殊限制。

### 后记

听说 E.Space 的最大权独立集问题的难度是取了对数的？

听说 E.Space 要把这 $n$ 道题结合成一道题出出来？

听说 E.Space 不会把这些题出在训练里面？




---

---
title: "[ICPC 2022 Jinan R] DFS Order 2"
layout: "post"
diff: 省选/NOI-
pid: P9669
tag: ['2022', 'O2优化', '背包 DP', '树形 DP', 'ICPC', '济南']
---
# [ICPC 2022 Jinan R] DFS Order 2
## 题目描述

Prof. Pang has a rooted tree that is rooted at vertex $1$ and has $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.

Now he wants to start the depth-first search at the root. He wonders for each node $v$, how many ways it can appear in the $j$-th position of $\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\le j\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. 

Prof. Pang wants to know for each node $v$, how many different $\textbf{depth-first search order}$s such that $v$ appears in the $j$-th position. For each $v, j~(1 \le v, j \le n)$, compute the answer. Because the answer can be very large, output it modulo $998244353$.

Following is a pseudo-code for the depth-first search on a rooted tree. After calling $\textbf{main}$(), $\texttt{dfs\_order}$ is the depth-first search order.

![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)
## 输入格式

The first line contains one integer $n~(1\le n \le 500)$, the number of vertices in the tree.

Each of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1\le u_i,v_i\le n, u_i\neq v_i)$.

It is guaranteed that the given edges form a tree.
## 输出格式

For each vertex $v$ from $1$ to $n$, output one line containing $n$ integers modulo $998244353$. The $j$-th integer in the $v$-th line should be the number of different depth-first search orders such that $v$ appears in the $j$-th position.
## 样例

### 样例输入 #1
```
5
1 2
1 3
3 4
3 5
```
### 样例输出 #1
```
4 0 0 0 0
0 2 0 0 2
0 2 2 0 0
0 0 1 2 1
0 0 1 2 1
```
## 题目翻译

### 题目描述

P有一棵树，根节点是$1$，总共有$n$个节点，从$1$到$n$编号。

他想从根节点开始进行深度优先搜索。他想知道对于每个节点$v$，在深度优先搜索中，它出现在第$j$个位置的方式有多少种。深度优先搜索的顺序是在搜索过程中访问节点的顺序。节点出现在第$j（1 \le j \le n $）个位置表示它在访问了$j - 1$个其他节点之后才被访问。因为节点的子节点可以以任意顺序访问，所以有多种可能的深度优先搜索顺序。

P想知道对于每个节点$v$，有多少种不同的深度优先搜索顺序，使得$v$出现在第$j$个位置。对于每个$v$和$j（i \le v,j \le n）$，计算答案。答案可能很大，所以输出时要取模$998244353$。以下是深度优先搜索的伪代码，用于处理树。在调用$main()$函数后， dfs_order将会包含深度优先搜索的顺序。



------------
#### 算法 $1$ 深度优先搜索的实现
```
1. 过程 DFS(节点 x)

2.	将x添加到dfs_order的末尾

3.	对于x的每个子节点y do               ·子节点可以以任意顺序遍历。

4.		DFS(y)

5.	结束循环

6. 结束过程

7. 过程 MAIN()

8.	将dfs_order设为全局变量

9.	dfs_order ← 空列表

10.	DFS(1)

11. 结束过程
```
------------

### 输入格式

第一行包含一个整数$n（1\le n\le 500）$，表示树中的节点数量。

接下来的n-1行描述了树的边。第i行包含两个整数$u_i$和$v_i$，表示连接的两个节点的标签$（1\le u_i,v_i\le n,u_i\not=v_i）$。

保证给定的边构成一棵树。

### 输出格式

对于每个从$1$到$n$的节点$v$，输出一行，包含$n$个整数，取模$998244353$。在第$v$行中，第$j$个整数表示不同的深度优先搜索顺序中，节点$v$出现在第$j$个位置的数量。

 	翻译由@ayf2192538031提供


---


---
title: "UOFTAD - Reverse Fox Hunt"
layout: "post"
diff: 难度0
pid: SP14973
tag: []
---

# UOFTAD - Reverse Fox Hunt

## 题目描述

有一户狐狸家族抓住了一个闯入他们领地的麻烦农民，他们想给他一个教训。当然，他们并不想做得太狠心——只是想阻止他回家，直到他愿意请求原谅。

狐狸和农民居住的森林可以看作是一个 $H$ 行（$1 \leq H \leq 6$）$W$ 列（$1 \leq W \leq 6$）的网格。每个格子上可能是草地（用 "G" 表示）、树木（用 "T" 表示）、农民（用 "F" 表示）或农场（用 "H" 表示）。农民可以向上、下、左或右移动到相邻的格子，只要格子没有被树木挡住。由于他过于自信地在森林中冒险，农民的初始位置与农场并不紧邻。

狐狸家族可以通过站在草地格子上来挡住农民的去路。显然，农民不敢进入有狐狸的格子。不过，狐狸们也有更重要的事情要去做，因此他们想知道，至少需要站在多少个格子上才能确保农民永远到不了他的农场。

总共有 $T$（$1 \leq T \leq 20$）个这样的情景。对于每个情景，你需要解答狐狸们的问题。请注意，如果树木的分布已经足以阻止农民时，可能不需要额外的狐狸插手。

## 输入格式

第一行：一个整数 $T$

接下来对于每个情景：

第一行：两个整数 $H$ 和 $W$

接下来的 $H$ 行：每行有 $W$ 个字符，表示第 $i$ 行的网格，$i = 1..H$

## 输出格式

对于每个情景，输出一个整数，表示阻止农民到达农场所需的最少狐狸数量。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2\n1 5\nFGTGH\n4 5\nGGGGG\nGFGTG\nGTTGH\nGGGGG
```

### 输出

```

```


---
title: "BFREGEX1 - A Kleene Implementation"
layout: "post"
diff: 难度0
pid: SP15092
tag: []
---

# BFREGEX1 - A Kleene Implementation

## 题目描述

雷神托尔逛超市时发现 Kleenex 牌纸巾正在打折，这让他联想到 Kleene 递归定理，以及这个定理在函数式编程中自复制程序（quine）上的应用。思绪纷杂让他头疼，于是他尝试思考用图灵机识别带有 Kleene 星号的正则表达式，但这只让他更痛苦。于是，他灵机一动，随手写了一个 brainf\*\*k 程序来处理含有 Kleene 加号的正则表达式，然后满意地付了账。

**注意：** 可以使用任何编程语言，但必须是 brainf\*\*k。

## 输入格式

第一行输入一个整数 **T**，表示测试数据的数量（$1 \le T \le 1000$）。以下是 **T** 组测试数据。

每组测试数据包括：
- 一行，包含一个正则表达式 **P**（$1 \le |P| \le 30$）。
- 接下来一行，包含一个整数 **Q**，表示需要测试的字符串数量（$1 \le Q \le 10$）。
- 接下来的 **Q** 行，每行包含一个字符串 **S**（$1 \le |S| \le 100$）。
- 最后一行是一个空行，用来分隔测试数据。

每一行都以换行符结束，包括测试数据的最后一行。

正则表达式 **P** 是合法的，且不以加号开头，也不包含连续两个加号。**P** 是由字符 {a, b, c, d, +} 组成的，而 **S** 由字符 {a, b, c, d} 组成。

## 输出格式

输出 **T** 行，每行是一个长度为 **Q** 的字符串。第 **i** 个字符表示测试字符串 **S** 是否满足由正则表达式 **P** 定义的语言：匹配的话输出 'Y'，否则输出 '.'。需要说明的是，我们要检查的是 **P** 是否与 **S** 完全匹配，而非与 **S** 的某部分匹配。等价于在 **P** 前后分别加上 '^' 和 '$' 符号进行匹配。请参考示例以加深理解。

## 说明/提示

- $1 \le T \le 1000$
- $1 \le |P| \le 30$
- $1 \le Q \le 10$
- $1 \le |S| \le 100$

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
a
2
a
aa

a+
2
a
aa

a+bc
6
abbacadabba
aaaabc
abc
bc
abcd
babc
```

### 输出

```
Y.
YY
.YY...
```


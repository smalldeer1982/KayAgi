---
title: "MOUNTAIN - Beautiful Mountains"
layout: "post"
diff: 难度0
pid: SP21635
tag: []
---

# MOUNTAIN - Beautiful Mountains

## 题目描述

Paco 是个积木爱好者，他喜欢把积木堆叠排序成美丽的山脉。最近，他只用一种方法来重新排列积木：将所有积木堆排成一条直线，然后每次只能把一个积木从一个堆里移到相邻的另一个堆里。

Paco 用这种方法创造出了各种“山脉”，现在他想要制作最美丽的排列。他认为，如果每对积木堆之间的距离是质数，那么这个山脉排列就是美丽的（注意，是每一对，不仅仅是相邻的）。当只有一个积木堆时，默认是美丽的。Paco 定义至少有一个积木的堆为一座山。

比如，下面的图示展示了一个初始的积木配置，以及一种通过 13 次移动形成两个相距 3 的积木堆的方式。然而，通过仅 6 次移动，Paco 就可以设计出一个由 3 个积木堆组成的美丽排列：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/SP21635/5fc90092a9beb4b7a11b14eb11d9a8a1210bc4bc.png)

给定当前的积木排列，计算使 Paco 的积木排列变得美丽所需的最少移动次数。

## 输入格式

输入包含多个测试用例。每个测试用例第一行是一个整数 $n$ ($1 \le n \le 100$)，表示积木堆的数量。接下来一行包含 $n$ 个整数 $b_i$ ($0 \le b_i \le 10^6$)，代表每个积木堆中的积木数目。

## 输出格式

对于每个测试用例，输出一个整数，表示将积木堆重新排列为美丽排列所需的最少移动次数。输出时不要有多余的空格或空行。


 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 \n1 2 1 2 1 \n8 \n1 2 1 3 2 1 2 1 \n0
```

### 输出

```
3\n6&nbsp;
```


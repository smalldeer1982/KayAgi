# ZUMA - ZUMA

## 题目描述

祖玛游戏是这样的：有一列$ N$ 个有颜色的珠子，如果触碰连续 $K$ 个或更多同色的珠子，那么它们就会消失，其余的珠子按照原来顺序接在一起。

现在你每次可以发射任意颜色的珠子，发射在任意位置（开头、结尾以及任意两个之间）。

注意，如果有连续 $K$ 个或更多同色的珠子，你可以不立即消去他们。

问最少需要几发可以消掉所有的珠子。

## 样例 #1

### 输入

```
2 5
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
10 4
3 3 3 3 2 3 1 1 1 3```

### 输出

```
4```

# 题解

## 作者：Superiority (赞：3)

# 思路

这题思维难度还是挺大的，我们尝试一步一步推。

我们首可以先单看某一个节点，显而易见的是添加的数量最多为 $T - 1$ 个珠子。所以，我们可以使用区间 DP，定义 $dp_{l,r,k}$ 在 $l$ 前**已经**添加了 $k$ 个珠子时，要消去 $l \sim r$ 里所有珠子所需的添加最小珠子的数量。

接下来就是设计状态，首先显然边界条件为 $dp_{i,i,k} = T - k - 1$，单点构成的区间，一定需要 $T - k - 1$ 个珠子才能完全消除。

对于某个状态 $dp_{l,r,k}$ 而言，如果在 $l$ 前添加了 $1$ 颗珠子，也就相当于从 $dp_{l,r,k+1}+1$ 转移过来，这样我们的第一个状态就完成了，可以得到 $dp_{l,r,k} = \min(dp_{l,r,k},dp_{l,r,k+1}+1)$。

假设 $k = T -1$，此时就相当于可以直接消除 $l$ 及以前的所有珠子，因此我们得到另外一个转移方程 $dp_{l,r,k}=\min(dp_{l,r,T-1},dp_{l+1,r,0})$。

接着，当 $c_l=c_{l+1}$ 时，这时的 $dp_{l,r,k}$ 就等于 $dp_{l+1,r,k+1}$，所以此时 $dp_{l,r,k}=\min(dp_{l,r,k},dp_{l+1,r,k+1})$。

最后，枚举一个位置 $x$，并且 $x$ 在 $l+2 \sim r$ 之间，这时如果 $c_l=c_x$，我们可以直接将 $l+1 \sim x-1$ 内的珠子消除，再把 $l$ 及前面的珠子和 $x \sim r$ 合并起来进行求解，可得到最后一个动态转移方程 $dp_{l,r,k} =\min(dp_{l,r,k},dp_{l+1,x-1,0}+dp_{x,r,k+1})$

- 注意一下边界情况。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[10001];
int dp[101][101][101];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=m;k++){
				dp[i][j][k]=1e9;
			}
		}
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			dp[i][i][j]=m-j;
		}
	}
	for(int len=2;len<=n;len++){
		for(int l=1;l+len-1<=n;l++){
			int r=l+len-1;
			for(int i=m;i>0;i--){
				if(i==m) dp[l][r][i]=min(dp[l][r][i],dp[l+1][r][1]);
				else dp[l][r][i]=min(dp[l][r][i],dp[l][r][i+1]+1);
				if(a[l]==a[l+1]) dp[l][r][i]=min(dp[l][r][i],dp[l+1][r][min(m,i+1)]);
				for(int j=l+1;j<r;j++){
					if(a[l]==a[j+1]) dp[l][r][i]=min(dp[l][r][i],dp[l+1][j][1]+dp[j+1][r][min(m,i+1)]);
				}
			}
		}
	}
	cout<<dp[1][n][1]<<endl;
    return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

首先对于有“序列”、“最少”、“最多”和一些操作（包括 $1$ 个）时，就应该想到区间 DP。

开始玩老套路，$f_{i,j}$ 表示从 $i\sim j$ 的答案。

结果发现没法转移，于是不得不更改成一个可行的状态。

我们经过分析，发现：插入操作比较难实现，不妨直接把插入后的连续值设进状态里：$f_{i,j,k}$ 表示 $i\sim j$ 最左边有大于等于连续 $k$ 个相同的珠子。

转移方程怎么推？首先考虑添加一个元素的：如果 $a_i=a_{i+1}$ 则 $f_{i+1,j,k}=f_{i,j,k+1}$。

既然维度很多，肯定有同区间的只有第 $3$ 个维度改变的转移：从连续更长的转移 $f_{i,j,k}=f_{i,j,k+1}+1$。

最常规的转移，从中间点 $x$ 让 $a_x\sim a_j$ 消掉。

当然 $k=K-1$（注意大写 $K$ 是表示题目中的 $K$）时，可以直接全部消除。

初始状态和最终答案：$f_{i,i,k}=K-k-1$（直接加上一堆珠子然后到 $K$ 消掉），答案显然是全部区间无特殊情况 $f_{1,n,0}$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[101],f[101][101][6];
int main(){
	memset(f,0x3f,sizeof(f));
	cin>>n>>k;
	for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        for(int k=0;k<::k;k++)
            f[i][i][k]=::k-k-1;//初始状态
    for(int l=2;l<=n;l++)//枚举长度
        for(int i=1,j;i<=n-l+1;i++){//左
            j=i+l-1;//右
            for(int k=::k-1;k>=0;k--){//注意转移用到了 k + 1，要倒着枚举
                if(k==::k-1)
					f[i][j][k]=min(f[i][j][k],f[i+1][j][0]);//清空
				else if(k<::k-1)
					f[i][j][k]=min(f[i][j][k],f[i][j][k+1]+1);//同阶段转移
				if(a[i]==a[i+1])
					f[i][j][k]=min(f[i][j][k],f[i+1][j][min(::k-1,k+1)]);//特殊情况转移
				for(int x=i+1;x<=j-1;x++)
					if(a[i]==a[x+1])
						f[i][j][k]=min(f[i][j][k],f[i+1][x][0]+f[x+1][j][min(::k-1,k+1)]);//常规情况转移 
            }
        }
	cout<<f[1][n][0];//答案
	return 0;
}
```

---


# CIJEVI - Cijevi

## 题目描述

为了设计从俄罗斯向克罗地亚输送天然气的新管道，萨格勒布和莫斯科正在使用一款名为《管道狂人》的电脑游戏。在该游戏中，欧洲被划分为 $R$ 行 $C$ 列的网格。每个小格子可能是空的，或者包含下图中的7种基本管道构建块之一：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/SP3882/678f6ebd902db14c54549869b81af41b0e76e108.png)

天然气从莫斯科流向萨格勒布，可以双向通过这些构建块流动。特别地，构建块 '+' 必须在垂直和水平方向上都能导通，如下所示：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/SP3882/ed558c8ede3b8c091a8e0b6d010d1a23c7e411a2.png)

在新的管道实施计划中，有人恶意删除了一个构建块，将其变成了一个空单元格。

请编写一个程序，找出被删除的构建块位置及其类型。

## 样例 #1

### 输入

```
3 7
.......
.M-.-Z.
.......```

### 输出

```
2 4 -


Input
3 5
..1-M
1-+..
Z.23.

Output
2 4 4


Input
6 10
Z.1----4..
|.|....|..
|..14..M..
2-+++4....
..2323....
..........

Output
3 3 |```

# 题解

## 作者：VitrelosTia (赞：2)

其实这道题的思路就是枚举和判断，判断每个点是否能合法就可以了，我们一步步来看。

首先是枚举，就是把每个 `.` 点尝试每一种变化，然后看看这种网格是不是正确的。大概写成这样。
```
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 0; k <= 6; k++) {
				if (mp[i][j] != '.') continue;
				if (check(i, j, dir[k])) {
					cout << i << ' ' << j << ' ' << dir[k] << '\n';
					return 0;
				}
			}
		}
	}
```

然后就是 `check` 怎么写了，首先先把新的网格搞出来，然后枚举每一个点，看它是不是可以和附近的相连的。
```
bool check(int x, int y, char c) {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			a[i][j] = mp[i][j];
		}
	}
	a[x][y] = c;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (!ck(i, j)) {
				return false;
			}
		}
	}
	return true;
}
```

判断每一个点的过程在 `ck` 里。这个函数比较复杂，但其实思路很清晰，就是对于网格上的每一种情况进行讨论，每一种情况可以总结出这几个方式是不行的：

1. 开口处都是 `.` 即障碍；
2. 开口处与其它管道不连接。

我们就根据图分别把所有情况判断掉就行了。比较烦的是开头和终点，这个你需要特殊处理，因为这种情况只要有一边是连进管道的就行了。最终代码是比较长的，但其实内核思路非常清晰。
```
bool ck(int x, int y) {
	if (a[x][y] == '.') return true;
	if (a[x][y] == 'M' || a[x][y] == 'Z') {
		if (x > 1 && x < n && y > 1 && y < m) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4' || 
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		} 
		if (x == 1) {
			if (a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4' || 
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		}
		if (x == n) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4' || 
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		}
		if (y == 1) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		}
		if (y == m) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4') return true;
		}
		return false;
	}
	if (a[x][y] == '|') {
		if (x == 1 || x == n) return false;
		if (a[x - 1][y] == '.' || a[x + 1][y] == '.' ||
		    a[x - 1][y] == '-' || a[x + 1][y] == '-' ||
			a[x - 1][y] == '2' || a[x - 1][y] == '3' || 
			a[x + 1][y] == '1' || a[x + 1][y] == '4') return false;
		return true;
	}
	if (a[x][y] == '-') {
		if (y == 1 || y == m) return false;
		if (a[x][y - 1] == '.' || a[x][y + 1] == '.' ||
		    a[x][y - 1] == '|' || a[x][y + 1] == '|' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4' || 
			a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '+') {
		if (x == 1 || x == n || y == 1 || y == m) return false;
		if (a[x - 1][y] == '.' || a[x + 1][y] == '.' || a[x][y - 1] == '.' || a[x][y + 1] == '.' || 
			a[x - 1][y] == '-' || a[x + 1][y] == '-' ||
			a[x][y - 1] == '|' || a[x][y + 1] == '|' || 
			a[x - 1][y] == '2' || a[x - 1][y] == '3' || a[x + 1][y] == '1' || a[x + 1][y] == '4' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4' || a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '1') {
		if (x == n || y == m) return false;
		if (a[x + 1][y] == '.' || a[x][y + 1] == '.' || 
			a[x + 1][y] == '-' ||
			a[x][y + 1] == '|' ||
			a[x + 1][y] == '1' || a[x + 1][y] == '4' ||
			a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '2') {
		if (x == 1 || y == m) return false;
		if (a[x - 1][y] == '.' || a[x][y + 1] == '.' ||
			a[x - 1][y] == '-' ||
			a[x][y + 1] == '|' || 
			a[x - 1][y] == '2' || a[x - 1][y] == '3' || 
			a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '3') {
		if (x == 1 || y == 1) return false;
		if (a[x - 1][y] == '.' || a[x][y - 1] == '.' ||
			a[x - 1][y] == '-' ||
			a[x][y - 1] == '|' ||
			a[x - 1][y] == '2' || a[x - 1][y] == '3' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4') return false;
		return true;
	}
	if (a[x][y] == '4') {
		if (x == n || y == 1) return false;
		if (a[x + 1][y] == '.' || a[x][y - 1] == '.' ||
			a[x + 1][y] == '-' ||
			a[x][y - 1] == '|' || 
			a[x + 1][y] == '1' || a[x + 1][y] == '4' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4') return false;
		return true;
	}
}
```

那么这道题就愉快地做完了。

---

## 作者：wyyinput (赞：1)

## 思路
先暴力找到起点和终点，再从两端沿管道 DFS 找到断点。找到位置后，枚举每一种管道，看哪个与断点匹配就可以了。
## [代码](https://www.luogu.com.cn/paste/t9vh2vqk)

---


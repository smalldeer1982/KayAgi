# 最近公共祖先（LCA）

## 题目描述

> 树是一种简单无向图，图中任意两个节点仅被一条边连接。所有连通无环无向图都是一棵树。
>
> 最近公共祖先（LCA）是图论和计算机科学中的一个概念。设 $\text{T}$ 是一个有 $N$ 个节点的有根树，树上有两个节点 $v$ 和 $w$，而这两个节点的最近公共祖先是 $u$，那么 $u$ 是 $v$ 和 $w$ 在 $\text{T}$ 上的祖先（允许自己是自己的祖先），且在满足上面的前提的所有节点中，其在 $T$ 上的高度最低。
> 
>——摘自维基百科

现在，你需要对于给定的树 $\text{T}$ 以及两个节点 $v$ 和 $w$，求出它们的最近公共祖先。

如下图所示，图中 $9$ 号节点与 $12$ 号节点的最近公共祖先为 $3$ 号节点。

![](https://cdn.luogu.org/upload/vjudge_pic/SP14932/0b23f0487b06b8d674d23253a6db517f49ca3acf.png)

## 说明/提示

### 样例解释

**样例输入 1**

```plain
1
7
3 2 3 4
0
3 5 6 7
0
0
0
0
2
5 7
2 7
```

**样例输出 1**

```plain
Case 1:
3
1
```

此样例在【题目描述】中有解释。

### 数据范围

对于 $100\%$ 的数据，$1 \le N \le 1000,0 \le M \le N - 1,1 \le Q \le 1000$。

# 题解

## 作者：llzzxx712 (赞：31)

## 多组数据LCA
    
   可以说是一道LCA模板题了，和普通LCA模板唯一不一样的地方就是它有多组数据，每组数据要重新建立树
   
   我习惯用倍增求LCA，复杂度（n+q）logn，n为节点数，q为询问数。在本题1000、1000的数据范围下约为        2* 10^4,1000组数据下总复杂度不超过 2 * 10^7，可以通过本题
   

------------
再来看题目，数据组数较多，加个快读先

```cpp
void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
```


------------


------------

领接表存树

```cpp
#define N 1002
#define ml 12
int to[N],head[N],ne[N],anc[N][ml+2],de[N],tot;
void add(int x,int y){
	to[++tot]=y,ne[tot]=head[x],head[x]=tot;
}
```
根据读入方式，可以看出这是一颗有根树，不需要开2倍空间，ml为maxlog，2^ml>最大深度,为防止数组越界，开了ml+2


------------
对于一组数据求LCA
```cpp
    int n,m,q,t;
    read(n);
    int root;
    for(int i=1;i<=n;i++){//节点数 
    	read(m);
    	for(int j=1;j<=m;j++){
    	    int x;
    	    read(x);
       	    add(i,x);
    	    v[x]=1;//有边通向x，x不是根节点
	    }
	}
	for(int i=1;i<=n;i++){
	    if(!v[i]){//遍历节点，看看哪个节点没有父亲，那么它就是根节点
		root=i;
		break;
	    }
	}
	dfs(root,root);//从根节点开始遍历一遍，求出每个节点深度和倍增数组，根节点的父亲认为是它自己
	read(q);
	cout<<"Case "<<ii<<':'<<endl;//输出时不要忘了这个
	for(int i=1;i<=q;i++){
	    int x,y;
	    read(x),read(y);
	    getlca(x,y);//求LCA
	}
```
↑主程序部分

↓dfs函数和getlca
```cpp
void dfs(int x,int fa){//anc[i][j]表示节点i向上走2^j步到的节点
    de[x]=de[fa]+1,anc[x][0]=fa;//计算该节点深度，并将它父亲标记为向上走一步
    for(int i=1;i<=ml;i++) anc[x][i]=anc[anc[x][i-1]][i-1];//向上走2^j补等同于向上走2^(j-1)到的节点再向上走2^（j-1）步
    for(int i=head[x];i;i=ne[i]) dfs(to[i],x);
}
```
```cpp
void getlca(int x,int y){
	if(x==y){
		cout<<x<<endl;//如果两个节点相同，直接输出其中一个
		return;
	}
	if(de[x]<de[y]) swap(x,y);//确保x的深度大于y的深度，便于将两个节点提升到同一高度
	for(int i=ml;i>=0;i--){
		if(de[anc[x][i]]>=de[y]){
			 x=anc[x][i];//如果x向上走2^i补后深度仍大于y，那么就走，从大到小枚举i之后就可以确保x，y走到了同一高度
		}
	}
	if(x==y){
		cout<<x<<endl;//如果此时xy重合了，那么还是输出x就好了
		return;
	}
	for(int i=ml;i>=0;i--){
		if(anc[x][i]!=anc[y][i]){//否则就让x、y同时向上跳
			x=anc[x][i],y=anc[y][i];//我们假设xy向上跳 i 步可以到达LCA，那么他们再跳i-1补时还没到LCA，这里就是让xy到达那i-1步
		}
	}
	cout<<anc[x][0]<<endl;//最后再向上跳一步就是他们的LCA了
	return;
}
```

最后要处理其它数据时需要清空树和v数组，但5个memset后就TLE了，仔细思考一下，在遍历时是以head数组开始查找的，to【】和ne【】是随着head一起生成的，所以只要清空head[]和v数组就可以了（别忘了把tot归零）

完整代码
```cpp
#include<bits/stdc++.h>
#define N 1002
#define ml 12
using namespace std;
bool v[1002];
int to[N],head[N],ne[N],anc[N][ml+2],de[N],tot,t;
void add(int x,int y){
	to[++tot]=y,ne[tot]=head[x],head[x]=tot;
}
void dfs(int x,int fa){
	de[x]=de[fa]+1,anc[x][0]=fa;
	for(int i=1;i<=ml;i++) anc[x][i]=anc[anc[x][i-1]][i-1];
	for(int i=head[x];i;i=ne[i]) dfs(to[i],x);
}
void getlca(int x,int y){
	if(x==y){
		cout<<x<<endl;
		return;
	}
	if(de[x]<de[y]) swap(x,y);
	for(int i=ml;i>=0;i--){
		if(de[anc[x][i]]>=de[y]){
			 x=anc[x][i];
		}
	}
	if(x==y){
		cout<<x<<endl;
		return;
	}
	for(int i=ml;i>=0;i--){
		if(anc[x][i]!=anc[y][i]){
			x=anc[x][i],y=anc[y][i];
		}
	}
	cout<<anc[x][0]<<endl;
	return;
}
void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
int main()
{
	int n,m,q,t;
    read(t);
    for(int ii=1;ii<=t;ii++){//数据组数 
    	read(n);
    	int root;
    	for(int i=1;i<=n;i++){//节点数 
    		read(m);
    		for(int j=1;j<=m;j++){
    			int x;
    			read(x);
    			add(i,x);
    			v[x]=1;
			}
		}
		for(int i=1;i<=n;i++){
			if(!v[i]){
				root=i;
				break;
			}
		}
		dfs(root,root);
		read(q);
		cout<<"Case "<<ii<<':'<<endl;
		for(int i=1;i<=q;i++){
			int x,y;
			read(x),read(y);
			getlca(x,y);
		}
    	memset(head,0,sizeof(head));
    	memset(v,0,sizeof(v));
    	tot=0;
	}
	return 0;
}
	

```

（~~写题解不易，给个赞呗）~~








---

## 作者：Purple_wzy (赞：16)

## 一篇集合了所有四种求lca方法的题解

**树剖求lca**

对这棵树进行轻重链剖分，每次沿重链向上跳，直到两个节点的top相同，

此时dep较小的就是lca。复杂度O(n+qlogn)

**倍增求lca**

令f[i][j]表示从i节点向上跳$2^j$个祖先跳到的点。每次查询，先使两节点

深度相同，然后一起向上跳就行。复杂度O((n+q)logn)

**tarjan求lca**

把询问分别挂在两节点上，然后对整棵树做一次dfs,用并查集维护每个节点

当前深度最小的祖先，具体细节见代码。复杂度O(n+q)

**st表求lca**

对树做一次dfs,求出数的欧拉序记录每个欧拉序的节点和其深度，令f[i][j]

表示[i,i+$2^j$-1]这一段深度最小的节点的欧拉序（不是节点编号），

然后就是常规的st表处理思路了。复杂度O(nlogn+q)

说一下这四种求法的优势：

树剖：可以结合各种线性数据结构将树上信息转化为链上信息；

倍增：可以同时维护权值等信息。

tarjan:一般用的比较少，可以在线性时间里解决lca以及树上两点距离问题；

st表：在动态点分治等题目中可以在线快速求lca

上代码

```
#include<bits/stdc++.h>
using namespace std;
#define re register int
#define F(x,y,z) for(re x=y;x<=z;x++)
#define FOR(x,y,z) for(re x=y;x>=z;x--)
typedef long long ll;
#define I inline void
#define IN inline int
template<class D>I read(D &res){
	res=0;register D g=1;register char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')g=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		res=(res<<3)+(res<<1)+(ch^48);
		ch=getchar();
	}
	res*=g;
}
typedef pair<int,int>pii;
struct E{
	int to,nt;
}e[22020];
#define T e[k].to
int head[10210],tot,X,Y,n,m,v[10210],root;
namespace solve1{//树剖 
	int siz[10210],dep[10210],top[10210],son[10210],fa[10210];
	I D_1(int x,int fat,int depth){
		dep[x]=depth;son[x]=-1;fa[x]=fat;siz[x]=1;
		re maxi=-1;
		for(re k=head[x];k!=-1;k=e[k].nt){
			if(T==fat)continue;
			D_1(T,x,depth+1);
			siz[x]+=siz[T];
			if(siz[T]>maxi)maxi=siz[T],son[x]=T;
		}
	}
	I D_2(int x,int fat,int topi){
		top[x]=topi;
		if(son[x]!=-1)D_2(son[x],x,topi);
		for(re k=head[x];k!=-1;k=e[k].nt){
			if(T==fat||T==son[x])continue;
			D_2(T,x,T);
		}
	}
	IN ques_lca(int x,int y){
		while(top[x]!=top[y]){
			if(dep[top[x]]<dep[top[y]])swap(x,y);
			x=fa[top[x]];
		}
		if(dep[x]>dep[y])swap(x,y);
		return x;
	}
	I solve(){
		D_1(root,0,1);
		D_2(root,0,root);
		read(m);
		while(m--){read(X);read(Y);cout<<ques_lca(X,Y)<<endl;}
	}	
};
namespace solve2{//倍增 
	int f[10210][15],fa[10210],lg[10210],dep[10210];
	I predo(){
		lg[0]=-1;
		F(i,1,n)lg[i]=lg[i>>1]+1;
		memset(f,0,sizeof(f));
	}	
	I D_1(int x,int fat,int depth){
		f[x][0]=fat;dep[x]=depth;fa[x]=fat;
		F(i,1,lg[dep[x]])f[x][i]=f[f[x][i-1]][i-1];
		for(re k=head[x];k!=-1;k=e[k].nt){
			if(T==fat)continue;
			D_1(T,x,depth+1);
		}
	}
	IN ques_lca(int x,int y){
		if(dep[x]<dep[y])swap(x,y);
		re d=dep[x]-dep[y];
		FOR(i,lg[d+1],0){
			if((d>>i)&1)x=f[x][i];
		}
		if(x==y)return x;
		FOR(i,lg[dep[x]],0){
			if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
		}
		return f[x][0];
	}
	I solve(){
		predo();
		D_1(root,0,1);
		read(m);
		while(m--){read(X);read(Y);cout<<ques_lca(X,Y)<<endl;}
	}
};
namespace solve3{//tarjan
	int fa[10210],vis[10210],ans[10210];
	vector<pii>v[10210];
	IN find(int x){
		return fa[x]==x?x:fa[x]=find(fa[x]);
	}
	I D_1(int x,int fat){
		for(re k=head[x];k!=-1;k=e[k].nt){
			if(T==fat)continue;
			D_1(T,x);fa[T]=x;
			//因为T及其子树都已经访问完毕，所以对于接下来的查询，这些节点的lca就与x保持一致 
		}
		for(auto p:v[x])if(vis[p.first])ans[p.second]=find(p.first);
		vis[x]=1;v[x].clear();
	}
	I solve(){
		F(i,1,n)fa[i]=i,vis[i]=0;
		read(m);
		F(i,1,m){
			read(X);read(Y);
			if(X==Y)ans[i]=X;//特判两点相同情况 
			else v[X].emplace_back(make_pair(Y,i));v[Y].emplace_back(make_pair(X,i));
			//在两个节点都挂上是为了保证更新到答案 
		}
		D_1(root,0);
		F(i,1,m)cout<<ans[i]<<endl;
	}
};
namespace solve4{//st表 
	int id[3030],N,dep[3030],p[3030],f[3030][15],lg[3030];
	I D_1(int x,int fa,int depth){
		p[x]=++N;dep[N]=depth;id[N]=x;
		for(re k=head[x];k!=-1;k=e[k].nt){
			if(T==fa)continue;
			D_1(T,x,depth+1);
			id[++N]=x;dep[N]=depth;
		}
	}
	IN ques_lca(int x,int y){
		if(p[x]>p[y])swap(x,y);
		re len=lg[p[y]-p[x]+1];
		if(dep[f[p[x]][len]]<dep[f[p[y]-(1<<len)+1][len]])return id[f[p[x]][len]];
		else return id[f[p[y]-(1<<len)+1][len]];
		//return id[min(f[p[x]][len],f[p[y]-(1<<len)+1][len])];
	}
	I solve(){
		N=0;
		D_1(root,0,1);
		lg[0]=-1;
		F(i,1,N)lg[i]=lg[i>>1]+1;
		F(i,1,N)f[i][0]=i;
		F(j,1,lg[N]){
			F(i,1,N-(1<<j)+1){
				if(dep[f[i][j-1]]<dep[f[i+(1<<(j-1))][j-1]])f[i][j]=f[i][j-1];
				else f[i][j]=f[i+(1<<(j-1))][j-1];
			}
			F(i,N-(1<<j)+2,N)f[i][j]=f[i][j-1];
		}
		read(m);
		while(m--){read(X);read(Y);cout<<ques_lca(X,Y)<<endl;}
	}
};
I init(){tot=-1;memset(head,-1,sizeof(head));memset(v,0,sizeof(v));}
I add(int x,int y){e[++tot].to=y;e[tot].nt=head[x];head[x]=tot;}
int t;
int main(){
	read(t);
	F(da,1,t){
		init();read(n);
		F(i,1,n){
			read(m);
			F(j,1,m){
				read(X);
				add(i,X);
				v[X]=1;
			}
		}
		F(i,1,n)if(!v[i]){root=i;break;}
		cout<<"Case "<<da<<":"<<endl;
		if(da%4==1)solve1::solve();
		else if(da%4==2)solve2::solve();
		else if(da%4==3)solve3::solve();
		else if(da%4==0)solve4::solve();
	}
	return 0;
}

```


---

## 作者：ShuraEye (赞：8)

# $LCA$模板

这道题可以说是$LCA$模板了，也是比较入门的一道题。

$LCA$是个很常见的算法，可用性和范围极大，可以通用于求$2$~$3$点
的[最近公共祖先](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)求法。
****
LCA有很多种打法：$Tarjan$求$LCA$，倍增$LCA$等等，这里本蒟蒻就向大家介绍一波比较简单的倍增$LCA$打法。

****

# 重要思路

倍增算法的主要思路是什么呢？？？



在倍增$LCA$中，我们需要定义一个$p[i][j]$数组，表示$i$的$2^j$祖先，这样就完成了一个树上记忆化。

还需要定义一个$d[i]$数组，表示第$i$个点的深度，这个$d[i]$数组会由$dfs$预处理更新。（之后讲到）

****
# 重要代码：$dfs$
这里的$dfs$主要是用来预处理每个点的深度的和它的$2^0$倍祖先也就是$1$倍祖先的，也就是它的父节点，这段代码其实比较简单，也不多讲。

而大家这里可以看到我是用链式前向星存边的，喜欢$vector$的小伙伴们当然可以选择$vector$存边，这里也提供上两种存边方法。

# 链式前向星：
```cpp
void dfs(int u,int fa)
{
	for(int i=head[u];i;i=nxt[i])
	{
		if(to[i]!=fa)
		{
			d[to[i]]=d[u]+1;
			p[to[i]][0]=u;
			dfs(to[i],u);
		}
	}
}
```
# $vector$：
```cpp
void dfs(int u,int fa)
{
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(v!=fa)
		{
			p[v][0]=u;
			d[v]=d[u]+1;
			dfs(v,u);
		}
	}
}
```
****
# 重要代码：$LCA$（划重点）

这是整个代码的核心部分了，在前面的$dfs$中已经预处理出每个点的深度了，现在我们就要从要求$LCA$的$a$和$b$中深度较深的一个，找出它最大是$2$的几次方祖先，用$l$存储。


```cpp
	if(d[a]<d[b])swap(a,b);//a、b中较大的
	int l=0;
	while((1<<l)<=d[a])l++;//找最大的l
	l--;
```

接下来找出$l$后，就开始爬树啦，要将$a$爬到与$b$一样的深度，$for$循环查找，这里有个小细节：将$i$从$l$开始循环，这样可以更快的找到符合条件的$a$。如果$a$的深度$-2^i$还是大于$b$的,那么就继续爬树，将$a$更新为$a$的$2^i$倍祖先。

如果将$a$爬到$b$的深度后，$a$==$b$，说明$a$就是$b$的最近公共祖先，直接$return$ $a$。


```cpp
for(int i=l;i>=0;i--)
		if(d[a]-(1<<i)>=d[b])
			a=p[a][i];//a爬树 
	if(a==b)return a;
```

当$a$爬到$b$的深度一样后，如果$a$的祖先$!=b$的祖先，那么就继续$for$循环爬树，直到它们的祖先一样，这里要注意，上一段代码是只更新$a$，这一段是要同时更新$a$与$b$，最后返回$a$的祖先。
```cpp
for(int i=l;i>=0;i--)
		if(p[a][i]!=p[b][i])
			a=p[a][i],b=p[b][i];
	return p[a][0];
```

**完整伪代码：
```cpp
int lca(int a,int b)
{
	if(d[a]<d[b])swap(a,b);
	int l=0;
	while((1<<l)<=d[a])l++;
	l--;
	for(int i=l;i>=0;i--)
		if(d[a]-(1<<i)>=d[b])
			a=p[a][i];
	if(a==b)return a;
	for(int i=l;i>=0;i--)
		if(p[a][i]!=p[b][i])
			a=p[a][i],b=p[b][i];
	return p[a][0];
}
```
****
# 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,cnt=0;
int to[N*2],nxt[N*2],head[N];
bool vis[N];
int p[N][21];
int d[N];
void add(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}
int lca(int a,int b)
{
	if(d[a]<d[b])swap(a,b);
	int l=0;
	while((1<<l)<=d[a])l++;
	l--;
	for(int i=l;i>=0;i--)
		if(d[a]-(1<<i)>=d[b])
			a=p[a][i];
	if(a==b)return a;
	for(int i=l;i>=0;i--)
		if(p[a][i]!=p[b][i])
			a=p[a][i],b=p[b][i];
	return p[a][0];
}
void dfs(int u,int fa)
{
	for(int i=head[u];i;i=nxt[i])
	{
		if(to[i]!=fa)
		{
			d[to[i]]=d[u]+1;
			p[to[i]][0]=u;
			dfs(to[i],u);
		}
	}
}
void init()
{
	cnt=0;
	memset(vis,0,sizeof(vis));
	memset(head,0,sizeof(head));
	memset(d,0,sizeof(d));
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int now=1;now<=t;now++)
	{
		init();
		scanf("%d",&n);
		int m,a,b,q,root;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&m);
			for(int j=1;j<=m;j++)
			{
				scanf("%d",&a);
				add(i,a);add(a,i);
				vis[a]=1;
			}
		}	
		for(int i=1;i<=n;i++)
		{
			if(!vis[i])
			{
				root=i;
				break;
			}
		}
		dfs(root,-1);
		for(int j=1;(1<<j)<=n;j++)
		{
			for(int i=1;i<=n;i++)
			{
				p[i][j]=p[p[i][j-1]][j-1];
			}
		}
		scanf("%d",&q);
		printf("Case %d:\n",now);
		for(int i=1;i<=q;i++)
		{
			scanf("%d %d",&a,&b);
			printf("%d\n",lca(a,b));
		}
	}
	return 0;
}
```

---

## 作者：communist (赞：7)

~~专业跟队形~~

~~唯一一个有$\LaTeX$的~~

裸的$LCA$，我用的是$Tarjan~LCA$，注意两点相同特判

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1010;
struct edge{
    int next,to;
}e[maxn],q[maxn<<1];
int n,m,s,head[maxn],cnt,ans[maxn],heads[maxn],f[maxn],cntc;
bool vis[maxn];
int find(int x)
{
    return x==f[x]?x:f[x]=find(f[x]);
}
void add(int x,int y)
{
    e[++cnt].next=head[x];
    e[cnt].to=y;
    head[x]=cnt;
}
void adds(int x,int y)
{
    q[++cnt].next=heads[x];
    q[cnt].to=y;
    heads[x]=cnt;
}
void tarjan(int x,int pre)
{
    for(int v,i=head[x];i;i=e[i].next)
    {
        if((v=e[i].to)==pre)
            continue;
        tarjan(v=e[i].to,x);
        int f1=find(x),f2=find(v);
        if(f1!=f2)
            f[f2]=f1;
    }
    for(int i=heads[x];i;i=q[i].next)
        if(vis[q[i].to])
            ans[(i+1)>>1]=find(q[i].to);
    vis[x]=1;
}
int main()
{
    scanf("%d",&s);
    while(s--)
    {
        scanf("%d",&n);
        cnt=0;
        memset(head,0,sizeof(head));
        memset(heads,0,sizeof(heads));
        memset(vis,0,sizeof(vis));
        for(int x,num,i=1;i<=n;i++)
        {
            scanf("%d",&num);
            for(int j=1;j<=num;j++)
            {
                scanf("%d",&x);
                add(i,x);
            }
        }
        scanf("%d",&m);
        cnt=0;
        for(int x,y,i=1;i<=m;i++)
        {
            scanf("%d%d",&x,&y);
            if(x==y)
                ans[i]=x;
            adds(x,y),adds(y,x);
        }
        for(int i=1;i<=n;i++)
            f[i]=i;
        tarjan(1,0);
        printf("Case %d:\n",++cntc);
        for(int i=1;i<=m;i++)
            printf("%d\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：ez_lcw (赞：6)

# 倍增LCA
[LCA（最近公共祖先）](https://baike.baidu.com/item/LCA/20414490)是一个很常见的问题（比如这题），它常用在树上$2$~$3$点的最近点（公最近共祖先），当然也同样适用于$2$点间的最短路。

求LCA有以下几种算法：

1. **$Tarjan$（离线算法，前置算法并查集）**

1. **倍增算法（前置知识$RMQ$），也就是今天要用到的**

倍增算法的主要思路是什么呢？

**首先，我们将整棵树分层：**
![](https://cdn.luogu.com.cn/upload/pic/46048.png)

具体方法可以用$dfs$：
```cpp
void dfs(int u)
{
	for(int i=head[u];i;i=nxt[i])
	{
		deep[to[i]]=deep[u]+1;//记录深度
		p[to[i]][0]=u;//记录v的1辈祖先就是u(2^0=1)
		dfs(to[i]);
	}
}
```

**然后假设现在要求$a$、$b$（$a$的深度大于$b$）的最近公共祖先：**
![](https://cdn.luogu.com.cn/upload/pic/46049.png)

**我们先运用$RMQ$将$a$跳到与$b$同一层的地方：**
![](https://cdn.luogu.com.cn/upload/pic/46050.png)

具体方法：
```cpp
int l=0;
	for(;(1<<l)<=deep[a];l++);//先计算上限
	l--;
	for(int i=l;i>=0;i--)if(deep[a]-(1<<i)>=deep[b])a=p[a][i];//将a与b移到同一层
```

**然后我们再用循环同时枚举$a$的$i$辈祖先$x$和$b$的$i$辈祖先$y$（节点$u$的$k$辈祖先表示$u$的*父亲的父亲的父亲...的父亲（共$2^k$个“的父亲”）*，代码中用$p[u][k]$表示）。**

**如果$x=y$，则说明此时$x$是在$a$、$b$的最近公共祖先的祖先了，那么我们不管它，因为它不是最近的公共祖先，继续往下枚举。**

**如果$x!=y$，则说明此时$x$和$y$并不是$a$、$b$的公共祖先，令$a=x$，$b=y$，并继续枚举。**

具体可以这么操作：
```cpp
for(int i=l;i>=0;i--)
{
	if(p[a][i]!=p[b][i])
	{
		a=p[a][i];
		b=p[b][i];
	}
}
```

**最后，$a$和$b$的父亲就是它们的最近公共祖先了。**
![](https://cdn.luogu.com.cn/upload/pic/46054.png)

全部代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>

#define N 1001
#define M 999001
#define L 10

using namespace std;

int t,n,q,cnt,root,deep[N],head[N],to[M],nxt[M],p[N][L];
bool vis[N];

void adde(int u,int v)//前向星存图
{
	cnt++;
	to[cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

void dfs(int u)//dfs标记深度
{
	for(int i=head[u];i;i=nxt[i])
	{
		deep[to[i]]=deep[u]+1;
		p[to[i]][0]=u;
		dfs(to[i]);
	}
}

int lca(int a,int b)//lca
{
	if(deep[a]<deep[b])swap(a,b);//注意让deep[a]>deep[b]
	int l=0;
	for(;(1<<l)<=deep[a];l++);
	l--;
	for(int i=l;i>=0;i--)if(deep[a]-(1<<i)>=deep[b])a=p[a][i];
	if(a==b)return a;//特判：如果a、b相等，则返回a（或b）。
	for(int i=l;i>=0;i--)
	{
		if(p[a][i]!=p[b][i])
		{
			a=p[a][i];
			b=p[b][i];
		}
	}
	return p[a][0];//返回a（或b）的父亲
}

int main()
{
	scanf("%d",&t);
	for(int Case=1;Case<=t;Case++)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			int m;
			scanf("%d",&m);
			for(int j=1;j<=m;j++)
			{
				int v;
				scanf("%d",&v);
				adde(i,v);
				vis[v]=true;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(!vis[i])
			{
				root=i;//求根
				break;
			}
		}
		deep[root]=0;//初始化
		dfs(root);
		for(int j=1;(1<<j)<=n;j++)//前置算法RMQ
		{
			for(int i=1;i<=n;i++)
			{
				p[i][j]=p[p[i][j-1]][j-1];
			}
		}
		scanf("%d",&q);
		printf("Case %d:\n",Case);
		while(q--)
		{
			int a,b;
			scanf("%d%d",&a,&b);
			printf("%d\n",lca(a,b));
		}
		cnt=0;//初始化
		memset(vis,false,sizeof(vis));
		memset(head,0,sizeof(head));
	}
}
```

---

## 作者：WAHearer (赞：6)

我用朴素算法都通过了。。。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct TREE{
	int father;
}tree[2005];//存当前节点的父亲
bool fathers[2005];//用来存祖宗节点
void getf(int n){
	fathers[n]=1;
	if(n==1)
		return;
	getf(tree[n].father);
}
void find(int n){
	if(fathers[n]==1){
		cout<<n<<endl;
		return;
	}
	find(tree[n].father);
}
int main(){
	int n,t;
	cin>>t;
	for(int k=1;k<=t;k++){
		cout<<"Case "<<k<<":"<<endl;
		cin>>n;
		for(int i=1;i<=n;i++){
			int a;
			cin>>a;
			for(int j=1;j<=a;j++){
				int num;
				cin>>num;
				tree[num].father=i;
			}
		}
		int q;
		cin>>q;
		for(int i=1;i<=q;i++){
			int x,y;
			cin>>x>>y;
			getf(x);//标记所有祖先
			find(y);//寻找最近的公共祖先
			for(int i=1;i<=n;i++){
				fathers[i]=0;//初始化
			}
		}
	}
	return 0;
}
```

---

## 作者：da32s1da (赞：5)

裸的LCA，注意输出**Case x:**(因为这错了一次**(╯‵□′)╯︵┻━┻**)

我用的是树剖版的LCA。
```
#include<cstdio>
#include<cstring>
#define me(x) memset(x,0,sizeof(x))
const int N=1050;
int t,n,m,p,q;
int to[N],fi[N],la[N],CNT;
inline void add_edge(int u,int v){
	to[++CNT]=v;la[CNT]=fi[u];fi[u]=CNT;
}
int dep[N],fa[N],siz[N],son[N];
void dfs(int u,int v,int depth){
	dep[u]=depth;fa[u]=v;siz[u]=1;
	for(int i=fi[u];i;i=la[i])
	if(to[i]!=v){
		dfs(to[i],u,depth+1);siz[u]+=siz[to[i]];
		if(siz[to[i]]>siz[son[u]]) son[u]=to[i];
	}
}
int top[N],bh[N],rnk[N],BH;
void dfs(int u,int v){
	top[u]=v;bh[u]=++BH;rnk[BH]=u;
	if(son[u]) dfs(son[u],v);
	for(int i=fi[u];i;i=la[i])
	if(to[i]!=fa[u]&&to[i]!=son[u])
	dfs(to[i],to[i]);
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]) u^=v^=u^=v;
		u=fa[top[u]];
	}
	return dep[u]<dep[v]?u:v;
}
int main(){
	scanf("%d",&t);int tt=t;
	while(t--){
		me(to);me(fi);me(la);CNT=0;
		me(dep);me(fa);me(siz);me(son);
		me(top);me(bh);me(rnk);BH=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&m);
			for(int j=1;j<=m;j++)
			scanf("%d",&p),add_edge(i,p);
		}
		dfs(1,0,1);
		dfs(1,1);
		scanf("%d",&m);printf("Case %d:\n",tt-t);
		for(int i=1;i<=m;i++)
		scanf("%d%d",&p,&q),printf("%d\n",lca(p,q));
	}
}
```

---

## 作者：Freddie (赞：2)

## LCA模板 我用的RMQ
- LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科

- 时间复杂度为O(nlogn) 。

#### 一.看见dalao都用前向星，~~我偏不用~~ 先介绍一下三个数组的含义
1. fa[u][i] 记录u的2^i辈祖先就是u
2. dep[u]   记录u的深度
3. point[u][i] 记录节点u的子节点

![tree](https://cdn.luogu.com.cn/upload/pic/18791.png)

#### 二.存图
其实就是用一个二维数组
我一开始用的queue后面看着有点麻烦就用vector了
```
vector<int> point[MAXN];
for(int j=1;j<=m;j++){
	scanf("%d",&x);
	fa[x][0]=i;	          //记录v的1辈祖先就是u(2^0=1)
	point[i].push_back(x);//用vector存子节点
    }
```
#### 三.预处理 倍增的精华
![](https://cdn.luogu.com.cn/upload/pic/39063.png)

#### 值得一提是是，我看见大多数求root都用的 _**入度**_|   来自（[拓扑排序](https://www.luogu.org/blog/constant/tuo-pu-pai-xu)）。然后用一个循环求入度为0的就是根节点。
**我做了一个小小的改动**:每次输入都输入的子节点编号，而且每个节点最多只有一个父亲，所以不会重复出现。而根节点的编号是不会出现的。所以我们先求出所有编号的和然后每次减去子节点的编号，最后剩下的数就是根节点的编号了~~qwq好像还慢了一点~~

$$ $$
#### 四.求LCA
求最近公共祖先，根据两个节点的的深度，如不同，向上调整深度大的节点，使得两个节点在同一层上，如果正好是祖先，结束；否则，将两个节点同时上移，查询最近公共祖先(两个过程均使用倍增加速)。

### 下面是代码
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
const int MAXN = 1030;
const int FA_LCA = 9;
using namespace std;
vector<int> point[MAXN];             //vector存树
int fa[MAXN][21],dep[MAXN],n,root=0;
void LCA_first(int u,int father){
    dep[u]=dep[father]+1;            //记录深度
    for(int i=0;i<FA_LCA;i++)
        fa[u][i+1]=fa[fa[u][i]][i];  //记录u的2^i辈祖先就是u
    for(int i=0;i<point[u].size();i++){
        LCA_first(point[u][i],u);
    }
}
int LCA(int x,int y){
    if(dep[x]<dep[y]) 
        swap(x,y);
    for(int i=FA_LCA;i>=0;i--)      //将x与y移到同一层
        if(dep[fa[x][i]]>=dep[y]){
            x=fa[x][i];
        }
    if(x==y)
            return x;       
    for(int i=FA_LCA;i>=0;i--)
        if(fa[y][i]!=fa[x][i])
            x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
void init(){                       //其他会覆盖，不用memset；
    for(int k=1;k<=n;k++)
        point[k].clear();
    root=0;                        //不然会wa！
}
int main()
{
    int T,TT;
    scanf("%d",&T),TT=T;
    while(T--){
        init();                    //初始化，不然会TLE！ 
        printf("Case %d:\n",TT-T); //输出第几组数据
        int m,x,y;
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d",&m);
            root=root+i;              //所有节点编号和
            for(int j=1;j<=m;j++){
                scanf("%d",&x);
                root=root-x;          //减去子节点编号，最后就为根节点
                fa[x][0]=i;	          //记录v的1辈祖先就是u(2^0=1)
                point[i].push_back(x);//用vector存子节点
            }
        }
        LCA_first(root,0);
        scanf("%d",&m);
        for(int i=1;i<=m;i++){
            scanf("%d%d",&x,&y);
            printf("%d\n",LCA(x,y));
        }
    }
}
```
### 五.关于tarjan求LCA
- 楼上大佬讲的很清楚了

求过~


---

## 作者：RocketTurtle (赞：1)

这道题一开始一直wa，看了评论要特判重点的询问关系QWQ。然后......就AC了

其实这是一道板子题，坑点就在判重。

1:首先建双向边及双向询问关系.

2:然后就是tarjan的板子.

3：最后输出询问结果时,max(node[2*i],node[2*i-1])是因为不知道哪个点先被访问到.
~~~
#include<string.h>
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int T,par[10000];
inline void start(){
	cin>>T;
}
int head1[10000],head2[10000],vis[10000],cnt,ans;
struct Edge{
	int to,prev;
}edge[10000000];
struct ASK{
	int from,to,prev;
}ask[10000000];
inline void addedge(int x,int y)
{
	edge[++cnt].to=y;
	edge[cnt].prev=head1[x];
	head1[x]=cnt;
}
inline void addask(int x,int y)
{
	ask[++ans].to=y;
	ask[ans].from=x;
	ask[ans].prev=head2[x];
	head2[x]=ans;
}
inline int find(int x){
	int r=x;
	while(r!=par[r])
	{
		r=par[r];
	}
	return par[r];
}
inline void init(int x,int y){
	int tx=find(x),ty=find(y);
	if(tx!=ty) par[tx]=ty;
}
int f[10000],node[10000000];
inline void lca(int x)
{
	for(int i=head1[x];i;i=edge[i].prev){
		int to=edge[i].to;if(to==f[x]) continue;f[to]=x;
		lca(to);
		init(to,x);
		vis[to]=1;
	}
	for(int i=head2[x];i;i=ask[i].prev){
		int to=ask[i].to;
		if(vis[to]) node[i]=find(to);
	}
}
inline void solve(){
	int h=0;
	while(T--){
		memset(head1,0,sizeof(head1));
		memset(head2,0,sizeof(head2));
		memset(vis,0,sizeof(vis));
		memset(node,0,sizeof(node));
		cnt=ans=0;
		int n;cin>>n;
		for(int i=1;i<=n;i++) f[i]=i,par[i]=i;
		for(int i=1;i<=n;i++){
			int m;cin>>m;if(!m) continue;
			for(int j=1;j<=m;j++){
				int p;cin>>p;addedge(i,p);addedge(p,i);
			}
		}
		int query;cin>>query;
		for(int i=1;i<=query;i++){
			int x,y;cin>>x>>y;if(x==y) node[i*2-1]=node[i*2]=x;addask(x,y);addask(y,x);
		}
		lca(1);
	    printf("Case %d:\n",++h);
		for(int i=1;i<=query;i++){
            printf("%d\n",max(node[2*i],node[2*i-1]));
		}
	}
}
int main(){
	start();
	solve();
	return 0;
}
~~~

---

## 作者：LGG_ (赞：0)

# LCA 易理解
裸lca就是变成了找几颗树的节点的lca
以下代码可能不是最优，但是很好理解。

不会lca的可以了解

[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.org/problem/P3379)

如果模板不了解的可以看[提交记录](https://www.luogu.org/record/22725222)

细节在代码讲解

```c
#include"iostream"
#include"cstdio"
#include"cstring"
using namespace std;
int n,m,s,next[20001],first[20001],go[20001];
int tot,dep[10001],f[10001][30];
bool vis[10001];//找树的根节点
void add(int u,int v)//前向星
{
	go[++tot]=v;
	next[tot]=first[u];
	first[u]=tot;
}
void _first(int u,int father)//建树
{
	dep[u]=dep[father]+1;
	f[u][0]=father;//初始化
	for(int i=0;i<=19;i++)f[u][i+1]=f[f[u][i]][i];
	for(int e=first[u];e;e=next[e])
	{
		int v=go[e];
		if(v==father)continue;
		//f[v][0]=u;//可以在这儿初始化
		_first(v,u);//递归
	}
}
int lca(int x,int y)//找lca（公共祖先节点）
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i=20;i>=0;i--)
	{
		if(dep[f[x][i]]>=dep[y])x=f[x][i];
		if(x==y)return x;//相同的话直接返回祖先节点
	}
	for(int i=20;i>=0;i--)
	{
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];//递归
}
void qing()//清零函数
{
	memset(f,0,sizeof(f));
	memset(dep,0,sizeof(dep));
	memset(next,0,sizeof(next));
	memset(go,0,sizeof(go));
	memset(vis,false,sizeof(vis));
	memset(first,0,sizeof(f));
	tot=0;
    //f，go，next，tot——可以不清
   //这样更容易理解⁽˚̌ʷ˚̌ʺ⁾

}
int main()
{
	int t;
	cin>>t;
	for(int now=1;now<=t;now++)
	{	
		qing();
		int a,b,c;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&c);
				for(int k=1;k<=c;k++)
				{
				scanf("%d",&a);
				add(i,a);
				add(a,i);
				vis[a]=true;//记录子节点
				}
		}
		int root;
		for(int i=1;i<=n;i++)
		{
			if(vis[i]!=true)
			{
				root=i;//找到根节点
				break;//小优化
			}
		}
		_first(root,0);//建树
		cin>>m;
		printf("Case %d:\n",now);
		while(m--)
		{
			scanf("%d%d",&a,&b);
			printf("%d\n",lca(a,b));
		}
	}
	return 0;	
}
```

## 总结
- 建树>>>>找根节点>>>>找lca>>>>清零>>>返回

广告时间：[小三的落谷博客](https://www.luogu.org/blog/MC233/)

---

## 作者：Fuko_Ibuki (赞：0)

我仔细看数据范围.  
这个数据范围看起来很小,我用了一些暴力做法.  
记忆化搜索求$lca$.  
定义$pa[i][j]$为$i$和$j$的最近公共祖先,初始化为$-1$.  
如果$i$和$j$相等,返回$i$.  
如果$dep[i]>dep[j]$,把$i$向上跳,返回$lca(fa[i],j)$.  
最后的情况返回$lca(i,fa[j])$.  
那么只要用一遍$dfs$处理每一个节点的父亲和深度就可以了.
谢谢大家.
```cpp
#include<bits/stdc++.h> //Ithea Myse Valgulious
namespace chtholly{
typedef long long ll;
#define re0 register int
#define rel register ll
#define rec register char
#define gc getchar
//#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?-1:*p1++)
#define pc putchar
#define p32 pc(' ')
#define pl puts("")
/*By Citrus*/
char buf[1<<23],*p1=buf,*p2=buf;
inline int read(){
  int x=0,f=1;char c=gc();
  for (;!isdigit(c);c=gc()) f^=c=='-';
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return f?x:-x;
  }
template <typename mitsuha>
inline bool read(mitsuha &x){
  x=0;int f=1;char c=gc();
  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';
  if (!~c) return 0;
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return x=f?x:-x,1;
  }
template <typename mitsuha>
inline int write(mitsuha x){
  if (!x) return 0&pc(48);
  if (x<0) pc('-'),x=-x;
  int bit[20],i,p=0;
  for (;x;x/=10) bit[++p]=x%10;
  for (i=p;i;--i) pc(bit[i]+48);
  return 0;
  }
inline char fuhao(){
  char c=gc();
  for (;isspace(c);c=gc());
  return c;
  }
}using namespace chtholly;
using namespace std;
const int aoi=2038;
typedef int fuko[aoi];
vector<int> lj[aoi];
fuko pa[aoi],dep,fa;
int lca(int u,int v) {
  return u==v?u:~pa[u][v]?pa[u][v]:pa[u][v]=dep[u]>dep[v]?lca(fa[u],v):lca(u,fa[v]);
}
void dfs(int u) {
  for (int v:lj[u]) fa[v]=u,dep[v]=dep[u]+1,dfs(v);
}
int main() {
  for (int t=read(),i,n,zxy=0; t--;) {
    for (n=read(),i=1; i<=n; ++i) lj[i].clear();
    memset(pa,-1,sizeof pa);
    for (i=1; i<=n; ++i)
      for (int k=read(); k--;) lj[i].push_back(read());
    printf("Case %d:\n",++zxy),dfs(1);
    for (int q=read(); q--;)
      write(lca(read(),read())),pl;
  }
}
```

---

## 作者：Misaka_Azusa (赞：0)

裸的LCA。

我用的是倍增LCA。

另外附上蒟蒻的[倍增LCA博客](http://www.cnblogs.com/MisakaAzusa/p/8612942.html)。

```
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 500001 + 10;
const int maxlog = 20;
int n, m, root, f[maxn][maxlog], deep[maxn], ans[maxn];
struct edge{
	int next, to;
}e[maxn<<2];
int cnt, head[maxn];
void add(int u, int v)
{
	e[++cnt].next = head[u]; e[cnt].to = v; head[u] = cnt;
	e[++cnt].next = head[v]; e[cnt].to = u; head[v] = cnt;
}
void dfs(int u, int p, int d)
{
	f[u][0] = p;
	deep[u] = d;
	for(int i = head[u]; i != -1; i = e[i].next)
	if(e[i].to != p) dfs(e[i].to, u, d+1);
}
void init()
{
	dfs(root, -1, 1);
	for(int i = 0; i + 1 < maxlog; i++)
	{
		for(int u = 1; u <= n; u++)
		if(f[u][i] < 0) f[u][i+1] = -1;
		else f[u][i+1] = f[f[u][i]][i]; 
	}
}
int LCA(int x, int y)
{
	if(deep[x] > deep[y]) swap(x,y);
	for(int i = 0; i < maxlog; i++)
	{
		if(deep[x] == deep[y]) break;
		if((deep[y]-deep[x])>>i&1) y = f[y][i];
	}
	if(x == y) return x;
	for(int i = maxlog - 1; i >= 0; i--)
	{
		if(f[x][i] != f[y][i])
		{
			x = f[x][i];
			y = f[y][i];	
		}	
	} 
	return f[x][0];
}
int main()
{
	int T;
	scanf("%d",&T);
	for(int k = 1; k <= T; k++)
	{
		memset(head, -1, sizeof(head));
		memset(ans, 0, sizeof(ans));
		memset(f, 0, sizeof(f));
		memset(deep, 0, sizeof(deep));
		memset(e,0,sizeof(e));
		root = 1;
		scanf("%d",&n);
		for(int i = 1; i <= n; i++)
		{
			int num;
			scanf("%d",&num);
			for(int j = 1; j <= num; j++)
			{
				int u;
				scanf("%d",&u);
				add(u,i);
			}
		}
		init();
		scanf("%d",&m);
		for(int i = 1; i <= m; i++)
		{
			int u, v;
			scanf("%d%d",&u,&v);
			ans[i] = LCA(u,v);
		}
		printf("Case %d:\n",k);
		for(int i = 1; i <= m; i++)
		printf("%d\n",ans[i]);
	}
	return 0;
}
```

---


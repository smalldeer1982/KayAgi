# SNGINT - Encode Integer

## 题目描述

Given an integer N **(0 <= N < 10 $ ^{7} $ )**. Encode N into another possible smallest integer M **(M > 0)**, such that product of digits of M equals to N.

## 样例 #1

### 输入

```
3
24
5
11```

### 输出

```
38
5
-1```

# 题解

## 作者：LightSpot (赞：0)

# SP18273 SNGINT - Encode Integer 题解
## 题意
给定 $T$ 个非负整数 $N$，求一个最小的正整数 $\overline{a_1a_2a_3...a_n}$，满足 
$\displaystyle\prod_{i = 1}^{n}a_i = N$，若不存在输出 $-1$。
## 思路
本题可以使用贪心求解。

因为所求的数每一个数位上的数字都 $< 10$，所以当且仅当 $N$ 分解质因数后最大的质因子 $< 10$ 才存在满足条件的解。又因为 $10$ 以内的质数只有 $2 , 3 , 5 , 7$，我们只用判断 $N$ 在提尽这四个质数后是否仍然 $> 10$，若是则无解。

顺着该思路往下想，如果数 $N$ 有解，我们就记录下它的因子里 $2 , 3 , 5 , 7$ 的次数，并用这四个数来组成我们想要的数。(下文里 $N$ 中的因子 $k$ 的次数记为 $cnt_k$) 但是直接将这四个数从小到大排它们各自的出现次数个是不行的，例如对于 $N = 16$，数 $28$ 显然比数 $2222$ 更优。这说明我们要尽可能把这四个数再次用乘的方式组合成一个 $< 10$ 的数（这里的**组合**指无序地选数相乘，下文也是这个意思），以达到使位数更小的目的。这样贪心显然正确，因为组合后数的位数一定比原来小，而位数更小的数一定比位数更大的数小。由此我们发现：$2 \times 2 \times 2 = 8 , 2 \times 2 = 4 , 3 \times 3 = 9 , 2 \times 3 = 6$ 都是满足条件的组合方式。然而当这些组合方式都可以使用时，我们应优先使用哪个呢？

- 当 $cnt_2 \geq 3$ 时，尽可能多的使用 $2 \times 2 \times 2 = 8$，因为这是唯一一个能将三个数合成一个数的组合方式，尽可能多的减少了答案的位数。
- 此时 $cnt_2 \leq 2$，下文证明当 $cnt_2 = 2$ 且 $cnt_3$ 为奇数时，我们不能使用 $2 \times 2 = 4$ 的组合方式：设 $cnt_3 = 2k + 1$，我们可以将前 $2k$ 个 $3$ 用 $3 \times 3 = 9$ 的方式组合起来，剩下两个 $2$ 中的一个与剩下的 $3$ 组合成 $6$，便会形成一个 $2$，一个 $6$ 与 $k$ 个 $9$。但若将两个 $2$ 组合成 $4$，我们可以同理推得最终会有一个 $3$，一个 $4$ 和 $k$ 个 $9$，显然没有前者优。
- 而当 $cnt_2 = 2$ 且 $cnt_3$ 为偶数时，我们仿照上文的证明可以得到此时一定要尽可能多地使用 $2 \times 2 = 4 , 3 \times 3 = 9$ 这两种组合方式才会最优。
- 当 $cnt_2 = 1$ 时，同理可得应尽可能优先使用 $3 \times 3 = 9$ 的组合方式。若组合后 $cnt_3 = 1$，则为了保证最终数位最小，我们使用 $2 \times 3 = 6$ 进行组合。

发现了吗？上面分析的结论转化后得到的组合方式的优先级如下：$2 \times 2 \times 2 = 8 > 3 \times 3 = 9 > 2 \times 3 = 6 > 2 \times 2 = 4$，于是我们在安排组合顺序时按照这个优先级写 if 即可。这也就是我们的贪心策略。（最后那三种组合方式的顺序是按它们乘积由大到小排的，似乎有什么规律，但我不会证明为什么是这样qwq）在输出答案时，我们只需从 $1$ 到 $9$ 输出 $cnt_k$ 个数 $k$ 即可。

**注意：当 $N$ 为 $1$ 或 $0$ 时存在解，分别为 $1$ 与 $10$，但这两个数因为无法分解质因数不在上述讨论范围中，所以要进行特判。**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T , num;
int cnt[10];

//count函数用于记录num中因子p的个数 
inline void count(const int &p)
{
	while(num % p == 0)
	{
		num /= p;
		cnt[p]++;
	}
	return;
}

int main()
{
	cin >> T;
	while(T--)
	{
		//初始化与输入 
		memset(cnt , 0 , sizeof(cnt));
		scanf("%d" , &num);
		
		//特判 
		if(num == 1)
		{
			printf("1\n");
			continue;
		}
		if(!num)
		{
			printf("10\n");
			continue;
		}
		
		//分解质因数并记录个数 
		count(2);
		count(3);
		count(5);
		count(7);
		
		//判断无解 
		if(num != 1)
		{
			printf("-1\n");
			continue;
		}
		
		//组合质因数 
		cnt[8] += cnt[2] / 3;
		cnt[2] %= 3;
		
		cnt[9] += cnt[3] / 2;
		cnt[3] %= 2;
		
		cnt[6] += min(cnt[2] , cnt[3]);
		cnt[2] -= cnt[6];
		cnt[3] -= cnt[6];
		
		cnt[4] += cnt[2] / 2;
		cnt[2] %= 2;
		
		//从小到大输出 
		for(int i = 1 ; i <= 9 ; i++) for(int j = 1 ; j <= cnt[i] ; j++) printf("%d" , i);
		printf("\n");
	}
	return 0;
}
```

---


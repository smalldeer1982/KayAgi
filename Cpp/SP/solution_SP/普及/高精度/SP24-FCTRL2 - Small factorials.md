# FCTRL2 - Small factorials

## 题目描述

要求计算小的正整数的阶乘。

## 样例 #1

### 输入

```
4
1
2
5
3```

### 输出

```
1
2
120
6```

# 题解

## 作者：Dimly_dust (赞：4)

这道题说实话实在简单
- C++用高精度写。

这道题应为数据量较小（$N<101$）,普通的高精就行了，可以不用压位高精。

参考程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
void answer()//高精模板
{
	short a[10001]= {0,1};//设定初始值，考虑到乘法，需开头用一
	short n,len=1;//初始长度len为一
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=len; j++)
		{
			a[j]*=i;//按位乘
		}
		for(int j=1; j<=len; j++)//进位
		{
			if(a[j]>=10)
			{
				if(a[j+1]==0)len++;//判断是否长度可加长
				a[j+1]+=(a[j]/10);
				a[j]%=10;
			}
		}
	}
	while(a[len]==0)len--;//过滤前面的零
	for(int i=len; i>=1; i--)cout<<a[i];
	cout<<endl;
	return;
}
int main()
{
	short t;
	cin>>t;//T组数据
	for(int i=1; i<=t; i++) answer();//输出答案
}
```



- Python因为自带高精普通的写就行了。

参考程序：

- 循环实现

```python
n=int(input())
for i in range(n):
    x = 1
    y = int(input())
    for i in range(1, y + 1):
       x = x * i #计算阶乘
    print(x)

```
- 递归实现

```python
def func(n):
    if n == 0 or n == 1:
        return 1
    else:
        return (n * func(n - 1))
n=int(input())
for i in range(n):
	che=int(input())
    print(func(che))

```




---

## 作者：Dream_It_Possible (赞：2)

此题为 _高精度类型_ 题目，**高乘单**即可AC。
用一个变量记录进位，在下一位加上它，然后在记录进位，再用一个变量记录位数。

注意：

1. 每次数组要清零，**个位赋1**。
1. 乘的时候要考虑**多出来的那位**和**值的位数**。
1. **倒着输出**

放代码：
```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int a[1005];
int main()
{	
	int t;
	cin>>t;
	while (t--)
	{
		int n,i,j,k;
		int p=1,jw=0;//jw为进位的值
		memset(a,0,sizeof(a));//每次清0
		a[1]=1;//个位为1，不然怎么乘都是0
		scanf("%d",&n);
		for(i=2;i<=n;i++)
		{
			jw=0;
			for(j=1;j<=p;j++)
			{
				a[j]=a[j]*i+jw;
				jw=a[j]/10;
				a[j]=a[j]%10;
			}
			while(jw>0)
			{
				a[j]=jw%10;
				jw/=10;
				j++;
			}
			p=j-1;//p记录位数
		}
		for (i=p;i>=1;i--)//倒着输出
		cout<<a[i];
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：hero_brine (赞：1)

俗话说得好：贪心过样例，暴力出奇迹，骗分最神奇，打表进省一（手动滑稽）

这道题的数据范围并不大，只在1到100之间，可以使用Python打表，代码如下：
```python
def factorial(k):
    k=int(k)
    if k==0:
        return 1
    else:
        return k*factorial(k-1);
for i in range(101):
    print('"',end="")
    print(factorial(i),end="")
    print('"',end="")
    print(", ",end="")


```
C++代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;
//之所以用string是因为unsigned long long也不够
string fac[]={"1", "1", "2", "6", "24", "120", "720", "5040", "40320", "362880", "3628800", "39916800", "479001600", "6227020800", "87178291200", "1307674368000", "20922789888000", "355687428096000", "6402373705728000", "121645100408832000", "2432902008176640000", "51090942171709440000", "1124000727777607680000", "25852016738884976640000", "620448401733239439360000", "15511210043330985984000000", "403291461126605635584000000", "10888869450418352160768000000", "304888344611713860501504000000", "8841761993739701954543616000000", "265252859812191058636308480000000", "8222838654177922817725562880000000", "263130836933693530167218012160000000", "8683317618811886495518194401280000000", "295232799039604140847618609643520000000", "10333147966386144929666651337523200000000", "371993326789901217467999448150835200000000", "13763753091226345046315979581580902400000000", "523022617466601111760007224100074291200000000", "20397882081197443358640281739902897356800000000", "815915283247897734345611269596115894272000000000", "33452526613163807108170062053440751665152000000000", "1405006117752879898543142606244511569936384000000000", "60415263063373835637355132068513997507264512000000000", "2658271574788448768043625811014615890319638528000000000", "119622220865480194561963161495657715064383733760000000000", "5502622159812088949850305428800254892961651752960000000000", "258623241511168180642964355153611979969197632389120000000000", "12413915592536072670862289047373375038521486354677760000000000", "608281864034267560872252163321295376887552831379210240000000000", "30414093201713378043612608166064768844377641568960512000000000000", "1551118753287382280224243016469303211063259720016986112000000000000", "80658175170943878571660636856403766975289505440883277824000000000000", "4274883284060025564298013753389399649690343788366813724672000000000000", "230843697339241380472092742683027581083278564571807941132288000000000000", "12696403353658275925965100847566516959580321051449436762275840000000000000", "710998587804863451854045647463724949736497978881168458687447040000000000000", "40526919504877216755680601905432322134980384796226602145184481280000000000000", "2350561331282878571829474910515074683828862318181142924420699914240000000000000", "138683118545689835737939019720389406345902876772687432540821294940160000000000000", "8320987112741390144276341183223364380754172606361245952449277696409600000000000000", "507580213877224798800856812176625227226004528988036003099405939480985600000000000000", "31469973260387937525653122354950764088012280797258232192163168247821107200000000000000", "1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000", "126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000", "8247650592082470666723170306785496252186258551345437492922123134388955774976000000000000000", "544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000", "36471110918188685288249859096605464427167635314049524593701628500267962436943872000000000000000", "2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000", "171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000", "11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000", "850478588567862317521167644239926010288584608120796235886430763388588680378079017697280000000000000000", "61234458376886086861524070385274672740778091784697328983823014963978384987221689274204160000000000000000", "4470115461512684340891257138125051110076800700282905015819080092370422104067183317016903680000000000000000", "330788544151938641225953028221253782145683251820934971170611926835411235700971565459250872320000000000000000", "24809140811395398091946477116594033660926243886570122837795894512655842677572867409443815424000000000000000000", "1885494701666050254987932260861146558230394535379329335672487982961844043495537923117729972224000000000000000000", "145183092028285869634070784086308284983740379224208358846781574688061991349156420080065207861248000000000000000000", "11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000", "894618213078297528685144171539831652069808216779571907213868063227837990693501860533361810841010176000000000000000000", "71569457046263802294811533723186532165584657342365752577109445058227039255480148842668944867280814080000000000000000000", "5797126020747367985879734231578109105412357244731625958745865049716390179693892056256184534249745940480000000000000000000", "475364333701284174842138206989404946643813294067993328617160934076743994734899148613007131808479167119360000000000000000000", "39455239697206586511897471180120610571436503407643446275224357528369751562996629334879591940103770870906880000000000000000000", "3314240134565353266999387579130131288000666286242049487118846032383059131291716864129885722968716753156177920000000000000000000", "281710411438055027694947944226061159480056634330574206405101912752560026159795933451040286452340924018275123200000000000000000000", "24227095383672732381765523203441259715284870552429381750838764496720162249742450276789464634901319465571660595200000000000000000000", "2107757298379527717213600518699389595229783738061356212322972511214654115727593174080683423236414793504734471782400000000000000000000", "185482642257398439114796845645546284380220968949399346684421580986889562184028199319100141244804501828416633516851200000000000000000000", "16507955160908461081216919262453619309839666236496541854913520707833171034378509739399912570787600662729080382999756800000000000000000000", "1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000", "135200152767840296255166568759495142147586866476906677791741734597153670771559994765685283954750449427751168336768008192000000000000000000000", "12438414054641307255475324325873553077577991715875414356840239582938137710983519518443046123837041347353107486982656753664000000000000000000000", "1156772507081641574759205162306240436214753229576413535186142281213246807121467315215203289516844845303838996289387078090752000000000000000000000", "108736615665674308027365285256786601004186803580182872307497374434045199869417927630229109214583415458560865651202385340530688000000000000000000000", "10329978488239059262599702099394727095397746340117372869212250571234293987594703124871765375385424468563282236864226607350415360000000000000000000000", "991677934870949689209571401541893801158183648651267795444376054838492222809091499987689476037000748982075094738965754305639874560000000000000000000000", "96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000", "9426890448883247745626185743057242473809693764078951663494238777294707070023223798882976159207729119823605850588608460429412647567360000000000000000000000", "933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000", "93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000"};
int n,a[105];
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    for (int i = 0; i < n; i++) cout<<fac[a[i]]<<endl;
    return 0;    
}

```


---

## 作者：panda_wang (赞：1)

# 【题意】
### 给出N , 然后给出A[I] , 求A中每个元素的阶乘
# 【解决方法】
### 使用语言：Python3
### 解决方案：( 1 ) 直接计算：导入math库，使用factorial函数进行阶乘计算
### 解决方案：( 2 ) 自己计算：使用阶乘的原理，利用for语句实现阶乘计算

### 代码：
### (1)
```python
import math

i = int(input())
v = []


for s in range(i):
    v.append(input())

for j in range(i):
    print(math.factorial(int(v[j])))
```
### (2)
```

i = int(input())
v = []


for s in range(i):
    v.append(input())

def fact(n):
    if n == 1:  
        return 1  
    else:  
        return n * fact(n-1)  

for fr1 in range(i):
    print(fact(int(v[fr1])))
```


---

## 作者：xzllll07 (赞：0)

逛了一圈，好像没人用字符串写高精，赶紧来写一篇。

这题是很容易的高精度，~~其实我觉得这题不应该是黄题，P1009比这个难。~~

进入正题，这道题 $n$ 范围是1到100，很容易看出需要高精。

**上代码。**
```cpp
#include <bits/stdc++.h>
using namespace std;
    
int c[20010];
string times(string a,string b)
{
    memset(c,0,sizeof(c));//清空数组
    int len1 = a.length();
    int len2 = b.length();
    reverse(a.begin(), a.end()); //反转字符串，右侧对齐。
    reverse(b.begin(), b.end());   
    for (int i=0;i<len1;i++) //双重 for 循环计算
    {
        for (int j=0;j<len2;j++)
        {
            int idx = i+j;
            c[idx]+=(a[i]-'0')*(b[j]-'0');
            c[idx+1] += c[idx]/10;
            c[idx] = c[idx]%10;      
        }
    }
    string ans="";
    bool flag=0;
    for (int i=20009;i>=0;i--) //重新转化回字符串并返回
    {
        if (!flag && c[i]!=0)
        {
            flag = 1;
        }
            if (flag)
        {
            ans+=(c[i]+'0');
        }
    }
    
    if (ans.length()==0) return "0";
    return ans;
}

int main()
{
    int t;
    cin>>t;
    while (t--) //省去一个循环变量
    {
        int n;
        cin>>n;
        string prod="1"; //初始值设为1，如果设为0的话结果都是0
        for (int i=2;i<=n;i++)
        {
            prod=times(prod,i);
        }
        cout<<prod<<endl;		
    }
	
}
```

**看起来是不是没什么问题？**

但是，大家注意，我们定义的 $\operatorname{times}$ 函数，接收的是两个字符串类型变量，而在 for 循环调用函数时，$i$ 是整型。

**那怎么解决呢？**

我们可以定义一个字符串数组，$str_{i}$ 就设为 "i"，这样，我们就可以将 $i$ 与 $prod$ 乘在一起了。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
    
int c[20010];
string times(string a,string b)
{
    memset(c,0,sizeof(c));//清空数组
    int len1 = a.length();
    int len2 = b.length();
    reverse(a.begin(), a.end()); //反转字符串，右侧对齐。
    reverse(b.begin(), b.end());   
    for (int i=0;i<len1;i++) //双重 for 循环计算
    {
        for (int j=0;j<len2;j++)
        {
            int idx = i+j;
            c[idx]+=(a[i]-'0')*(b[j]-'0');
            c[idx+1] += c[idx]/10;
            c[idx] = c[idx]%10;      
        }
    }
    string ans="";
    bool flag=0;
    for (int i=20009;i>=0;i--) //重新转化回字符串并返回
    {
        if (!flag && c[i]!=0)
        {
            flag = 1;
        }
            if (flag)
        {
            ans+=(c[i]+'0');
        }
    }
    
    if (ans.length()==0) return "0";
    return ans;
}

int main()
{
    string str[101]={"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100"};
    int t;
    cin>>t;
    while (t--) //省去一个循环变量
    {
        int n;
        cin>>n;
        string prod="1"; //初始值设为1，如果设为0的话结果都是0
        for (int i=2;i<=n;i++)
        {
            prod=times(prod,str[i]); //注意这里用str[i]
        }
        cout<<prod<<endl;		
    }
	
}
```

附：

本蒟蒻太懒了，$str$ 数组的定义并不想自己手打，所以写了一小段程序来生成。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    cout<<"string str[101]={";
    for (int i=1;i<=100;i++) 
    {
        cout<<"\""<<i<<"\""<<",";
    }
    cout<<"};";
}
```
注意最后生成的代码，在 "100" 后面多了一个逗号，记得删掉。

---

## 作者：不到前10不改名 (赞：0)

//高精度阶乘怎么可能是黄题？？？这乱评的吧！
```
#include<stdio.h>
#include<string.h>
int srx[10001],sry,n,q,i,j,lhy;
void lgx(int t)
{
    srx[1]=1;//多组数据所以要清零和赋初值
    sry=1;
    memset(srx,0,sizeof(srx));//小心有坑
    for(int i=1;i<=t;i++)
    {lhy=0;//重置
    for(int j=1;j<=sry;j++)
    {srx[j]=srx[j]*i+lhy;
    lhy=srx[j]/10;//处理进位
    srx[j]%=10;}
    srx[sry+1]+=lhy;//最后一位没有进
    while(srx[sry+1])//更新长度
    {if(srx[sry+1]>=10)
    {srx[sry+2]=srx[sry+1]/10;
    srx[sry+1]%=10;}
    sry++;}}
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;++i)
    {scanf("%d",&q);
    lgx(q);
    for(j=sry;j>=1;--j)
    printf("%d",srx[j]);
    printf("\n");}
    return 0;
    }

```

---

## 作者：Nozebry (赞：0)

## 题目分析：
这道题如果用**C++** 或者 **pascal** 的话，那就必须自己去打一打高精度，但在这里，我们将使用自带高精度的 **Python 3** 来实现

## 解决方案:
No.1:直接计算：导入math库，使用库内自带函factorial数进行阶乘计算解决问题；

No.2 手打计算：利用Python 3自带的高精，直接计算阶乘。具体实现利用for语句实现即可

### No.1
#### AC Code:
```python
import math
lck=int(input())
for hlz in range(lck):
    nzb=int(input())
    lckAKIOI=math.factorial(int(nzb))
    print(lckAKIOI)
```
### No.2
No.2代码请自行尝试，增加对Python 3语言的使用感觉

（温馨提示：请勿抄袭代码，后果自负^_^）

---


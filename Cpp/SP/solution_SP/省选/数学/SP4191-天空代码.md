# 天空代码

## 题目描述

Stancu 喜欢太空旅行，但他是一个贫穷的软件开发者，永远买不起自己的飞船。因此，他准备偷窃 Petru 的飞船。唯一的问题是，Petru 用一个基于银河系星星 ID 编号的复杂加密系统锁住了飞船。为了破解这个系统，Stancu 必须检查每组四颗星星的子集，确保它们的编号的唯一公约数是 $1$。这可太麻烦了！

幸运的是，Stancu 成功地将星星数量限制为 $n$，但即便如此，四颗星星的可能子集仍然可能非常多。帮助他找出这些子集的数量，并判断是否有机会破解系统。

## 说明/提示

$1 \leq n \leq 10000$。

## 样例 #1

### 输入

```
4
2 3 4 5
4
2 4 6 8
7
2 3 4 5 7 6 8```

### 输出

```
1
0
34```

# 题解

## 作者：tuzhewen (赞：9)

啊这，为什么题解全是容斥做的啊。那我提供一种莫比乌斯反演的做法吧~


我们令$f(n)$表示四个数最大公因数为$n$的方法数，$F(n)$表示四个数的 $gcd$ 为$n$的倍数的方法数

那么不难发现，这两个函数满足莫比乌斯反演的条件，所以说：
$f(n)=\sum\limits_{n|d}\mu(\frac{d}{n})F(d)$

我们要的答案就是所有的$f(n)$，那么我们求出每个$F(x)$的值就好了。怎么求呢？由定义可得：$F(x)$的值我们就可以通过计算$x$的倍数在整个数列里面出现了多少次就好了（包括它本身），那么我们要从这些$x$的倍数中（假设有$k$个）任选$4$个，所以每一个$F(x)$的贡献就是$C^4_k$了

~~开不开`long long`都没事的样子？~~

那么下面就是$ACcode$：
```
#include<cstdio>
#include<cstring>
#define F(i,l,r) for(register int i=l;i<=r;i++)
#define D(i,r,l) for(register int i=r;i>=l;i--)
#define ll long long
#define mem(a,b) memset(a,b,sizeof(a))
#define p_b push_back
#define m_p make_pair
#define il inline
const int INF=0x3f3f3f3f,N=1e4+5,M=1e4;
using namespace std;
int mu[N];
bool isp[N];
int prime[N],num;
int n,a[N];
void get_mu() {
	mu[1]=1;
	F(i,2,M) isp[i]=1;
	F(i,2,M) {
		if(isp[i]) prime[++num]=i,mu[i]=-1;
		F(j,1,num) {
			if(prime[j]*i>M) break;
			isp[prime[j]*i]=0;
			if(i%prime[j]==0) {mu[prime[j]*i]=0;break;}
			mu[prime[j]*i]=-mu[i];
		}
	}
}//递推求mu
ll calc(ll n) {return n*(n-1)*(n-2)*(n-3)/24ll;}
int Pr[N],cnt;
int F[N],app[N];
int main() {
	get_mu();
	while(~scanf("%d",&n)) {
		if(n<4) {puts("0");continue;}
		mem(app,0),mem(F,0);//不要忘记初始化！
		F(i,1,n) scanf("%d",&a[i]),app[a[i]]++;//计算每个数字出现的次数，待会计算x的倍数出现多少次要用到
		ll ans=0;
		F(i,1,M) for(int j=i;j<=M;j+=i) F[i]+=app[j];//计算F(x)的值
		F(i,1,M) if(F[i]>=4) ans+=calc(F[i]*1ll)*1ll*mu[i];//把F(x)的贡献加上
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：laduiw (赞：7)

# 容斥原理基本应用
上手容斥定理推荐[容斥](https://blog.csdn.net/TRiddle/article/details/51873991)

然后说说这题的做法，套路依然是总的减掉不合法的，总的显然是C(n,4),不合法的是四个数gcd>1,然后就是gcd>1的个数。

做过hdu4153的大佬可以轻松联想到gcd和质因数有关，设sum[i]表示n个数中是i的倍数的个数，可以用调和级数那样的复杂度搞出来，cnt[i]表示i由多少个不同质数连乘起来,注意一定要不同，然后就容斥了，若x由奇数个质数连乘起来就加上C(sum[x],4)，否则就减C(sum[x],4)，再用C(n,4)减掉这些这些就行了。注意一下这里不能像hdu那题用2的幂次表示状态，因为那题是单点，这题是区间，所以直接枚举x就好。

Code
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=10000;
int n,v[N+10],pd[N+10],su[N+10],sum[N+10],cnt[N+10],flag[N+10];
LL calc(int x)
{
	return (LL)x*(x-1)*(x-2)*(x-3)/(LL)24;
}

int main()
{
	//freopen("pp.in","r",stdin);
	//freopen("bf.out","w",stdout);
	int tot=0;
	for (int i=2;i<=N;i++)
	{
		if (pd[i]==0) {
			su[tot++]=i;
			for (int j=i;j<=N;j+=i)
			{
				pd[j]=1;
				if (j%(i*i)!=0 && flag[j]==0) cnt[j]++;
					else cnt[j]=0,flag[j]=1;//一但出现质因子次数>=2直接不要了
			}
		}
	}
        //预处理出cnt，以及素数
	while (scanf("%d",&n)!=EOF)
	{
		memset(v,0,sizeof(v));
		memset(sum,0,sizeof(sum));
		for (int i=1;i<=n;i++)
		{
			int x;
			scanf("%d",&x);
			v[x]++;//可能会重数，不能写v[x]=1
		}
		for (int i=1;i<=N;i++)
			for (int j=i;j<=N;j+=i) sum[i]+=v[j];
		LL ans=calc(n);//这里是先赋值成总数，所以后面符号要变
		for (int i=2;i<=N;i++)
		{
			if (cnt[i]) {
				if (cnt[i]&1) ans-=calc(sum[i]);
					else ans+=calc(sum[i]);
			}
		} // 对于容斥里面的是奇减偶加，还是反过来，可以用cnt=1代表所有奇数情况来想，明白在求什么，就不太会出错
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：lianchanghua (赞：4)

#### 题目大意

有 $n$ 个正整数 $a_i$，你要统计有多少个四元组满足全部互质（不要求两两互质）。

#### 思路

本题需要用到容斥原理。
我可以逆向考虑：我们去考虑其补集, 我们求出四个数的最大公约数大于 $1$ 的。然后再用 $C_{n}^{4}$ 减去剩下的就是结果。我们就可以将每个数的因子都分解出来。然后进行相加减，如 $6$ 时，$6$ 会重复出现在 $2$，$3$ 中，所以就从中减去，每个都进行这样的操作即可。

思路就是这个思路，实现就十分简单了。

[双倍经验](https://www.luogu.com.cn/problem/P2714)

#### AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
int a[10010],ans[10010];
void q(int x){
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			a[i]++;
			if(i*i!=x) a[x/i]++;
		}
	}
}
int qq(int x){
	return x*(x-1)*(x-2)*(x-3)/24;
}
signed main(){
    while(cin>>n){
        memset(ans,0,sizeof(ans));
        memset(a,0,sizeof(a));
        for(int i=1;i<=n;i++){
        	int x;
        	cin>>x;
        	q(x);
    	}
        for(int i=10000;i>=1;i--){
        	ans[i]=qq(a[i]);
        	for(int j=i*2;j<=10000;j+=i)
        		ans[i]-=ans[j];
    	}
    	cout<<ans[1]<<"\n";    
    }
	return 0;
}
```

---

## 作者：Register_int (赞：3)

小清新容斥题。  
直接硬刚不太好做，考虑问题的反面，即有多少个四元组 $a,b,c,d$ 满足 $\gcd(a,b,c,d)>1$。枚举这个 $gcd$ 的约数 $x$，并且设序列中能被 $x$ 整除的数的个数为 $x=n$，则满足 $x|gcd(a,b,c,d)$ 的四元组个数为 $\binom n4$。之后，如果枚举过程中 $x$ 有平方因子 $p^2$，那么所有 $x$ 的方案数就都要作废。因为在容斥过程中，所有能被 $p^2$ 整除的方案都能被 $p$ 计算到。如果没有平方因子，那么就按照奇质因子为正，偶质因子为负的方式容斥。容易发现这一因数就是 $-\mu(x)$。那么直接计算就可以了。  
注意，为了快速计算能被 $x$ 整除的数的个数，需要先枚举倍数做一遍前缀和。
# AC 代码
```cpp
#include <bits/stdc++.h> 

using namespace std;

typedef long long ll;

const int MAXN = 1e4 + 10;

int p[MAXN], mu[MAXN], tot;
bool vis[MAXN];

inline 
void init(int n) {
    mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) p[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot; j++) {
            if (i * p[j] > n) break;
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
            mu[i * p[j]] = -mu[i];
        }
    }
}

inline 
ll c4(ll n) {
    return n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4;
}

int n, maxp;

int a[MAXN], t[MAXN];

ll res;

int main() {
    init(1e4);
    while (~scanf("%d", &n)) {
        memset(t, 0, sizeof t), res = maxp = 0;
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]), t[a[i]]++, maxp = max(maxp, a[i]);
        for (int i = 2; i <= maxp; i++) {
            for (int j = i << 1; j <= maxp; j += i) t[i] += t[j];
        }
        for (int i = 2; i <= maxp; i++) res += -mu[i] * c4(t[i]);
        printf("%lld\n", c4(n) - res);
    }
}
```

---

## 作者：Leasier (赞：2)

前置芝士：[莫比乌斯反演](https://oi-wiki.org/math/mobius/)

令 $\operatorname{cnt}_i = \displaystyle\sum_{j = 1}^n [a_j = i]$，$f(x)$ 表示其 $\gcd$ 为 $x$ 的方案数，$g(x)$ 表示其 $\gcd$ 为 $x$ 的倍数的方案数，则所求为 $f(1)$。

显然 $g(x) = C_{\sum_{x\ |\ d}^m  \operatorname{cnt}_d}^4 = \displaystyle\sum_{x\ |\ d}^n f(d)$。运用倍数形式的莫比乌斯反演公式可得：$f(x) = \displaystyle\sum_{x\ |\ d}^n \mu(d) g(d)$。

将 $n = 1$ 带入可得：$f(1) = \displaystyle\sum_{i = 1}^n \mu(i) f(i)$。

线性筛出 $\mu$ 函数后直接计算即可。时间复杂度为 $O(Tm \ln m + N)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int N = 1e4 + 7;
int prime[N], mu[N], a[N], cnt[N];
bool p[N];

inline void init1(){
	int cnt = 0;
	p[0] = p[1] = true;
	mu[1] = 1;
	for (register int i = 2; i < N; i++){
		if (!p[i]){
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				mu[t] = 0;
				break;
			}
			mu[t] = -mu[i];
		}
	}
}

inline void init2(int n, int m){
	for (register int i = 1; i <= m; i++){
		cnt[i] = 0;
	}
	for (register int i = 1; i <= n; i++){
		cnt[a[i]]++;
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

inline ll comb_4(int n){
	return (ll)n * (n - 1) * (n - 2) * (n - 3) / 24;
}

int main(){
	int n;
	init1();
	while (scanf("%d", &n) != EOF){
		int m = 0;
		ll ans = 0;
		for (register int i = 1; i <= n; i++){
			scanf("%d", &a[i]);
			m = max(m, a[i]);
		}
		init2(n, m);
		for (register int i = 1; i <= m; i++){
			if (mu[i] != 0){
				int cur_ans = 0;
				for (register int j = i; j <= m; j += i) cur_ans += cnt[j];
				ans += mu[i] * comb_4(cur_ans);
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：Fairicle (赞：2)

容斥。

看到 $\text{gcd}$ 就会想到质因子。不妨设 $f_i$ 表示以 $i$ 的倍数为 $\text{gcd}$ 的组数。

总共的组数是 $C_{n}^4$，应当减去 $\sum_{i\in prime}f_i$ 如 $f_2,f_3,f_5$

但是我们发现多减去了质数两两相乘的倍数的组数，如 $f_6,f_{10},f_{15}$，再把它加上。

又会多加了三个不同质数相乘的倍数的组数，再把它减去。

最后我们发现只需要对由**不同质数相乘的数**进行统计且每个质数**只出现了一次**，而加或者减通过质数个数的奇偶性判断，奇减偶加。（有兴趣的可以去了解莫比乌斯函数

记 $num_i$ 为在 $n$ 个数中，有多少个数是 $i$ 的倍数，再处理一下由**不同质数相乘的数**的质因子个数的奇偶性，这题就做完了。

代码可以看 @laduiw 的，我是觉得他讲的不是很清楚才写这篇题解的。

---

## 作者：Tommy_clas (赞：1)

我终于见到第一个会用莫比乌斯函数的题了（反演菜鸡$QAQ$）。

这道题**比较**适合初学容斥的人做。

[传送门](https://www.luogu.org/problem/SP4191)

题目大意：给出$n$个数，求其中任意四个数互质的方案数。（$n≤1e4$）

“互质”也就要求最大公约数为$1$，即四个数没有相同的质因子，例如：如果四个数$a,b,c,d$都是$2$的倍数，那么它们一定不互质，至于为何一定是质因子，因为它是最简的约数，任何数都能用质因子的次幂之积的形式表达出来且唯一，具体的可以参考一些其它学习资料（如某进阶指南），这里便不再赘述。

总之问题就转化成了从$n$个数里抽出$4$个数，使它们没有公共的质因子。即选中$4$个数后，对于任意一个质因子，都不能整除这$4$个数的方案数。

因为最多有$10000$个$[1,10000]$范围内的数，所以涉及到的质因子可能会与$n$同级别，直接枚举复杂度爆炸。

对于这种有很多限制的题目，我们可以考虑一下容斥。

既然我们考虑的是**对于每一个质因子都不能全部整除四个数**，那我们可以反过来考虑一下**至少有某些质因子全部整除四个数**。至于为什么这样考虑，是因为这是根据[容斥原理的公式和内容](https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/10146840?fr=aladdin)类比得来的。~~其实是懒得打公式（逃。~~

因此，我们能得到如下等式：
~~~
每个质因子都不全能整除的方案数=不带限制的总方案数
			    			-至少一个质因子全能整除的方案数
                            +至少两个质因子全能整除的方案数
                            -至少三个质因子全能整除的方案数
                            ......以此类推。
~~~
这样问题又转化成了如何求至少有某些质因子全部整除四个数的方案数。先求出$n$个数中所有能被这些质因子之积整除的数的数量，因为从中取任意$4$个都能满足上述条件，所以直接计算$\binom{num}{4}$就可以了。

怎么去求数量？暴力枚举质因子的组合然后暴力统计？显然时间并不够用。

其实我们忘记了一个**时间复杂度与调和级数有关的**求一些数的同一个约数的总个数的方法。那就是枚举约数，然后再在值域内枚举它的倍数，统计它是$n$个数中多少个数的约数，用调和级数证明这么做的复杂度是$O(NlnN)$的。

然后我们只需要从所有枚举的约数里，找到需要的约数即可。（质因子分解后每个幂的指数都是$1$的数），关于容斥系数，可以暴力求质因子个数，然后奇数为正，偶数为负。

但是还记得我们开头说了什么吗？

所有数的统计答案直接乘上对应的莫比乌斯函数再求和即是正确答案！

因为对于质因子幂的指数不为$1$的数，它的莫比乌斯函数值是$0$，对于质因子个数是奇数的数，它的莫比乌斯函数值是$-1$，而对于质因子个数是偶数的数，它的莫比乌斯函数值是$1$，正好符合我们的要求！

总而言之，我们先预处理出$1$~$10000$内所有的莫比乌斯函数，然后对于每组询问先统计约数的个数，然后计算$\sum_{i=1}^{max_a}\mu_i \times \binom{cnt_i}{4}$即可，别忘了清空数组！

上代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define N 10005
#define ll long long
using namespace std;
int n,sum[N],maxn,prime[N];
ll ans;
int tag[N],mo[N],vis[N];
void init()
{
	mo[1]=1;
	for(int i=2;i<=N-5;i++)
	{
		if(!vis[i])mo[i]=-1,prime[++prime[0]]=i;
		for(int j=1;prime[j]*i<=N-5&&j<=prime[0];j++)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j])mo[i*prime[j]]=mo[i]*(-1);
			else break;
		}
	}
}
void clean()
{
	maxn=ans=0;
	memset(tag,0,sizeof(tag));
	memset(sum,0,sizeof(sum));
}
ll C(ll a,ll b)
{
	if(a<b)return 0;
	if(b==0)return 1;
	ll res=1;
	for(ll i=0;i<b;i++)res*=a-i;
	for(ll i=1;i<=b;i++)res/=i;
	return res;
}
int main()
{
	init();
	while(scanf("%d",&n)!=EOF)
	{
		clean();
		for(int i=1,x;i<=n;i++)
			scanf("%d",&x),maxn=max(maxn,x),tag[x]=1;
		for(int i=1;i<=maxn;i++)
			for(int j=i;j<=maxn;j+=i)
				if(tag[j])sum[i]++;
		for(int i=1;i<=maxn;i++)
			ans+=mo[i]*C(sum[i],4);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/SP4191)。

#### 思路

很典的数论容斥题目。

令 $g(x)$ 表示 $\gcd(a_i,a_j,a_k,a_l)|x$ 的个数，$f(x)$ 表示 $\gcd(a_i,a_j,a_k,a_l)=x$ 的个数。

很显然，有 $g(x)=\sum_{x|i}f(i)\Leftrightarrow f(x)=\sum_{x|i}g(i)\mu(\frac{i}{x})$。

将 $x=1$ 带入得 $f(1)=\sum_{i=1}^n\mu(i)f(i)$。

对于 $g(x)$，我们已知了 $a$ 中 $x$ 的个数 $p$，那么 $g(x)=\dbinom{num}{4}$。

接下来直接求 $f(1)$ 即可。

#### CoDe

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=1e5+7;
ll n,a[Maxn],f[Maxn],g[Maxn],mu[Maxn],num[Maxn],V;
int prime[Maxn],cnt;
bool isprime[Maxn];
inline void init(ll N){
	isprime[1]=isprime[0]=1;mu[1]=1;
	for(ll i=2;i<=N;i++){
		if(!isprime[i]) prime[++cnt]=i,mu[i]=-1;
		for(ll j=1;j<=cnt&&prime[j]*i<=N;j++){
			isprime[i*prime[j]]=1;
			if(!(i%prime[j])) break;
			mu[i*prime[j]]=-mu[i];
		}
	}
}
inline ll C(ll x){
	if(x<=3) return 0;
	return x*(x-1)*(x-2)*(x-3)/24;
}
int main(){
	init(Maxn-7);
	while(~scanf("%lld",&n)){
		ll ans=0;
		memset(num,0,sizeof num);
		for(ll i=1;i<=n;i++) scanf("%lld",&a[i]),num[a[i]]++,V=max(V,a[i]);
		for(ll i=V;i>=1;i--){
			for(ll j=i;j<=V;j+=i) 
				f[i]+=num[j];
			f[i]=C(f[i]);
		}
		for(ll i=1;i<=V;i++) ans+=f[i]*mu[i];
		printf("%lld\n",ans);	
		for(ll i=1;i<=V;i++) f[i]=0,num[i]=0;
	}
	return 0;
}

```

管理大大求过qwq。

---

## 作者：orz_z (赞：0)

## 题目大意

给出长为 $n$ 的序列 $a$，现在让你求出 $a$ 中有多少个四元组，满足这四个数的最大公约数等于 $1$。

对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^4,1 \leq a_i \leq 10^4$。

## 解题思路

显然是莫比乌斯反演。

我们令 $f(n)$ 表示四个数最大公因数为 $n$ 的方案数，$F(n)$ 表示四个数的 $\gcd$ 为 $n$ 的倍数的方案数。

显然 $f(x)=\sum\limits_{x|d}\mu(\frac{d}{x})F(d)$。

$F(x)$ 怎么求呢？可以先记录每个数 $i$ 出现的次数 $cnt_i$，则是 $x$ 的倍数的数有 $\sum\limits_{x|d}cnt_d$ 个，记为 $p$，那么 $F(x)=\begin{pmatrix}p\\4\end{pmatrix}$，也就是从 $p$ 个数中选 $4$ 个数的方案数。

显然，$ans=f(1)=\sum\limits_{1|d} \mu(d)F(d)$，循坏累加即可。

## CODE

```cpp
#include <bits/stdc++.h>

#define int long long
#define mem(a, b) memset(a, b, sizeof(a))

#define p_b push_back
#define m_p make_pair

const int INF = 0x3f3f3f3f, _ = 1e4;

using namespace std;

bool vis[_ + 7];

int num, prime[_ + 7], mu[_ + 7];

int n, a[_ + 7];

void init()
{
	mu[1] = 1;
	for (int i = 2; i <= _; ++i)
	{
		if (!vis[i])
			prime[++num] = i, mu[i] = -1;
		for (int j = 1; j <= num; ++j)
		{
			if (prime[j] * i > _)
				break;
			vis[prime[j] * i] = 1;
			if (i % prime[j] == 0)
			{
				mu[prime[j] * i] = 0;
				break;
			}
			mu[prime[j] * i] = -mu[i];
		}
	}
}

int calc(int n) { return n * (n - 1) * (n - 2) * (n - 3) / 24ll; }

int F[_ + 7], d[_ + 7];

signed main()
{
	init();
	while (~scanf("%d", &n))
	{
		if (n < 4)
		{
			puts("0");
			continue;
		}
		memset(d, 0, sizeof d);
		memset(F, 0, sizeof F);
		for (int i = 1; i <= n; ++i)
			scanf("%d", &a[i]), d[a[i]]++;
		int ans = 0;
		for (int i = 1; i <= _; ++i)
			for (int j = i; j <= _; j += i)
				F[i] += d[j];
		for (int i = 1; i <= _; ++i)
			if (F[i] >= 4)
				ans += calc(F[i]) * mu[i];
		printf("%lld\n", ans);
	}
	return 0;
}
```



---

## 作者：Strelitzia (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/SP4191)

---

容斥做法，感谢[AZ千文
](https://www.luogu.com.cn/user/132533)巨佬提点。

定义 $ans_i$ 为四个数的 $\gcd$ 为 $\text i$ ，注意，这里是为 $\text i$，不是 $\text i$ 的倍数。

我们对于一个数，求出它是那些数的倍数，$sum_i$ 就表示有多少个数是 $\text i$  的倍数。

那么一开始的 $ans_i = \dbinom{sum_i}{4}$ 是包含 $i \times 2,i\times3,i\times4,\ldots$ 的。

我们假象一个 $\text i$ 之后的已经处理完了，即 $ans_{i + 1}$ 为真的是 $\gcd$ 为 $\text{i+ 1}$ 的，那么，我们可以得到 $ans_i$ 如何计算。

$$
ans_i=res_i-ans_{2\times i}-ans_{3\times i}-ans_{4 \times i}-\dots
$$

最后 $ans_1$ 就是答案。


```cpp
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>T Abs(T x) {return x < 0 ? -x : x;}

const int N = 10000  + 5;

int n,cnt,mx;
long long ans[N];
int a[N],b[N];
long long g(int x) {return 1ll * x * (x - 1) * (x - 2) * (x - 3) / 24;}

int main () {
	while (~scanf("%d",&n)) {
		memset(b,0,sizeof b);
		memset(ans,0,sizeof ans);
		for (int i = 1 ; i <= n ; ++ i) read(a[i]) , mx = Max(a[i],mx);
		for (int i = 1 ; i <= n ; ++ i) {
			for (int j = 1 ; j * j <= a[i] ; ++ j) {
				if (a[i] % j == 0) {
					b[j] ++,b[a[i] / j] += a[i] / j != j;
				}
			}
		}
		for (int i = 1 ; i <= mx ; ++ i) if (b[i] >= 4) ans[i] = g(b[i]);
		for (int i = mx ; i >= 1 ; -- i) {
			for (int j = i + i ; j <= mx ; j += i) ans[i] -= ans[j];
		}
		print(ans[1]),putchar('\n');
	}
	return 0;
}
```

---


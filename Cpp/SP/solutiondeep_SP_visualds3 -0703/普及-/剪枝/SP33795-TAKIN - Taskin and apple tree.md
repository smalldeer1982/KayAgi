# 题目信息

# TAKIN - Taskin and apple tree

## 题目描述

# TAKIN - Taskin和苹果树


Taskin有一个苹果园，每天早上他都会去果园采摘苹果。他有一个篮子，可以携带**不超过 M个**苹果。Taskin将所摘的苹果放入篮子里，对于每一棵树，他要么将这棵树上的所有苹果摘完，要么跳过这棵树不摘。现在让你制定一个方案，使Taskin所摘的苹果数量最多。

## 说明/提示

T<=10,N<=20,M<=2*10^10,a[i]<=10^9

翻译提供者：right_cat

## 样例 #1

### 输入

```
2
5 6
2 1 2 7 8
5 10
1 2 4 4 6```

### 输出

```
5
10```

# AI分析结果



---

## 算法分类
暴力搜索

---

## 题解思路与核心难点分析

### 题目核心逻辑
每棵树选择全摘或不摘，在总和不超过 M 的条件下求最大苹果数。  
**关键矛盾**：M 极大（1e10）无法用常规背包 DP，但 n 很小（20），2^20 ≈ 1e6 可暴力枚举。

### 题解对比与共性
所有题解均采用以下核心逻辑：  
1. **暴力枚举**：DFS 递归遍历所有可能的子集组合  
2. **剪枝优化**：当前总和超过 M 时立即回溯  
3. **状态维护**：维护当前总和与决策树的索引  

**差异点**：  
- 递归实现（主流）：通过函数调用栈维护状态，代码更简洁  
- 位运算实现（Jerry_heng）：枚举二进制位表示选择状态，无需递归但无法剪枝提前终止  

---

## 题解评分（≥4星）

### [UnyieldingTrilobite] ⭐⭐⭐⭐⭐  
- **亮点**：极简递归设计，单行 DFS 函数；优雅的三目运算符实现剪枝与终止条件  
- **代码示例**：  
```cpp
long long dfs(...) { 
    return now<=m ? i>n ? now : max(...) : 0; 
}
```

### [zhangyuhan] ⭐⭐⭐⭐  
- **亮点**：详细注释与错误提醒（long long 与多测清空），适合新手  
- **代码示例**：  
```cpp
void dfs(...) {
    if(v>m) return;  // 剪枝
    if(cur>n) ans = max(...);  // 边界
}
```

### [Fatalis_Lights] ⭐⭐⭐⭐  
- **亮点**：封装快读提升 IO 效率，函数式编程风格  
- **代码示例**：  
```cpp
inline void dfs(int depth, int tot) { 
    if(depth>n) ans = max(...); 
}
```

---

## 最优思路与技巧提炼

### 关键思路
1. **暴力剪枝**：利用 n 的小范围，通过 DFS 枚举所有子集，遇到超限立刻回溯  
2. **状态传递**：递归时传递当前总和与决策索引，无需额外数据结构  
3. **多测处理**：每组数据前重置最大值变量  

### 代码实现要点
```cpp
// 核心递归逻辑
long long dfs(int i, long long sum) {
    if (sum > M) return 0;           // 剪枝
    if (i > n) return sum;            // 终止条件
    return max(
        dfs(i+1, sum),               // 不选当前树
        dfs(i+1, sum + a[i])         // 选当前树
    );
}
```

---

## 同类题目推荐
1. **P1036 选数**：子集和问题，相同枚举方法  
2. **P2392 kkksc03考前临时抱佛脚**：多阶段决策剪枝  
3. **P1443 马的遍历**：BFS 与状态维护（不同算法但同暴力思想）  

---

## 可视化与算法演示设计

### 动画方案
- **像素风格决策树**：  
  - 每棵树显示为像素图标，选中时高亮  
  - 当前总和以数字+进度条显示在顶部，超限时变红  
- **音效反馈**：  
  - 选中树：8-bit "点击"音效  
  - 超限：短促失败音效  
  - 更新最大值：胜利音效  

### 关键步骤演示
1. **递归展开**：用不同颜色标记当前决策的树（绿色=选中，灰色=未选）  
2. **剪枝提示**：当总和超过 M 时，子树以红色叉标记  
3. **最优解追踪**：右侧面板实时显示历史最大值  

### 复古交互功能
- **自动演示模式**：  
  - 模拟递归深度优先遍历，每步延迟可调  
  - 失败路径半透明显示，成功路径保留高亮  
- **积分系统**：  
  - 正确剪枝+10分，找到更优解+50分  
  - 总分以8-bit字体显示  

---

## 代码实现（核心递归+剪枝）
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t, n, m, a[21];

long long dfs(int i, long long sum) {
    if (sum > m) return 0;
    if (i > n) return sum;
    return max(dfs(i+1, sum), dfs(i+1, sum + a[i]));
}

int main() {
    cin >> t;
    while (t--) {
        cin >> n >> m;
        for (int i=1; i<=n; i++) cin >> a[i];
        cout << dfs(1, 0) << endl;
    }
    return 0;
}
```

---
处理用时：75.79秒
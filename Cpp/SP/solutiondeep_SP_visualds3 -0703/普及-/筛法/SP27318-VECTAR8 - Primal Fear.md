# 题目信息

# VECTAR8 - Primal Fear

## 题目描述

Changu 和 Mangu 对质数感到害怕，但他们并不是害怕所有的质数。他们只畏惧一种特殊的质数：这种质数不含数字 0，并且无论去掉多少个前导数字，剩下的部分依然是质数。举个例子，他们会害怕 4632647，因为它不包含数字 0，而且它的每一个前导截断（632647、32647、2647、647、47 和 7）都是质数。

你的任务是，对于给定的数字 $N$，找出有多少个不大于 $N$ 且被 Changu 和 Mangu 害怕的质数。

## 说明/提示

$1 \le T \le 100$

$1 \le N \le 10^6$

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3

2

3

4```

### 输出

```
1

2

2```

# AI分析结果



**唯一算法分类**  
筛法预处理 + 逆向生成（DFS）  

---

### **综合分析与结论**  
题目要求找出所有满足条件的质数（无0，所有前缀截断均为质数）。各题解主要分为两种思路：  
1. **逆向生成法**：从小质数（2,3,5,7）出发，递归地在高位添加1-9的数字，生成更大的质数，确保每一步生成的新数都是质数。这样生成的数天然满足条件。  
2. **暴力枚举法**：先用筛法生成所有质数，然后逐个检查每个质数的所有前缀截断是否为质数，并排除含0的质数。  

**核心难点与解决方案**：  
- **逆向生成法**：避免无效检查，直接生成符合条件的数。通过递归添加高位数字并利用筛法快速判断新数是否为质数，时间复杂度显著优于暴力法。  
- **暴力枚举法**：需要处理质数的截断和0的检测，复杂度较高。  

**最优思路**：逆向生成法。通过剪枝和逐步构造，避免不必要的计算，时间复杂度为 \(O(k \log \log n)\)（\(k\) 为符合条件的质数数量），显著优于暴力法的 \(O(n \log n)\)。  

---

### **题解清单 (≥4星)**  
1. **dg114514（★★★★☆）**  
   - **亮点**：逆向生成思路高效，代码简洁，利用递归和筛法预处理快速生成结果。  
   - **关键代码**：  
     ```cpp  
     void get(int x, int d=1) {  
         ans.pb(x);  
         for (int i=1; i<10; i++)  
             if (i*p10[d]+x <= N && !vis[i*p10[d]+x])  
                 get(i*p10[d]+x, d+1);  
     }  
     ```  
   - **个人心得**：通过从小质数反推构造，避免无效检查。  

2. **liuyuantao（★★★★☆）**  
   - **亮点**：DFS生成剪枝，避免无效路径，代码清晰。  
   - **关键代码**：  
     ```cpp  
     void dfs(LL x, LL y) {  
         if (x == 7) return;  
         for (int i=1; i<=9; i++) {  
             y += i * pw10[x-1];  
             if (!noPrime[y]) {  
                 iz[y] = 1;  
                 dfs(x+1, y);  
             }  
             y -= i * pw10[x-1];  
         }  
     }  
     ```  
   - **个人心得**：递归生成时剪枝，确保每一步构造的数为质数。  

---

### **最优思路提炼**  
1. **逆向生成剪枝**：从个位质数开始，每次在高位添加数字，若新数为质数则继续递归，否则停止。  
2. **预处理优化**：预先计算10的幂次（如`p10[]`），快速生成新数。  
3. **避免0的存在**：生成时仅添加1-9，无需额外判断。  

---

### **同类型题推荐**  
1. [SPOJ - TDPRIMES](https://www.spoj.com/problems/TDPRIMES/)（质数生成与剪枝）  
2. [LeetCode 248 - Strobogrammatic Number III](https://leetcode.com/problems/strobogrammatic-number-iii)（递归构造特定格式数）  
3. [洛谷 P1218 - 质数生成路径](https://www.luogu.com.cn/problem/P1218)  

---

### **可视化与算法演示**  
**动画设计**：  
1. **像素风格界面**：用8位像素网格展示数的生成过程，初始质数（2,3,5,7）显示为绿色方块。  
2. **递归步骤高亮**：每次递归添加高位数字时，新数字以黄色闪烁，若生成质数则变为绿色，否则变红并停止。  
3. **音效提示**：  
   - 添加数字时播放“哔”声，成功生成质数时播放上升音调，失败时播放下降音调。  
4. **控制面板**：支持暂停、单步执行，速度调节观察递归生成路径。  

**代码片段（伪代码）**：  
```javascript  
function generatePrimalFear(num, depth) {  
    if (depth > 6) return;  
    for (let i = 1; i <= 9; i++) {  
        let newNum = i * Math.pow(10, depth) + num;  
        if (isPrime(newNum)) {  
            drawPixel(newNum, 'green');  
            generatePrimalFear(newNum, depth + 1);  
        } else {  
            drawPixel(newNum, 'red');  
        }  
    }  
}  
```  

---

**总结**：逆向生成法通过剪枝和预判，高效生成符合条件的质数，是本题的最优解法。可视化设计可结合递归过程和像素风格，直观展示算法核心逻辑。

---
处理用时：113.57秒
# 题目信息

# VECTAR8 - Primal Fear

## 题目描述

Changu 和 Mangu 对质数感到害怕，但他们并不是害怕所有的质数。他们只畏惧一种特殊的质数：这种质数不含数字 0，并且无论去掉多少个前导数字，剩下的部分依然是质数。举个例子，他们会害怕 4632647，因为它不包含数字 0，而且它的每一个前导截断（632647、32647、2647、647、47 和 7）都是质数。

你的任务是，对于给定的数字 $N$，找出有多少个不大于 $N$ 且被 Changu 和 Mangu 害怕的质数。

## 说明/提示

$1 \le T \le 100$

$1 \le N \le 10^6$

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3

2

3

4```

### 输出

```
1

2

2```

# AI分析结果



## 算法分类
**筛法生成法**

---

## 题解思路与核心难点

### 思路对比
1. **生成法**（dg114514、liuyuantao题解）  
   - 从个位质数（2/3/5/7）出发，递归构造更高位质数  
   - 每次在左侧添加非零数字，确保截断后的所有前缀均为质数  
   - 预处理后通过二分快速响应查询  
   - **优势**：时间复杂度低，直接构造合法数，避免冗余检查  

2. **暴力法**（Aurelia_Veil等题解）  
   - 先筛出所有质数，再逐一检查每个质数的所有截断情况  
   - 通过逐位截断或数学运算生成前缀并验证  
   - **劣势**：需多次检查每个质数的所有前缀，效率较低  

### 解决难点
- **构造合法性**：确保每个生成的数所有前缀均为质数  
- **高效筛选**：通过筛法预处理质数表，避免重复计算  
- **数字截断**：正确生成所有可能的前缀并验证  

---

## 题解评分（≥4星）

1. **dg114514的生成法（5星）**  
   - **亮点**：代码简洁，递归生成逻辑清晰，利用筛法优化预处理  
   - **核心代码**：  
     ```cpp
     void get(int x, int d=1) {
         ans.pb(x);
         for(int i=1; i<10; i++)
             if(i*p10[d]+x <=N && !vis[i*p10[d]+x])
                 get(i*p10[d]+x, d+1);
     }
     ```

2. **liuyuantao的DFS生成法（4星）**  
   - **亮点**：结合深度优先搜索，显式处理位数限制  
   - **核心代码**：  
     ```cpp
     void dfs(LL x, LL y) {
         if(x==7) return;
         for(int i=1; i<=9; i++) {
             y += i*pw10[x-1];
             if(!noPrime[y]) {
                 iz[y] = 1;
                 dfs(x+1, y);
             }
             y -= i*pw10[x-1];
         }
     }
     ```

---

## 最优思路提炼

### 关键技巧
1. **质数生成方向**：从低位向高位构造，确保每个中间状态合法  
2. **剪枝优化**：仅在前缀合法时继续生成，避免无效分支  
3. **预处理+二分查询**：提前生成所有可能解，实现O(1)查询  

### 同类型题
- [USACO1.5]特殊的质数肋骨（构造前缀合法质数）  
- 左右截断质数问题（如LeetCode 739）  
- 筛法模板题（如P3383）  

---

## 可视化算法设计

### 动画方案
1. **筛法过程**  
   - **像素风格**：用网格表示数字，质数标记为绿色，合数红色  
   - **动态效果**：埃拉托斯特尼筛法的筛除过程可视化  

2. **递归生成**  
   - **树形展开**：根节点为2/3/5/7，子节点为添加数字后的新质数  
   - **颜色编码**：不同位数用不同颜色层级展示  
   - **音效反馈**：成功生成时播放上升音调，失败短促音效  

3. **交互控制**  
   - **速度调节**：滑块控制递归生成速度  
   - **单步调试**：按空格键逐层展开生成树  

### 复古风格实现
- **Canvas绘制**：8位像素字体，16色调色板  
- **音效设计**：  
  - `beep.wav`（成功生成）  
  - `error.wav`（遇到合数）  
  - `bgm.ogg`（8位循环背景音乐）  

---

## 推荐题目
1. **P1218** [USACO1.5]特殊的质数肋骨  
2. **P1032** [NOIP2002]字串变换（状态扩展思维）  
3. **P3383** 【模板】线性筛素数（基础筛法练习）  

---

## 代码片段
### dg114514生成法（完整）
```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;
const int N=1e6;
bitset<N+5>vis;
int p10[]={1,10,100,1000,10000,100000,1000000,10000000};
vector<int>ans;
void get(int x,int d=1){
    ans.pb(x);
    for(int i=1;i<10;i++)
        if(i*p10[d]+x<=N&&!vis[i*p10[d]+x])
            get(i*p10[d]+x,d+1);
}
signed main() {
    vis[1]=1;
    for(int i=2;i<=N;i++)
        if(!vis[i])
            for(int j=i*i;j<=N;j+=i)
                vis[j]=1;
    get(2),get(3),get(5),get(7);
    sort(ans.begin(),ans.end());
    int T,x;
    cin>>T;
    while(T--)
        cin>>x,cout<<upper_bound(ans.begin(),ans.end(),x)-ans.begin()<<"\n";
    return 0;
}
```

---
处理用时：224.98秒
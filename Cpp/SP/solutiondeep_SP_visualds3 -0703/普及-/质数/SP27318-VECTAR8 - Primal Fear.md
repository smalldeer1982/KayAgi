# 题目信息

# VECTAR8 - Primal Fear

## 题目描述

Changu 和 Mangu 对质数感到害怕，但他们并不是害怕所有的质数。他们只畏惧一种特殊的质数：这种质数不含数字 0，并且无论去掉多少个前导数字，剩下的部分依然是质数。举个例子，他们会害怕 4632647，因为它不包含数字 0，而且它的每一个前导截断（632647、32647、2647、647、47 和 7）都是质数。

你的任务是，对于给定的数字 $N$，找出有多少个不大于 $N$ 且被 Changu 和 Mangu 害怕的质数。

## 说明/提示

$1 \le T \le 100$

$1 \le N \le 10^6$

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3

2

3

4```

### 输出

```
1

2

2```

# AI分析结果



---

**唯一算法分类**：质数筛与生成法

---

### **题解思路与算法要点**

**核心思路**：  
题目要求找出所有满足以下条件的质数：  
1. 不含数字 0；  
2. 每次去掉前导数字后剩下的数仍是质数。  

**关键难点**：  
1. 如何高效判断所有可能的截断情况？  
2. 如何快速预处理满足条件的质数以应对多组查询？

**解决方案对比**：  
1. **生成法（反向构造）**：  
   - **核心思想**：从个位质数（2、3、5、7）出发，递归地在左侧添加数字（1-9），生成更大的质数。确保每一步生成的数均为质数，从而保证所有截断后的数自动满足条件。  
   - **优势**：避免对每个质数的多次截断检查，时间复杂度更优（仅处理符合条件的质数）。  
   - **实现**：预先生成所有符合条件的质数，排序后用二分查找回答查询。  

2. **暴力法（正向筛选）**：  
   - **核心思想**：先筛出所有质数，再逐个检查每个质数的所有截断是否均为质数且不含0。  
   - **劣势**：需对每个质数进行多次截断检查，时间复杂度较高（质数数量多时效率低）。  

---

### **题解评分 (≥4星)**

1. **作者：dg114514（5星）**  
   - **亮点**：  
     - 使用生成法，仅处理可能的候选质数，显著减少计算量。  
     - 代码简洁，结合筛法和递归生成，预处理后通过二分快速回答查询。  
   - **代码片段**：  
     ```cpp
     void get(int x, int d=1) {
         ans.pb(x);
         for (int i=1; i<10; i++) {
             int new_num = i * p10[d] + x;
             if (new_num <= N && !vis[new_num])
                 get(new_num, d+1);
         }
     }
     ```

2. **作者：Make_China_Great（4星）**  
   - **亮点**：  
     - 暴力法仅处理质数，避免无效检查。  
     - 通过截断取模实现前导数字去除。  
   - **代码片段**：  
     ```cpp
     for (int i : primes) {
         int l = i, r = 1;
         bool valid = true;
         while (l >= r) {
             r *= 10;
             if (is_composite[l % r] || has_zero(l, r)) {
                 valid = false;
                 break;
             }
         }
         if (valid) mark[i] = 1;
     }
     ```

3. **作者：dmc0702（4星）**  
   - **亮点**：  
     - 类似暴力法，但通过前缀和优化预处理结果。  
     - 代码结构清晰，适合理解暴力法的基本思路。  

---

### **最优思路提炼**

- **生成法**：  
  1. **筛法预处理质数表**：快速判断任意数是否为质数。  
  2. **递归构造质数**：从个位质数出发，逐步在左侧添加数字生成新质数。  
  3. **预处理与二分查询**：生成所有可能质数后排序，查询时直接二分结果。  

- **关键技巧**：  
  - 递归时限制生成数的范围（不超过 `N`），避免无效计算。  
  - 利用筛法的 `vis` 数组快速验证生成数是否为质数。  

---

### **类似题目与算法套路**

- **同类型题目**：  
  - **双面质数**：要求左截断和右截断均为质数。  
  - **回文质数**：质数本身是回文数。  

- **通用解法**：  
  - **质数生成法**：通过已知质数构造新质数，避免全量检查。  
  - **预处理与二分**：多查询场景下的经典优化手段。  

---

### **推荐题目**

1. **P1217** [USACO1.5] 回文质数  
2. **P1304** 哥德巴赫猜想  
3. **P3383** 线性筛素数  

---

### **个人心得摘录**

- **调试教训**：生成法必须确保每一步生成的数均为质数，否则截断后的数可能不合法。  
- **优化经验**：预处理时筛法的选择（埃氏筛 vs 欧拉筛）显著影响效率。  

---

### **可视化与算法演示**

- **动画设计**：  
  1. **生成法递归树**：以树状图展示从个位质数逐步生成新质数的过程，高亮每一步添加的数字和新生成的质数。  
  2. **暴力法截断检查**：动态显示质数的截断过程，红色标记检查失败的截断数。  

- **交互功能**：  
  - **步进控制**：单步执行生成或截断检查，观察中间结果。  
  - **对比模式**：并行展示生成法和暴力法的执行步骤，突出效率差异。  

- **像素风格**：  
  - **8位像素UI**：质数以像素方块表示，绿色为合法质数，红色为截断失败。  
  - **音效提示**：生成新质数时播放上升音调，截断失败时播放低沉音效。  

---

**代码片段（生成法核心逻辑）**：  
```cpp
// 筛法预处理质数
bitset<N+5> vis;
vector<int> ans;

void get(int x, int d) {
    ans.push_back(x);
    for (int i=1; i<=9; i++) {
        int new_num = i * pow(10, d) + x;
        if (new_num <= N && !vis[new_num])
            get(new_num, d+1);
    }
}

// 预处理生成所有可能质数
get(2, 1); get(3, 1); get(5, 1); get(7, 1);
sort(ans.begin(), ans.end());
```

---

**结论**：生成法以高效构造为核心，暴力法以直观易理解为优势，两者结合筛法和预处理技巧，是解决此类质数筛选问题的典型思路。

---
处理用时：358.22秒
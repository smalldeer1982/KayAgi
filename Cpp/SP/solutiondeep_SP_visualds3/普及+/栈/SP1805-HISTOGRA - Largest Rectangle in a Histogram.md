# 题目信息

# HISTOGRA - Largest Rectangle in a Histogram

## 题目描述

![](https://cdn.luogu.com.cn/upload/vjudge_pic/SP1805/b9567e3483620f1fe679470ac44083eae9842e79.png)

如图所示，在一条水平线上有  $n$ 个宽为  $1$ 的矩形，求包含于这些矩形的最大子矩形面积（图中的阴影部分的面积即所求答案）。

## 样例 #1

### 输入

```
7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
0```

### 输出

```
8
4000```

# AI分析结果



---
# 💡 Kay的C++算法解析：Largest Rectangle in a Histogram 深入学习指南 💡

<introduction>
今天我们来一起分析“Largest Rectangle in a Histogram”这道经典的C++编程题。本指南将帮助大家梳理题目思路，理解核心算法（单调栈），并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`单调栈的应用（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键在于理解并运用“单调栈”这一数据结构技巧。简单来说，单调栈是一种特殊的栈结构，栈内元素保持单调递增或递减。它的核心思想是“及时排除不可能的选项，保持策略集合的高度有效性和秩序性”（引用自题解中的经典总结）。在本题中，单调栈用于高效计算每个矩形高度能向左右扩展的最大宽度，从而找到最大面积的矩形。

- **题解思路**：所有优质题解均围绕单调栈展开。基本思路是：维护一个单调递增的栈，栈中存储矩形的高度和宽度。遍历每个矩形时，若当前矩形高度小于栈顶高度，则弹出栈顶元素并计算其能形成的最大矩形面积（高度×累计宽度），直到栈顶高度小于当前高度。最后将当前矩形入栈（合并弹出的宽度）。通过这种方式，每个元素仅入栈和出栈一次，时间复杂度为O(n)。
- **核心难点**：如何正确维护栈的单调性、计算每个高度的扩展宽度、处理边界条件（如添加哨兵元素h[n+1]=0以确保所有元素被处理）。
- **可视化设计**：计划采用8位像素风格动画，用不同颜色的像素块表示栈中的矩形，通过闪烁、移动动画展示入栈、出栈过程，同步高亮当前处理的矩形和累计宽度，配合“叮”声提示关键操作（如弹出、计算面积）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者冒泡ioa**
* **点评**：此题解思路清晰，直接点明单调栈的核心思想（“及时排除不可能的选项”），代码简洁规范（如变量名s存栈高度、w存宽度，含义明确）。特别亮点是通过添加哨兵元素h[n+1]=0确保所有元素被处理，避免遗漏。代码实践价值高，可直接用于竞赛。

**题解二：作者___new2zy___**
* **点评**：此题解详细解释了单调栈的操作步骤（如入栈、合并宽度），并通过结构体rect（h,w）明确存储高度和宽度，逻辑直观。代码注释丰富，适合初学者理解。其分治思想的补充说明（如“每个元素出栈时更新最大面积”）对理解算法正确性有重要帮助。

**题解三：作者蓬萊山輝夜**
* **点评**：此题解从单调栈的定义和性质出发，逐步推导到本题应用，理论结合实践。代码中使用数组模拟栈（s和w数组），效率高且易于调试。特别提到“时间复杂度O(n)因每个元素仅入栈、出栈一次”，帮助学习者理解算法优化点。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何维护单调栈的单调性？**
    * **分析**：遍历每个矩形时，若当前矩形高度小于栈顶高度，需不断弹出栈顶元素，直到栈顶高度小于当前高度。弹出的元素无法再向右扩展（因当前矩形更矮），此时计算其面积并合并宽度。例如，栈顶元素高度为h，累计宽度为w，则面积为h*w。
    * 💡 **学习笔记**：单调栈的维护是“以空间换时间”的典型，通过保持栈内单调递增，确保每个元素仅处理一次。

2.  **关键点2：如何计算每个高度的扩展宽度？**
    * **分析**：弹出栈顶元素时，累计宽度（即该高度能向左扩展的宽度）等于弹出元素的宽度之和。例如，弹出元素宽度为w1、w2，则累计宽度为w1+w2，新入栈的矩形宽度为累计宽度+1（自身宽度）。
    * 💡 **学习笔记**：宽度的累计是动态的，每次弹出操作都会将前一个高度的宽度合并到当前处理中，确保后续计算的准确性。

3.  **关键点3：如何处理边界条件？**
    * **分析**：添加哨兵元素h[n+1]=0（或h[0]=-1），确保遍历结束后栈中所有元素被弹出并计算面积。例如，样例输入中的最后一个0，强制所有剩余元素出栈，避免遗漏最大面积。
    * 💡 **学习笔记**：哨兵元素是处理边界问题的常用技巧，能简化代码逻辑，避免复杂的条件判断。

### ✨ 解题技巧总结
- **技巧1：哨兵元素的使用**：在数组首尾添加极小值（如h[n+1]=0），确保所有元素被处理。
- **技巧2：宽度的动态累计**：弹出栈顶元素时，累计宽度用于计算当前高度的扩展范围，合并后入栈的宽度为累计宽度+1。
- **技巧3：双数组模拟栈**：用两个数组分别存储高度（s）和宽度（w），比结构体更高效，适合竞赛场景。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路（如冒泡ioa、___new2zy___的实现），采用数组模拟栈，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    const int MAXN = 100010;
    long long h[MAXN];  // 存储每个矩形的高度
    long long s[MAXN];  // 单调栈，存储高度
    long long w[MAXN];  // 存储对应高度的宽度
    int top;            // 栈顶指针

    int main() {
        int n;
        while (cin >> n && n) {
            top = 0;
            long long ans = 0;
            for (int i = 1; i <= n; ++i) cin >> h[i];
            h[n + 1] = 0;  // 哨兵元素，确保所有元素被处理

            for (int i = 1; i <= n + 1; ++i) {
                if (h[i] > s[top]) {  // 当前高度大于栈顶，入栈
                    s[++top] = h[i];
                    w[top] = 1;
                } else {  // 当前高度小于等于栈顶，弹出并计算面积
                    long long width = 0;
                    while (s[top] > h[i]) {
                        width += w[top];
                        ans = max(ans, s[top] * width);  // 更新最大面积
                        top--;
                    }
                    s[++top] = h[i];
                    w[top] = width + 1;  // 合并宽度（当前宽度=累计宽度+1）
                }
            }
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：该代码首先读取输入，添加哨兵元素h[n+1]=0。遍历每个矩形时，维护单调递增的栈（s存高度，w存宽度）。若当前高度小于栈顶，则弹出栈顶元素并计算面积（高度×累计宽度），直到栈顶高度小于当前高度。最后将当前高度和合并后的宽度入栈。遍历结束后，输出最大面积。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段，并点出各自的亮点。
</code_intro_selected>

**题解一：作者冒泡ioa**
* **亮点**：代码简洁，变量命名直观（s存栈高度，w存宽度），通过哨兵元素h[n+1]=0确保所有元素被处理。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n+1;i++) {
        if(a[i]>s[p]) s[++p]=a[i],w[p]=1;
        else {
            int width=0;
            while(s[p]>a[i]) {
                width+=w[p];
                ans=max(ans,(long long)width*s[p]);
                p--;
            }
            s[++p]=a[i],w[p]=width+1;
        }
    }
    ```
* **代码解读**：这段代码是单调栈的核心逻辑。当当前高度a[i]小于栈顶s[p]时，弹出栈顶元素并累计宽度（width），计算面积（s[p]×width），直到栈顶高度小于a[i]。最后将a[i]和合并后的宽度（width+1）入栈。
* 💡 **学习笔记**：通过“width+=w[p]”动态累计宽度，确保每个弹出的元素的宽度被正确合并到当前处理中。

**题解二：作者___new2zy___**
* **亮点**：使用结构体rect（h,w）明确存储高度和宽度，逻辑清晰，适合理解。
* **核心代码片段**：
    ```cpp
    struct rect { ll h, w; };
    rect S[100050] = {(rect){0, 0}};
    int top = 0;
    for(int i=1; i<=n+1; i++) {
        if(H[i] > S[top].h) 
            S[++top] = (rect){H[i], 1};
        else {
            ll width = 0;
            while(S[top].h > H[i]) {
                width += S[top].w;
                ans = max(ans, 1ll * width * S[top].h);
                top--;
            }
            S[++top] = (rect){H[i], width + 1};
        }
    }
    ```
* **代码解读**：结构体rect存储每个栈元素的高度（h）和宽度（w）。遍历每个矩形时，若当前高度H[i]小于栈顶高度，弹出栈顶元素并累计宽度，计算面积后将当前高度和合并后的宽度入栈。
* 💡 **学习笔记**：结构体的使用让代码逻辑更直观，适合初学者理解栈中元素的含义。

**题解三：作者蓬萊山輝夜**
* **亮点**：代码规范，注释清晰，强调“所有元素仅入栈、出栈一次，时间复杂度O(n)”。
* **核心代码片段**：
    ```cpp
    for(int i=1; i<=n+1; i++) {
        if(a[i] > s[p]) {
            s[++p] = a[i];
            w[p] = 1;
        } else {
            int len = 0;
            while(s[p] > a[i]) {
                len += w[p];
                ans = max(ans, (long long)len * s[p]);
                p--;
            }
            s[++p] = a[i], w[p] = len + 1;
        }
    }
    ```
* **代码解读**：与冒泡ioa的代码类似，但变量名“len”更直观表示累计的宽度。通过“len += w[p]”计算弹出元素的总宽度，确保当前入栈元素的宽度正确。
* 💡 **学习笔记**：变量命名的直观性（如len代替width）能提升代码可读性，是值得学习的编程习惯。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解单调栈的工作流程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到栈的入栈、出栈过程和面积计算。
</visualization_intro>

  * **动画演示主题**：`像素直方图探险——单调栈的秘密`

  * **核心演示内容**：展示单调栈如何处理每个矩形的入栈、出栈，以及如何计算最大面积。例如，当处理一个较矮的矩形时，弹出栈顶较高的矩形，累计宽度并计算面积，最后将合并后的矩形入栈。

  * **设计思路简述**：采用FC红白机风格的像素画面（8-16色调色板），用不同颜色的像素块表示栈中的矩形（如蓝色表示栈内元素，红色表示当前处理元素）。关键操作（如弹出、计算面积）伴随“叮”声，增强记忆点。通过“小关卡”设计（如每处理一个矩形算一关），增加学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示直方图（每个矩形为1×h的像素块，颜色为绿色），右侧显示单调栈（垂直堆叠的像素块，颜色为蓝色）。
          * 控制面板包含“开始/暂停”“单步执行”“重置”按钮和速度滑块（调节动画速度）。
          * 播放8位风格背景音乐（如《超级马里奥》的简单变奏）。

    2.  **遍历矩形**：
          * 当前处理的矩形（i）用红色边框高亮，伴随“滴”声提示。
          * 若当前矩形高度大于栈顶（蓝色块），则新矩形（蓝色）滑入栈顶，宽度显示为1（白色数字）。

    3.  **弹出栈顶并计算面积**：
          * 若当前矩形高度小于栈顶，栈顶蓝色块开始闪烁（黄色边框），弹出时向上移动并消失，同时累计宽度（白色数字在栈右侧累加）。
          * 计算面积时，弹出块的高度×累计宽度显示在屏幕上方（如“5×3=15”），伴随“叮”声，最大值用红色高亮。

    4.  **合并宽度并重新入栈**：
          * 弹出所有更高的块后，当前矩形（蓝色）滑入栈顶，宽度显示为累计宽度+1（如“3+1=4”）。

    5.  **处理哨兵元素**：
          * 遍历到h[n+1]=0（黑色块）时，栈中所有元素依次弹出，计算面积，最终最大面积显示为金色。

  * **旁白提示**：
      * （弹出栈顶时）“当前矩形更矮，栈顶的高矩形无法向右扩展，弹出并计算面积！”
      * （合并宽度时）“累计宽度为3，当前矩形宽度为3+1=4，入栈！”
      * （完成遍历后）“所有元素处理完毕，最大面积是8！”

<visualization_conclusion>
通过这样的动画，我们能清晰看到单调栈的每一步操作，理解宽度的累计和面积的计算逻辑，比单纯看代码更直观！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的单调栈解法后，我们可以进一步思考其适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 单调栈不仅能解决直方图最大矩形问题，还常用于：
        1. **寻找每个元素左边/右边第一个更小/更大的元素**（如洛谷P5788 单调栈模板题）。
        2. **计算柱状图中最大矩形的变形**（如二维矩阵中的最大矩形，需逐行转化为直方图）。
        3. **股票价格中的“最大跨度”问题**（如寻找连续天数中价格不下降的最长区间）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5788** - `【模板】单调栈`
          * 🗣️ **推荐理由**：直接考察单调栈的基本操作，适合巩固本题的核心技巧。
    2.  **洛谷 P1901** - `发射站`
          * 🗣️ **推荐理由**：需要找到每个元素左右第一个更大的元素，是单调栈的典型应用。
    3.  **洛谷 P2422** - `良好的感觉`
          * 🗣️ **推荐理由**：与本题类似，求子区间最小值与长度的乘积最大值，可通过单调栈高效解决。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和思考过程，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者冒泡ioa)**：“最初在处理边界条件时，忘记添加h[n+1]=0，导致最后几个矩形未被处理，结果错误。后来通过添加哨兵元素解决了问题。”
>
> **点评**：这位作者的经验提醒我们，边界条件的处理是编程中容易出错的地方。添加哨兵元素是解决此类问题的有效技巧，能简化逻辑并避免遗漏。

-----

<conclusion>
本次关于“Largest Rectangle in a Histogram”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握单调栈的核心技巧，并通过动画和练习加深理解。记住，多动手写代码、调试，才能真正掌握算法！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：127.18秒
# 题目信息

# LCS - Longest Common Substring

## 题目描述

A string is finite sequence of characters over a non-empty finite set Σ.

In this problem, Σ is the set of lowercase letters.

Substring, also called factor, is a consecutive sequence of characters occurrences at least once in a string.

Now your task is simple, for two given strings, find the length of the longest common substring of them.

Here common substring means a substring of two or more strings.

## 样例 #1

### 输入

```
alsdfkjfjkdsal
fdjskalajfkdsla```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：LCS - Longest Common Substring 深入学习指南 💡

<introduction>
今天我们来一起分析“LCS - Longest Common Substring”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法（后缀自动机SAM的应用），并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串处理（后缀自动机SAM应用）

🗣️ **初步分析**：
解决“最长公共子串”问题的关键在于高效处理两个字符串的连续公共子串。后缀自动机（SAM）是一种专为子串问题设计的高效数据结构，它能在线性时间内构建，且支持快速匹配。简单来说，SAM可以理解为一个“压缩的字典树”，每个节点代表一组子串（这些子串互为后缀），通过转移边连接，后缀链接（parent树）则用于处理后缀关系。

在本题中，SAM的主要应用流程是：  
1. 对第一个字符串构建SAM，将其所有子串信息压缩存储；  
2. 用第二个字符串在SAM上“逐字符匹配”，记录最长匹配长度。若当前字符有转移则继续，无转移则沿后缀链接回溯（类似KMP的失败指针），直到找到可转移的节点或回到根节点。  

核心难点在于：  
- SAM的正确构建（包括节点分裂、后缀链接维护）；  
- 匹配过程中如何处理失配（沿后缀链接跳转时长度的更新逻辑）。  

可视化设计思路：  
采用8位像素风格动画，用彩色方块表示SAM节点（根节点为蓝色，普通节点为绿色，分裂节点为黄色），边用箭头表示转移。匹配时，当前节点闪烁（红色边框），长度用数字显示在节点上方。失配时，沿后缀链接（虚线箭头）跳转，每跳一步播放“滴答”音效；找到转移时，播放“叮”音效并延长长度。动画支持单步/自动播放，同步显示当前匹配的代码行，帮助直观理解节点转移和长度更新。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码规范性、算法有效性等方面筛选了以下4星以上的优质题解：
</eval_intro>

**题解一：作者bztMinamoto（赞：15）**  
* **点评**：此题解思路清晰，直接采用SAM构建+匹配的经典方法。代码结构规范（如`SuffixAutoMaton`类封装SAM操作），变量名`ch`（转移表）、`fa`（后缀链接）、`l`（节点最大长度）含义明确。匹配过程的`calc`函数逻辑直白（分三种情况处理转移），边界条件（如跳转到根节点时重置长度）处理严谨。代码可直接用于竞赛，是SAM应用的典型模板。

**题解二：作者chihik（赞：3）**  
* **点评**：此题解对SAM的核心操作（`Extend`函数）和匹配逻辑（`Calc`函数）解释简洁，代码注释清晰。特别是`Maxlen`数组的命名（表示节点能代表的最长子串长度）增强了可读性。匹配时通过`tot`变量实时更新当前匹配长度，最终取最大值，逻辑直观，适合初学者理解SAM的匹配流程。

**题解三：作者温词（赞：1）**  
* **点评**：此题解用`map`实现转移表（`node[p].ch[now]`），适合字符集较大的场景（虽本题是小写字母，但扩展性强）。代码中`extend`函数的注释详细（如“建SAM的过程是常规操作”），匹配时对失配处理的逻辑（`while(p&&!node[p].ch[now])`）解释到位，尤其强调“`len=node[p].len+1`”的原因（当前节点的最长子串长度加1），对理解SAM匹配的核心逻辑有帮助。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决最长公共子串问题时，我们通常会遇到以下核心难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何正确构建SAM？  
    * **分析**：SAM的构建涉及节点分裂（`clone`节点）和后缀链接的维护。例如，当插入新字符时，若当前节点`p`的转移已存在且长度不满足（`len[q] != len[p]+1`），需创建`clone`节点复制`q`的转移，并调整后缀链接。这一步是SAM的核心，确保每个节点代表的子串集合正确。  
    * 💡 **学习笔记**：SAM的构建需要严格维护`len`（节点最长子串长度）和`fa`（后缀链接），分裂节点是保证线性复杂度的关键。

2.  **关键点2**：如何在SAM上高效匹配第二个字符串？  
    * **分析**：匹配时，若当前字符有转移则直接跳转（长度+1）；若无转移，需沿后缀链接回溯，直到找到可转移的节点（此时长度为该节点的`len+1`）。若回溯到根节点仍无转移，则重置长度为0。这一步的关键是理解后缀链接的含义（当前节点的最长后缀对应的节点），确保能快速找到可能的匹配位置。  
    * 💡 **学习笔记**：匹配过程的核心是利用后缀链接“回溯”到可能的匹配位置，避免从头开始，从而保证线性时间复杂度。

3.  **关键点3**：如何处理匹配过程中的长度更新？  
    * **分析**：当沿后缀链接找到可转移的节点`p`时，当前匹配长度应为`p.len + 1`（因为`p`的最长子串长度为`p.len`，添加当前字符后长度加1）。若直接使用`p`的转移节点的`len`，可能会错误地取到更长的子串（该子串可能不包含当前字符）。  
    * 💡 **学习笔记**：匹配长度的更新需基于当前节点的`len`，而非转移后节点的`len`，确保长度是“当前匹配的连续子串”的长度。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将最长公共子串问题转化为“在SAM上匹配第二个字符串”，利用SAM高效存储子串的特性。  
- **模块化设计**：将SAM的构建（`build`）和匹配（`calc`）封装为函数/类，提高代码可读性和复用性。  
- **边界测试**：测试空字符串、完全相同/不相同的字符串等边界情况，确保代码鲁棒性。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心C++实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合bztMinamoto和chihik的题解，采用SAM构建+匹配的经典方法，代码结构清晰，适合竞赛使用。  
* **完整核心代码**：  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 2e6 + 10; // 两倍字符串长度（SAM节点数）

struct SuffixAutoMaton {
    int len[N], fa[N]; // len: 节点最长子串长度；fa: 后缀链接
    int ch[N][26];     // 转移表
    int last, cnt;     // 最后一个节点，总节点数

    SuffixAutoMaton() { cnt = last = 1; } // 根节点为1

    void extend(int c) {
        int p = last, np = ++cnt;
        len[np] = len[p] + 1;
        while (p && !ch[p][c]) ch[p][c] = np, p = fa[p];
        if (!p) fa[np] = 1;
        else {
            int q = ch[p][c];
            if (len[q] == len[p] + 1) fa[np] = q;
            else {
                int nq = ++cnt;
                len[nq] = len[p] + 1;
                memcpy(ch[nq], ch[q], sizeof(ch[q]));
                fa[nq] = fa[q];
                fa[q] = fa[np] = nq;
                while (p && ch[p][c] == q) ch[p][c] = nq, p = fa[p];
            }
        }
        last = np;
    }

    int calc(char *t) {
        int p = 1, len = 0, ans = 0;
        for (int i = 0; t[i]; i++) {
            int c = t[i] - 'a';
            while (p != 1 && !ch[p][c]) p = fa[p], len = len[p];
            if (ch[p][c]) p = ch[p][c], len++;
            else len = 0; // 回到根节点仍无转移，重置长度
            ans = max(ans, len);
        }
        return ans;
    }
} sam;

char s[N], t[N];

int main() {
    scanf("%s%s", s, t);
    for (int i = 0; s[i]; i++) sam.extend(s[i] - 'a');
    printf("%d\n", sam.calc(t));
    return 0;
}
```
* **代码解读概要**：  
  代码通过`SuffixAutoMaton`类封装SAM操作。`extend`函数构建SAM（处理节点分裂和后缀链接），`calc`函数用第二个字符串匹配，记录最长长度。主函数读取输入后，先构建第一个字符串的SAM，再调用`calc`计算结果。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：作者bztMinamoto**  
* **亮点**：代码结构规范，`SuffixAutoMaton`类清晰封装SAM操作，匹配逻辑分情况处理（有转移/无转移），边界条件（跳转到根节点）处理严谨。  
* **核心代码片段**：  
```cpp
void calc(int n) {
    int p = 1;
    for (int i = 1; i <= n; i++) {
        int c = t[i] - 'a';
        if (ch[p][c]) len++, p = ch[p][c];
        else {
            for (; p && !ch[p][c]; p = fa[p]);
            if (p) len = l[p] + 1, p = ch[p][c];
            else len = 0, p = 1;
        }
        ans = max(ans, len);
    }
}
```
* **代码解读**：  
  `calc`函数逐字符处理第二个字符串。若当前节点`p`有字符`c`的转移（`ch[p][c]`存在），则长度`len`加1并跳转；若无转移，沿后缀链接`fa[p]`回溯，直到找到有转移的节点（此时长度为该节点的`l[p]+1`）或回到根节点（重置长度为0）。每次更新最大长度`ans`。  
* 💡 **学习笔记**：匹配时的长度更新需结合当前节点的`l[p]`（最长子串长度），确保长度是连续匹配的结果。

**题解二：作者温词**  
* **亮点**：用`map`实现转移表（`node[p].ch[now]`），适合字符集较大的场景，代码注释详细（如解释`len=node[p].len+1`的原因）。  
* **核心代码片段**：  
```cpp
for (i=1; i<=l2; i++) {
    int now = t[i]-'a'+1;
    if (node[p].ch[now]) {
        p = node[p].ch[now]; len++;
    } else {
        while (p && !node[p].ch[now]) p = node[p].fa;
        if (!p) { p=1; len=0; }
        else { len = node[p].len + 1; p = node[p].ch[now]; }
    }
    ans = max(ans, len);
}
```
* **代码解读**：  
  匹配时，若当前字符有转移则直接跳转（长度+1）；否则沿后缀链接回溯。若回溯到根节点（`p=0`），则重置`p=1`（根节点）和`len=0`；否则，当前长度为回溯后节点的`len+1`（因为该节点的最长子串长度为`node[p].len`，添加当前字符后长度加1）。  
* 💡 **学习笔记**：`map`实现的转移表虽牺牲了一点时间，但提高了代码的通用性（如处理大字符集）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解SAM的构建和匹配过程，我设计了一个“像素SAM探险”动画，用8位风格模拟节点转移和匹配过程。
</visualization_intro>

  * **动画演示主题**：像素SAM探险——寻找最长公共子串  
  * **核心演示内容**：  
    1. SAM构建：用绿色像素块表示节点，边表示转移（箭头），分裂节点（黄色）时弹出“克隆”提示。  
    2. 匹配过程：用红色箭头表示当前匹配位置，长度数字动态更新；失配时沿后缀链接（虚线箭头）回溯，播放“滴答”音效；找到转移时，长度增加并播放“叮”音效。  

  * **设计思路简述**：  
    8位像素风降低学习压力，动态节点颜色（绿色普通、黄色分裂、蓝色根）帮助区分节点类型；音效强化关键操作记忆（如匹配成功的“叮”声）；游戏化“探险”主题（每匹配一个字符算一步，最长长度为得分）增加趣味性。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：  
       - 屏幕左半部分显示SAM节点（网格排列，根节点在中心），右半部分显示控制面板（单步/自动按钮、速度滑块）。  
       - 顶部显示“当前匹配长度”和“最大长度”，底部显示当前处理的字符（来自第二个字符串）。  

    2. **SAM构建动画**：  
       - 输入第一个字符串时，逐个字符触发`extend`操作：  
         - 新节点（绿色）从根节点“生长”，边用箭头连接。  
         - 若需分裂节点（黄色），原节点（绿色）的边切换到克隆节点，播放“分裂”音效（短促“啵”声）。  

    3. **匹配过程动画**：  
       - 输入第二个字符串时，红色指针从根节点开始：  
         - 若有转移（箭头高亮），指针滑动到目标节点，长度数字+1，播放“叮”声。  
         - 若无转移，指针沿后缀链接（虚线箭头）回溯，每跳一步播放“滴答”声；找到转移后，指针跳转，长度更新为`p.len+1`，播放“叮”声。  
         - 若回溯到根节点仍无转移，指针回到根，长度归零，播放“嗡”声。  

    4. **结束状态**：  
       - 匹配完成后，最大长度用金色高亮显示，播放胜利音效（欢快旋律），并弹出“最长公共子串长度为XX！”的提示。  

  * **旁白提示**：  
    - “看！新节点从根节点生长出来，这是SAM在记录第一个字符串的子串~”  
    - “当前字符无法匹配，指针沿着后缀链接回溯，寻找可能的匹配位置...”  
    - “找到转移了！长度增加，现在最长长度是XX！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到SAM的构建细节和匹配时的回溯逻辑，理解为什么SAM能高效处理最长公共子串问题。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的SAM解法后，我们可以进一步思考SAM在其他子串问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    SAM不仅能解决最长公共子串问题，还可用于：  
    1. 求字符串的不同子串数量（每个节点贡献`len - fa.len`个子串）；  
    2. 求多个字符串的最长公共子串（广义SAM）；  
    3. 子串出现次数统计（通过后缀链接树的size数组）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3181 [HAOI2016]找相同字符**  
        * 🗣️ **推荐理由**：此题需用广义SAM统计两个字符串的公共子串数量，能巩固SAM的扩展应用。  
    2.  **洛谷 P1117 [NOI2016]优秀的拆分**  
        * 🗣️ **推荐理由**：考察后缀数组和LCP（最长公共前缀）的应用，与本题的SAM思路形成互补。  
    3.  **洛谷 P1967 [NOIP2013 提高组]货车运输**  
        * 🗣️ **推荐理由**：虽为图论问题，但其中的“路径最长边”问题可转化为子串问题，训练问题抽象能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者teafrogsf)**：“一开始没注意匹配时长度的更新逻辑，直接用了转移后节点的`len`，导致答案错误。后来通过打印中间变量发现，正确的长度应该是当前节点的`len+1`。”  

**点评**：这位作者的调试经历提醒我们，在处理SAM的匹配逻辑时，长度的更新需严格基于当前节点的`len`（最长子串长度），而非转移后节点的`len`。打印中间变量（如当前节点、长度）是定位此类错误的有效方法。

---

<conclusion>
本次关于“LCS - Longest Common Substring”的C++解题分析就到这里。希望这份指南能帮助大家理解SAM的核心思想和应用，掌握最长公共子串的高效解法。记住，多动手调试、多思考算法原理，是提升编程能力的关键！下次见~ 💪
</conclusion>

---
处理用时：155.87秒
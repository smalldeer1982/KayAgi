---
title: "RE1 - Reverse Engineering"
layout: "post"
diff: 难度0
pid: SP10464
tag: []
---

# RE1 - Reverse Engineering

## 题目描述

排序是并存于计算机科学和数学中一个迷人主题。只要你深入了解了排序算法，你就能感受到自然的美妙魅力。在排序方面已经做了许多研究，接下来我们讨论一个和排序有关的优美而古老的问题：找到对给定数字排序所需的两数字交换的最小次数。

但是，那些富有智慧的时代已经一去不复返了。现在几乎全部的OIer都知道问题应该如何解决;无论他们是否正确理解了排序的内涵。所以对此感到深深悲哀的研究人员们提出了一个这样的新问题:



有 $N$ 个不同的整数。有多少种排序的方法可以使相邻交换的最小次数按单调递增顺序排序为 $K$ ?



研究人员还不能对这个新问题的难度做出合理的判断，但他们相信解决这个问题需要对排序算法有很深的理解。我不认为研究人员们是对的，我想让你帮我证明他们的谬误，你可以做到吗？




排序是并存于计算机科学和数学中一个迷人主题。只要你深入了解了排序算法，你就能感受到自然的美妙魅力。在排序方面已经做了许多研究，接下来我们讨论一个和排序有关的优美而古老的问题：找到对给定数字排序所需的两数字交换的最小次数。

但是，那些富有智慧的时代已经一去不复返了。现在几乎全部的OIer都知道问题应该如何解决;无论他们是否正确理解了排序的内涵。所以对此感到深深悲哀的研究人员们提出了一个这样的新问题:



有 $N$ 个不同的整数。有多少种排序的方法可以使相邻交换的最小次数按单调递增顺序排序为 $K$ ?



研究人员还不能对这个新问题的难度做出合理的判断，但他们相信解决这个问题需要对排序算法有很深的理解。我不认为研究人员们是对的，我想让你帮我证明他们的谬误，你可以做到吗？

## 输入格式

首先输入一个整数 $T(T<200000)$ ，表示测试情况的个数为 $T$ 。

每种情况都有两个整数 $N(1$ 和 $K(0$ 。




首先输入一个整数 $T(T<200000)$ ，表示测试情况的个数为 $T$ 。

每种情况都有两个整数 $N(1$ 和 $K(0$ 。

## 输出格式

对于每种情况，分别打印其结果 $\mod 10^9+7$ 的得数。

~~~

对于每种情况，分别打印其结果 $\mod 10^9+7$ 的得数。
~~~

## 样例 #1

### 输入

```
33 110 45100 56
```

### 输出

```
Case 1: 2Case 2: 1Case 3: 904490303
```


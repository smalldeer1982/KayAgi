---
title: "SEGFAULT - Segfault"
layout: "post"
diff: 难度0
pid: SP23511
tag: []
---

# SEGFAULT - Segfault

## 题目描述

小彼得和他的朋友小尼古拉是两位黑客，他们常常利用空闲时间玩一个叫「SIGSEGV」的游戏。在这个游戏中，两人要争夺受害者计算机的内存控制权。他们的目标是写出程序来占领尽可能多的内存位置。

游戏规则如下：

- 内存被表示为一个矩阵 RAM\[\]\[\]；矩阵中的每一个格子可能是**空闲的**，被彼得或尼古拉占领的，或者是属于**受害者**的。
- 彼得和尼古拉的程序从这个矩阵中的某个格子开始执行，执行过程中它们只能进行如下操作：「移动到当前格子的上、下、左或右，并试图占领新的格子」。
- 如果程序尝试占领的格子不是空闲的且不属于自己的，将会触发**段错误**（Segmentation Fault），并**立即终止**；尽管如此，程序已经占领的那些内存位置仍属于该程序的所有者。
- 彼得和尼古拉可在设备上同时启动**多个**程序，这些程序只能在游戏**开始时**启动。

两名黑客各有一项不对等的优势：

- 尼古拉的方案更迅速，因此如果彼得和尼古拉同时抢占一个（空闲的）格子，尼古拉会占领成功，而彼得的程序会被终止。
- 尼古拉拥有一台 K 核心的计算机，他可以在游戏开始时启动 K 个程序。
- 彼得则掌握着内存的初始状态以及尼古拉所有程序的行动计划。而尼古拉因为不知道初始状态，他的程序设计得非常简单：程序从指定位置开始，只按固定方向一直走（直到碰到矩阵边缘或一个不自由的格子而终止）。
- 在彼得的程序占领初始位置后，尼古拉的程序才会开始执行。
- 尼古拉给彼得的程序植入了一种病毒，导致彼得所有程序必须从同一个起点出发。
- 彼得凭借最新的 Pintel Core i∞ 处理器，可以在开始时启动无限多个程序（但它们必须都从相同位置开始）。

彼得想知道，如果他采用最佳策略，他最多可以占领多少个内存位置。

## 输入格式

首先输入包含两个自然数 $N$ 和 $M$，表示 RAM\[\]\[\] 矩阵的行数和列数，两者间用空格隔开。

接下来的 $N$ 行每行是个长度为 $M$ 的字符串，表示内存的初始状态（RAM\[i\]\[j\] 由第 $i$ 行的第 $j$ 个字符表示）：

- 用 `.` 表示空闲格子；
- 用 `#` 表示属于受害者的格子；
- 用 `S` 表示彼得程序的开始位置。

接下来的一行是自然数 $K$，表示尼古拉计算机的核心数量。随后 $K$ 行中，每行描述一个尼古拉的程序，格式为 X Y DIR，其中 X 和 Y 为整数，表示程序的起始位置，DIR 表示它的移动方向（`U` - 上，`D` - 下，`L` - 左，`R` - 右）。

## 输出格式

输出彼得最多能占领的内存位置数，假设他采用最优策略。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
\n6 5\n#.S.#\n.....\n.....\n...##\n##...\n...##\n2\n2 1 R\n3 5 L
```

### 输出

```
18
```


---
title: "INC2015F - Pointers"
layout: "post"
diff: 难度0
pid: SP26306
tag: []
---

# INC2015F - Pointers

## 题目描述

你有一个 $R$ 行 $C$ 列的网格地图，每个单元格中都有一个箭头，那些箭头分别是 '`^`', '`>`', '`<`', 或 '`v`'。站在一个单元格上时，你需要根据箭头的指示移动到相邻的单元格。例如，如果你位于坐标 $(r, c)$，那么：

- '`^`' 会引导你移动到上方单元格 $(r-1, c)$。
- '`>`' 会引导你移动到右侧单元格 $(r, c+1)$。
- '`<`' 会引导你移动到左侧单元格 $(r, c-1)$。
- '`v`' 会引导你移动到下方单元格 $(r+1, c)$。

如果移动后超出了网格的边界会掉出地图。  
你的任务是修改一些箭头，使得从网格的任何一个单元格出发，沿着箭头移动，最终都能回到原地。你需要计算最少需要修改的箭头数量。

来看一个例子，4 行 2 列的地图如下：

```
> v
 v <
> v
><
```

下面是三种可能的修改方案：

```
> < v <
> < v <
> < v <
> < > <
```

在第一个方案中，需要修改 3 个箭头：$\{(1, 2), (2, 1), (3, 2)\}$。在第二个方案中，需要修改 6 个箭头：$\{(1, 1), (1, 2), (2, 2), (3, 1), (3, 2), (4, 2)\}$。在最后一个方案中，修改了 2 个箭头：$\{(2, 1), (3, 2)\}$。在所有可能方案中，最少需要修改 2 个箭头（如第三种方案）。

同样地，如果移动后超出了网格边界，就会掉出地图。

## 输入格式

第一行是一个整数 $T$，表示测试用例的数量。对于每个测试用例：

- 第一行包含两个整数 $R$ 和 $C$，分别表示网格的行数和列数。
- 接下来的 $R$ 行中，每行用一个字符串描述一行中各个单元格中的箭头方向。

## 输出格式

对于每个测试用例，输出形如 `Case #X: Y` 的结果，其中 $X$ 是测试用例的编号，从 1 开始。$Y$ 是为实现目标所需修改的最少箭头数；如果无法实现目标，则输出 `-1`。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
4 2
&gt;v
v&lt;
&gt;v
&gt;&lt;
3 4
v&lt;&gt;v
v^^v
&gt;^^&lt;
3 4
v&lt;&lt;&lt;
v^v&lt;
&gt;&gt;&gt;^
1 2
&gt;&gt;
```

### 输出

```
Case #1: 2
Case #2: 0
Case #3: 2
Case #4: 1
```


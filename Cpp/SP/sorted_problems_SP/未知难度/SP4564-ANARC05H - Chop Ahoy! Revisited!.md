---
title: "ANARC05H - Chop Ahoy! Revisited!"
layout: "post"
diff: 难度0
pid: SP4564
tag: []
---

# ANARC05H - Chop Ahoy! Revisited!

## 题目描述

给定一个由数字组成的非空字符串，我们可以按照原始顺序将这些数字划分成若干子组。要求是：除了最后一个子组，每个子组中的数字之和必须小于或等于其右边紧邻的子组中数字之和。显然，每个数字只属于其中一个子组。

例如，字符串 635 只能被分成一个子组 \[635\] 或两个子组 \[6-35\]（因为 6 小于 8）。再如字符串 1117，可以被分成一个子组 \[1117\]，或者通过以下方式分组：\[1-117\]，\[1-1-17\]，\[1-11-7\]，\[1-1-1-7\]，\[11-17\] 和 \[111-7\]。因此，总共有 7 种可能的分组方式。

请编写一个程序，计算出对于给定的数字字符串，满足条件的所有可能的分组方式的数量。

## 输入格式

程序会对多个测试用例进行测试。每个测试用例占一行，包含一个长度不超过 25 的字符串，字符串只由数字组成。

当遇到仅包含 "bye" 的一行时，表示输入结束。该行不算作测试用例。

## 输出格式

对于每个测试用例，按照以下格式输出：

`k. n`其中，k 是测试用例的编号（从 1 开始），n 是该测试用例的分组方式数量。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
635
1117
9876
bye
```

### 输出

```
1. 2
2. 7
3. 2
```


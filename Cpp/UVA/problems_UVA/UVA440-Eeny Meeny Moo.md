---
title: "Eeny Meeny Moo"
layout: "post"
diff: 难度0
pid: UVA440
tag: []
---

# Eeny Meeny Moo

## 题目描述

## 题目背景

相信你已经体验过了——如果一个国家有很多个人同时上网，那么网速会变得非常非常慢~


为了解决这个棘手的问题，乌尔姆大学要制定一个“高峰负荷应急计划”。他们希望能以最系统、最公平的方式在网络高峰时切断德国一些城市的网络接入，好使网络快一点。

假设德国现在有 $n$ 个随机排列的城市，其中弗莱堡位列第一，乌尔姆在第二位，卡尔斯鲁厄排名第三，以此类推。

我们要选择一个数 $m$，依照这样的规律断开某些城市的互联网连接：
- 首先切断城市 $1$ 的互联网接入
- 接着切断城市 $1+m$ 的互联网接入
- 以此类推，切断 $1+2m$、$1+3m$ 等城市的互联网接入。
- 切断互联网接入的时候忽略已经被切断互联网的城市。

城市的排列是环形的，也就是说城市的互联网应该会是循环切断的。假如现在我们要切断城市 $n-3$ 的互联网接入，而 $m$ 的值是 $5$，那么接下来要切断的是城市 $3$ 的互联网接入（从城市 $n-3$ ，分别数到 $n-2$、$n-1$、$n$、$2$（这里城市 $1$ 因为已经切断了所以忽略不计）、$3$）。

举个例子：

- 如果当前的 $m=5$ 而 $n=17$，那么城市的断网顺序会是这样的一个序列：
>[1,6,11,16,5,12,2,9,17,10,4,15,14,3,8,13,7]

问题是，最后给乌尔姆断网显然是最好的（因为那里是许多优秀程序员的来源地），所以对于给定的 $n$，乌尔姆大学需要仔细选择数字 $m$，保证最后一个切断网络连接的是乌尔姆（城市 $2$）。

你的任务是编写一个程序，读取 $n$ 个城市，之后给出**最小而且能保证最后才给乌尔姆断网**的数字 $m$。

## 输入格式

输入有一行或多行，每行包含一个数字 $n$。

请读取输入直到输入的 $n$ 为 $0$。

## 输出格式

输出有一行或多行。对于每个不是 $0$ 的 $n$，打印一行一个 $m$，满足题目中的要求。

## 样例 #1

### 输入

```
3
4
5
6
7
8
9
10
11
12
0
```

### 输出

```
2
5
2
4
3
11
2
3
8
16
```


# 20个问题 Twenty Questions

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=247&page=show_problem&problem=3693

[PDF](https://uva.onlinejudge.org/external/12/p1252.pdf)

# 题解

## 作者：龙潜月十五 (赞：9)

## 一、前言

本题是一道**状压 DP**，由于本人状压 DP学的不好，故写下这篇题解加深理解。本文将介绍**位运算**，**状压 DP**，以及**做题思路**。

## 二、位运算

- 位运算的一个重要作用就是**表示一个集合**，常见于**状压 DP**。

- 一个数的二进制可以看作是一个**集合**（ $0$ 表示在这个集合中，$1$ 表示不在这个集合中）。而这时的**位运算**可以看做是**对集合的操作**。

| **操作** | **集合表示** | **位运算语句** |
| :----------: | :----------: | :----------: |
| 交集 | $a \ \cap \ b$ | `a & b` |
| 并集 | $a \ \cup \ b$ | `a | b`  |
| 补集 | $\bar{a}$ | `~ a` (**全集**为**二进制都是一**)  |
| 差集 | $a$ \ $b$ | `a & (-b)` |
| 对称差 | $a \triangle b$ | `a ^ b` |

## 三、题意

有 $n$ 个长度为 $m$ 的二进制串（物品），每次你都可以询问目标二进制串（心中想的物品）第 $k$ 位的值（心中的物品是否有该特征），问**最少**询问几次能够确定目标二进制串。

## 四、思路

### （1） 审题
首先看到**二进制串**就很快能想到**状压 DP**，再一看 $m \leq 11$，十分符合状压 DP 的情况。

**适合状态压缩的情况**：

- 状态复杂，难以表达。

- 但是状态**数量**少，且决策较少（最好就只有两个，符合二进制）

### （2） 状态

由于我们在询问过一个特征值之后就不需要再询问一遍，因此我们可以设一个集合 $s$ 表示**已经询问过的特征组成的集合**。而我们又要求出一个确定的二进制串，假设这个确定的二进制串为 $F$，那么我们设 $a$ 表示**已经确定的 $F$ 的特征所组成的集合**。则可以得到状态 $f(s,a)$ 为**已经询问过集合 $s$，已经确定的 $F$ 的特征集为 $a$ 时还需要询问的最小次数。**

### （3） 转移

我们假设下一次提问的对象是特征 $k$，可得转移方程

$$f(s,a)=\min(f(s,a),\max(f(s+\{k\},a+\{k\}),f(s+\{k\},a))+1)$$

取 $\max$ 是因为我们只是猜测确定的串是否有特征 $k$，它可能有可能没有，需要我们取最大值保证**确定了 $k$ 到底是不是它的特征**。取 $\min$ 得到满足条件的最优解。

### （4） 实现

具体实现用**记忆化搜索更优**，因为这里我们难以确定递推顺序，而记忆化搜索**不需要考虑顺序**。

## 五、状压 DP

接下来我会举一些本题的代码为例子来阐述状压 DP 的具体实现。

```cpp
(s&(1<<k))==0;
```
- $1<<k$ 表示**只有 $k$ 单独一个元素的集合**，而 `a & b` 是取两者的**交集**，$s$ 和 $k$ 交集为 $0$ 表示 $s$ **集合中没有** $k$ 元素。

```cpp
s|(1<<k);
```

- `a | b` 是取两者的并集，一般表示**把两个集合相加**，在这里表示**在 $s$ 集合中加入 $k$ 元素**。

```cpp
for(int i = s; i; i = (i-1)&s)
```

- **遍历** $s$ 集合。

## 六、后记

- 参考文献：
	
 	[oi - wiki](https://oi-wiki.org/math/bit/)、
《算法竞赛入门经典》

---

## 作者：Lovesaint_lym2010 (赞：2)

一道状压dp的题，挺难的

首先这道题符合状态压缩的条件：
1. 状态复杂，难以用一个值来表达；
2. 数据范围很小 $(m \leq 11)$

很显然这道题可以使用状压dp。一个动态规划的题，需要考虑的是：究竟需要维护什么。

以往遇到这种 $n$ 个东西的题，大多都要维护到第几个了。但是**我们的思维不能固化**，因为这道题，**维护到第几个了一点儿用也没有**。

很明显我们问的问题每次是不一样的，所以**我们需要维护哪些位置已经被问过了**，这是一个二进制串。我们写出状态：$f_{st_1}$ 表示已经问过 $st_1$ 中的问题，还需要询问多少次。接着考虑转移，$f_{st_1} = \min \{ f_{st_1 + \{k\}} + 1 \}$。但是这个转移没有任何意义，因为它与输入的东西无关。这时候我们需要考虑，**什么时候可以确定一个二进制串**？记：**$st_1$ 中被询问过的与心中想的串 $s$ 的共同部分为 $st_2$，那么只需要 $st_2$ 只有这一个串拥有就好了**。

我们改变状态，$f_{st_1, st_2}$ 中 $st_1$ 表示已经问过的位置，$st_2$ 表示已经确定的位置。其实这个状态比较抽象，因为这个已经确定的位置并没有说是哪一个二进制串的确定位置，而是与他心中所想的串的确定位置。那为什么要这么设计呢？因为**通过确定的位置可以知道，询问这些是否可以唯一确定一个二进制串**。借助转移可以更好地理解：
$$ f_{st_1, st_2} = \min\{ \max\{ f_{st_1 | k, st_2 | k}, f_{st_1 | k, st_2} \} + 1 \} , k \notin st_1$$
这个的意思是，询问第 $k$ 位时，要么这位是心中的串的特征，要么不是，两者取最大才能知道至少要询问多少次，最后 $+1$ 表示这次询问。

边界是 $st_1, st_2$ 只能唯一确定一个串的时候，每一个都判断太慢了，所以我们应该预处理出来：$cnt_{st_1, st_2}$ 表示询问的为 $st_1$，确定的为 $st_2$ 的时候，有多少个串满足要求。具体详见代码。

那么这道题就愉快的做完了。

```cpp
#include <iostream>
#include <cstring>
#include <string>
using namespace std;
const int NR = 130, MR = 11, KR = 1 << MR;
int n, m, a[NR];
int f[KR][KR], cnt[KR][KR];
string T2T(int x)
{
    string s = "";
    int cnt = 1;
    while (cnt <= m)
    {
        int d = x % 2;
        if (d == 0) s = '0' + s;
        else s = '1' + s;
        x /= 2, cnt++;
    }
    return s;
}
void preWork()
{
    for (int i = 0; i < (1 << m); i++)
        for (int j = 1; j <= n; j++)
            cnt[i][a[j] & i]++;
}
int dfs(int st1, int st2)
{
    if (f[st1][st2] != -1) return f[st1][st2];
    if (cnt[st1][st2] <= 1) return f[st1][st2] = 0;
    if (cnt[st1][st2] == 2) return f[st1][st2] = 1;
    // cout << T2T(st1) << " " << T2T(st2) << " " << cnt[st2] << '\n';
    int ans = 20;
    for (int i = 0; i < m; i++)
    {
        int k = (1 << i);
        if (!(k & st1))
            ans = min(ans, max(dfs(st1 | k, st2 | k), dfs(st1 | k, st2)) + 1);
    }
    // printf("f[%s][%s] = %d\n", T2T(st1).c_str(), T2T(st2).c_str(), ans);
    return f[st1][st2] = ans;
}
int main()
{
    while (cin >> m >> n && n && m)
    {
        memset(a, 0, sizeof a);
        memset(cnt, 0, sizeof cnt);
        for (int i = 1; i <= n; i++)
        {
            string s; cin >> s;
            int k = 1;
            for (int j = 0; j < m; j++)
                a[i] |= ((s[j] - '0') << j);
        }
        memset(f, -1, sizeof f);
        preWork();
        cout << (dfs(0, 0) == 0 ? 0 : dfs(0, 0)) << '\n';
   }
    return 0;
}
```

---

## 作者：autoint (赞：2)

# 分析
#### 为了叙述方便，设“心里想的物体”为W。首先在读入时把每个物体转化为一个二进制整数。不难发现，同一个特征不需要问两遍，所以可以用一个集合s表示已经询问的特征集。
#### 在这个集合s中，有些特征是W所具备的，剩下的特征是W不具备的。用集合a来表示“已确认物体W具备的特征集”，则a一定是s的子集。
#### 设d(s,a)表示已经问了特征集s，其中已确认W所具备的特征集为a时，还需要询问的最小次数。如果下一次提问的对象是特征k（这就是“决策”），则询问次数为：
##### max{d(s+{k},a+{k}),d(s+{k}, a)}+1
#### 考虑所有的k，取最小值即可。边界条件为：如果只有一个物体满足“具备集合a中的所有特征，但不具备集合s-a中的所有特征”这一条件，则d(s,a)=0，因为无须进一步询问，已经可以得到答案。
#### 因为a为s的子集，所以状态总数为3m，时间复杂度为O(m*3^m)。对于每个s和a，可以先把满足该条件的物体个数统计出来，保存在cnt[s][a]，避免状态转移的时候重复计算。统计cnt[s][a]的方法是枚举s和物体，时间复杂度为O(n*2^m)，所以总时间复杂度为O(n*2^m +m*3^m)。对于本题的规模来说O(n*2^m)可以忽略不计。
# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T> inline T read(T&x)
{
    T data=0;
    int w=1;
    char ch=getchar();
    while(ch!='-'&&!isdigit(ch))
        ch=getchar();
    if(ch=='-')
        w=-1,ch=getchar();
    while(isdigit(ch))
        data=10*data+ch-'0',ch=getchar();
    return x=data*w;
}
const int maxn=150;
int m,n;
int feature[maxn],cnt[(1<<11)+10][(1<<11)+10];
int d[(1<<11)+10][(1<<11)+10];

int dp(int s,int a){
    if(d[s][a]!=-1)
        return d[s][a];
    if(cnt[s][a]<=1)
        return d[s][a]=0;
    if(cnt[s][a]==2)
        return d[s][a]==1;
    int ans=20;
    for(int i=0;i<m;++i)
        if(!(s&(1<<i)))
            ans=min(ans, max(dp(s|(1<<i),a),dp(s|(1<<i),a|(1<<i)))+1 );
    return d[s][a]=ans;
}

int main()
{
    while(read(m)&&read(n))
    {
        memset(feature,0,sizeof(feature));
        char s[20];
        for(int i=1;i<=n;++i)
        {
            scanf("%s",s);
            for(int j=0;j<m;++j)
                feature[i]|=((s[j]-'0')<<j);
        }
/*		clog<<"input check"<<endl;
        for(int i=1;i<=n;++i)
        {
            for(int j=0;j<m;++j)
                clog<<((feature[i]&(1<<j))?1:0);
            clog<<endl;
        }
        clog<<"input check completed"<<endl;*/
        memset(cnt,0,sizeof(cnt));
        for(int i=0;i<(1<<m);++i)
            for(int j=1;j<=n;++j)
                ++cnt[i][i&feature[j]];
        memset(d,-1,sizeof(d));
        printf("%d\n",!dp(0,0)?0:dp(0,0)+1);
    }
    return 0;
}

```
## 另外，输入物体和预处理cnt[s][a]时刘汝佳标程的做法太繁琐，大家可以参考我的做法。
#### 网上有大量AC代码没有预处理，大概比我慢了70ms，而我跑出来是80ms，所以差别不大。有的人可能喜欢不加预处理，这里我也提供一份朴素的代码（不是我打的，有问题别找我）
```cpp
# include<iostream>
# include<cstdio>
# include<string>
# include<cstring>
# include<algorithm>
using namespace std;
 
const int INF=0x3f3f3f3f;
 
char p[13];
int dp[1<<11][1<<11],sta[130],m,n;
 
int getVal()
{
    int res=0;
    for(int i=0;i<m;++i)
        if(p[i]=='1')
            res|=(1<<i);
    return res;
}
 
int DP(int s,int a)
{
    if(dp[s][a]!=INF)
        return dp[s][a];
 
    int num=0;
    for(int i=0;i<n;++i)///在这里，也可以预处理出来以提高效率；
        if((sta[i]&s)==a)///"=="的优先级比"&"的高!!!
            ++num;
    if(num<=1)
        return dp[s][a]=0;
 
    int &ans=dp[s][a];
    for(int i=0;i<m;++i){
        if(s&(1<<i))
            continue;
        ans=min(ans,max(DP(s|(1<<i),a),DP(s|(1<<i),a|(1<<i)))+1);
    }
    return ans;
}
 
int main()
{
    while(scanf("%d%d",&m,&n)&&n+m)
    {
        for(int i=0;i<n;++i){
            scanf("%s",p);
            sta[i]=getVal();
        }
        memset(dp,INF,sizeof(dp));
        printf("%d\n",DP(0,0));
    }
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/UVA1252)
# 题意分析
分析题意，我们知道一共有 $n$ 个物体，$m$ 种特征。每个物体有哪些特征可以用一个 $m$ 位二进制数来描述。接着他会在心中想一个物品，让我们来猜这是哪个物品，每次可以询问这个物品是否有某个特征。问：在最坏情况下，至少要询问多少次，才可以确定是哪个物品。
# 初步思考
一看到最少两字，首先想到贪心。但这题贪心显然是不行的。再看看数据范围，觉得更像是动态规划。更具体的，应该是状态压缩动态规划。那么既然是状态压缩，那么到底压缩什么？看了看数据范围，$m\le 11$。那么应该是压缩有关 $m$ 的状态。那哪些是有关 $m$ 的状态呢？显然有很多。但我们**需要的**是什么？是**有意义**的，是**和输入有关**的，是**对解决问题有帮助的**。还有一点最重要，是**正确**的，也就是**能通过子问题的解来推导大问题的解**的。~~（好像说了一堆的废话）~~。
# 深度思考
既然是状态压缩 dp，那三要素可不能少。
## 一、状态
明白了要选有关 $m$ 的状态，而且还是我们需要的。 $\\$
例如这个状态 $dp_S$，他表示已经问了 $S$ 中的特征，还需要问多少次。当然这个状态的转移方程很好推导，即 $dp_S=\min\{dp_{S+k}+1\}$，其中 $k\notin S$。但这个转移他没有任何意义，他和输入也无关。这时候我们就需要考虑，什么时候能确定一个物体？这个其实很容易就能想明白了，显然，当一个物体有某些特征，而这些特征其他物体都不满足，那就可以确定是这个物体，不是吗？那不妨我们设上文中提到的“某些特征”记作 $v$，此时的状态 $dp_{S,v}$ 就表示已经问了 $S$ 中的特征，得知正确的物体满足 $v$ 中的特征，一共还需要问多少次？
## 二、边界
确定了状态，那就得确定边界了。试想一下，如果满足某些特征的物体只有一个或根本没有，那是不是不用再问了？如果只剩两个物体了，只要问一下它们的不同点，是不是就可以直接确定了？那么边界不就出来了吗？但如果满足某些特征的物体超过了两个，那你问其中的一个特征，最坏情况下只能排除一个物品。用一个数组 $c$ 来存储询问的为 $S$，确定的为 $v$ 时满足条件的物体的个数。就可以很容易判断是否是边界。
## 三、转移
假设此时已经问过了 $S$ 中的特征，还不能确定。此时再问一个特征，肯定不能问问过了的特征。设将要问的特征为 $k$，则必须满足 $k\notin S$。接下来就要判断问这个特征是否更优。首先要分两种情况：

1. 答案不满足特征 $k$，此时由状态 $dp_{S+k,v}$ 转移而来。
2. 答案满足特征 $k$，此时由状态 $dp_{S+k,v+k}$ 转移而来。

既然题目要求是最坏的情况，那肯定是从这两个状态中取询问次数最多的状态，最后再取最小值，由此可得状态转移方程：
 $$dp_{S,v}=\min\{dp_{S,v},\max\{dp_{S+k,v+k},dp_{S+k,v}\}+1\},k\notin S$$ 


那么这道题就愉快的做完了。
# 具体步骤
- 输入并初始化 c 数组。
- 记忆化搜索，调用 $\operatorname{dfs}(0,0)$ 。
- 如果递归到达边界或此状态已经求解，返回。
- 进行状态转移，并返回答案。

---


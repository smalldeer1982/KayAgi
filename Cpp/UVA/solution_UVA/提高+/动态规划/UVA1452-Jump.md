# Jump

## 题目背景

扩展约瑟夫环问题。

## 题目描述

[problemUrl]: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=447&page=show_problem&problem=4198

编号为 $1,2,...n$ 的人围坐在圆桌周围。从 $1$ 号开始报数，报到 $k$ 的人出列，他的下一个人又重新从 $1$ 开始报数，数到 $k$ 的人又出列；依次下去，直到圆桌上所有人都出列。给定 $n$ 与 $k$，求最后出列的三个人的编号。

例如 $n=10,k=2$，出列顺序为 `2，4，6，8，10，3，7，1，9，5`。那么答案为 `1 9 5`。

## 说明/提示

$5≤n≤5\times 10^5,2≤k≤5\times 10^5$ 。

## 样例 #1

### 输入

```
1
10 2```

### 输出

```
1 9 5```

# 题解

## 作者：皎月半洒花 (赞：4)

~~这一波，这一波叫做「模仿 Matrix67 既遂」~~

翻了翻刘汝佳的蓝书，发现约瑟夫问题自己之前似乎没怎么玩过，于是就编了编。

## 普通约瑟夫环问题

大概是先考虑普通的约瑟夫问题:

> 编号分别为 $0,1,2\cdots n-1$ 的围成一圈，从 $0$ 出发，每走 $k$ 步枪毙一个，求最后的生还选手。这东西有个十分玄妙的 $dp$ ：

令 $f_i$ 为经过了 $i$ 轮之后的生还者，那么有

$$f_i=(f_{i-1}+k)\bmod i\qquad (1)$$

然后经扶苏启发，想出了一个比较妙的证明方式：

考虑原本是一个无限大的圈，从 $0$ 开始走 $k$ 步枪毙掉 $k-1$ 号选手之后重新编号，即编号从

$$0,1,2,3,4\cdots k-2, k,k+1,k+2,k+3\cdots n$$

变成了

$$n-k+1,n-k+2,n-k+3 \cdots n-1,0,1,2\cdots n-k$$

也就是从原来的 $k$ 号重新开始走。每走一次重新标一次号。

会发现，每次重标号，所有的幸存元素编号都会 $-k$，当然这个 $-k$ 是在模**上次剩下的元素个数**意义下的。这样最后删来删去，剩下唯一的元素被重标号成 $0$ 。


那不妨来换一个类似的游戏。从最开始的 0 开始，每次添加进来一个人跟他一起删，直到添加到 $n$ 个人。发现这样做本质上就是在重复上面的约瑟夫游戏，只是…倒了过来？不难发现第 $n$ 个被删的，就是最后的 $0$ 号选手，这个选手每次都经历了被 $+k$，然后 mod 原来的数这个过程…

所以 $(1)$ 式就好理解了。$0$ 号元素经历 $n$ 次重编号，每次都 $-k$ 再对当时的人数取模。考虑反过来做，就变成 $+k$ 了。

扶哥当时的证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/bjth8y9u.png)

## 扩展约瑟夫环问题

> 改成求倒数第 $1$、倒数第 $2$ …… 倒数第 $m$ 被 gank 的小朋友。

这东西并不是 $f_{i-1},f_{i-2}\cdots f_{i-m}$。因为约瑟夫问题是的状态是不同的游戏，转移是在不同游戏间转移而不是不同人。

考虑扩展一下 $f$ 。发现如果倒数第二个被删除的，每次也要重编号，mod 当时的元素个数。所以按照上面的思路，只需要求出他生前最后一次的位置就可以逆推了。发现如果要是第 $n-1$ 个被 gank，那么需要当时的位置正好是 $k-1$，并且是 $\bmod ~2$ 意义下的 $k-1$ 。所以可以知道他的初始位置应该设置为 $(k-1)\bmod 2$ 。

于是就可以设 $f_{n,m}$ 表示 $n$ 个人的游戏，还要进行 $k$ 轮游戏时剩下的人是谁。那么 $f_{m,m-1}=(k-1)\bmod m$，剩下的就是一摸一样的逆推过程。

以下是[UVA1452 Jump](https://www.luogu.com.cn/problem/UVA1452)的代码。

```cpp
int T ; 
int n, k ; 
int f[N][M] ;

int main(){
	cin >> T ;
	while(T --){
		cin >> n >> k ; 
		for (int o = 0 ; o < 3 ; ++ o){
			f[o + 1][o] = (k - 1) % (o + 1) ;
			for (int i = o + 2 ; i <= n ; ++ i)
				f[i][o] = (f[i - 1][o] + k) % i ;
		}
		cout << f[n][2] + 1 << " " << f[n][1] + 1 << " " << f[n][0] + 1 << '\n' ; 
	}
}
```


---

## 作者：Moon_Lighter (赞：1)

### 题意：
求约瑟夫环倒数三个删除的是几。

### 思路：
经典约瑟夫环的递推是： $f_1 = 0 ,f_n = (f_{n-1}+k) \bmod n$ 。

### 那么这道题就变形为：
当求倒数第三个的时候，我们考虑只剩三个的时候，第一删除的就是答案，那么结果很容易写出来是： $(k-1)\bmod 3$ ，同时这也是 $f_3$ 的答案，同理推出其他的只是起始条件变了。

---
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
int f(int a,int b,int c)
{
    int d=(b-1)%(a-c+1);
    for(int t=a-c+2;t<=a;t++)
    {
        d=(b+d)%t;
    } 
    return d+1;
}
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        cout<<f(n,m,n-2)<<f(n,m,n-1)<<f(n,m,n)<<endl;
    }
    return 0;
}
```

---

## 作者：pomelo_nene (赞：1)

$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/UVA1452)，同步于[动态规划100题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)第18题。

$\ \ \ \ \ \ \ $注：以上皆为 0 开头，代表队伍中的 1，$n-1$ 代表第 $n$ 人。

$\ \ \ \ \ \ \ $这实际上是一个约瑟夫问题的一个变形。首先回到约瑟夫问题，它的实质是：将 $n$ 个人的子问题化成 $n-1$ 个，在同时建立一个映射关系，也就是我们的递推数组。我们要求最后一个人，就要倒退回去推出 $n$ 个人的情况。得到了最后一个人是谁，在倒推倒数第二人，倒数第三人即可。

$\ \ \ \ \ \ \ $所以我们定义 $dp_i$ 为 $i-1$ 个人出列后，接下来应该让谁出列（同时调整队列顺序与编号）。我们最后一个出列的人因为在队头，所以编号一定为 0。因此 $dp_1=0$。题目定义得出递推方程：

$$dp_{i-1}=dp_i-k(\mod i)$$

$\ \ \ \ \ \ \ $即：

$$dp_i=dp_{i-1}+k(\mod i)$$

$\ \ \ \ \ \ \ $考虑到我们要求倒数三个人，所以分别令 $dp_1=0,dp_1=1,dp_2=2$ 就可以分别求出倒数第一个，倒数第二个和第三个了。

$\ \ \ \ \ \ \ $这里就直接把数组滚了，代码会有点奇怪。因为 0 是开头，所以答案注意加 1。

$\ \ \ \ \ \ \ $滚了数组之后代码可能有点怪，可以自行理解一下。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		int n,k;
		scanf("%d %d",&n,&k);
		int a=0,b=(k-1)%2,c=(k-1)%3;
		for(int i=2;i<=n;++i)	a+=k,a%=i;
		for(int i=3;i<=n;++i)	b+=k,b%=i;
		for(int i=4;i<=n;++i)	c+=k,c%=i;
		printf("%d %d %d\n",c+1,b+1,a+1);
	}
	return 0;
}
```

---


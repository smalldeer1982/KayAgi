# Pebble Solitaire

## 题目描述

[原PDF](https://uva.onlinejudge.org/external/106/p10651.pdf)

Pebble Solitaire是一款有趣的游戏。你会得到一个上面有一排小洞的板，这些洞最初只有一个没有被鹅卵石占据。 游戏的目的是从棋盘上移除尽可能多的鹅卵石。如果满足以下条件，你就可以进行移动：如果存在三个相邻的、能连成一条直线的洞（不妨称它们为A，B和C），中间为B，其中A是空的，但B和C上均有一个石子。那么你可以把C上的石子移到A上，并拿走B中的石子。 你可以继续移动石子，直到无法再移动为止。

在这个问题中，我们来看一个简单的游戏变体，即一个沿着一条线放置十二个小洞的板。 每次游戏开始时，有一些洞上被放有石子。你的任务是使尽可能少的鹅卵石留在棋盘上。

![pr](https://cdn.luogu.org/upload/pic/23786.png)

在 a) 中有两种可能的移动，分别是8->6和7->9。

b) 为 a) 选择第二种移动方式的结果，此时又有两种移动方式，分别是5->7或者6->4。

c) 作为 b) 做出第一种选择的结果，此时再没有其它的移动方式了。

## 样例 #1

### 输入

```
5
---oo-------
-o--o-oo----
-o----ooo---
oooooooooooo
oooooooooo-o```

### 输出

```
1
2
3
12
1```

# 题解

## 作者：spire001 (赞：2)

## 题意

就是一种跳棋，让你在上面想怎么跳就怎么跳，最后看棋盘上最少有几个棋子。

## 思路

观察到棋盘大小是较小常数 $12$。考虑状态压缩。

`bool` 型数组 $dp_i$ 表示能表示出的一种状态。

最后处理出所有状态后，取值为真的并且棋子最少的作为答案即可。

那么问题来了，如何计算出一个数二进制表示中的 $1$？

注意到二进制的性质，一个数与自己减一做和运算，可以去掉自己最低位的 $1$。

故可以这么写出计算 $1$ 的数量的函数 `nums`。

```cpp
inline int nums(int num)
{
	int cnt = 0;
	while(num)
	{
		num &= num - 1;//减一必定使最后一个1消失，和运算去掉它。
		cnt++;
	}
	return cnt;
}
```

还有如何去掉第 $i$ 位的 $1$。

可以通过 ```num &= ~(1 << i - 1)``` 实现。

为了加快转移速度，可以使用更高级的数据结构来替代 `bool` 数组。

我这里使用的是 `STL` 中的 `bitset` 来实现。

## 代码

```cpp
# include <iostream>
# include <cstring>
# include <cstdlib>
# include <ctime>
# include <algorithm>
# include <queue>
# include <stack>
# include <iomanip>
# include <cctype>
# include <vector>
# include <bitset>
# include <climits>
# include <random>

using namespace std;

template <typename T>
void Read(T & num)
{
	num = 0;short f = 1;char c;
	for(c = cin.get(); c < '0' || c > '9'; c = cin.get()) if(c == '-') f = -f;
	for(; c <= '9' && c >= '0'; c = cin.get()) num = (num << 1) + (num << 3) + (c ^ 48);
	num *= f;return;
}
template <typename T>
void Write(T num)
{
	if(num < 0) {num = ~num + 1;cout.put('-');}
	if(num > 9) Write(num / 10);
	cout.put((num % 10) ^ 48);
}
template <typename T>//我喜欢快读快写
void Write(T num , char __c)
{
	Write(num);
	cout.put(__c);return;
}
int T;
inline int nums(int num)
{
	int cnt = 0;
	while(num)
	{
		num &= num - 1;
		cnt++;
	}
	return cnt;
}
bitset <(1 << 13)> box;
void print(int number)//调试时输出二进制的方法,是递归的思路
{
	if(number > 1) print(number / 2);
	cout << number % 2;
	return;
}
bool flag;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	Read(T);
	int x = 1 << 13;
	while(T--)
	{
		box.reset();
		int num = 0;
		char c;
		for(int i = 1; i <= 12; i++)
		{
			cin >> c;
			if(c == 'o') num |= (1 << (i - 1));
		}
		//print(num);cout << '\n';
		box[num] = true;
        int formax = nums(num);//找出循环的最大次数，最多循环初始时的棋子数。
		for(int i = 1; i < formax; i++)
		{
			flag = false;
			for(int j = 0; j < x; j++)
			{
				if(box[j])
				{
					/*left，向左跳的情况*/
					
					for(int p = 2; p <= 11; p++)
					{
						
						
						if(!(j & (1 << (p - 2))) && (j & (1 << p - 1)) && (j &(1 << p)))
						{
							num = j;
//							print(num);
//							cout << " -> " ; 
							num &= ~(1 << p - 1);
							num &= ~(1 << p);//去掉最右边的1
							num |= 1 << (p - 2);//加上左边的1
							box[num] = flag = true;
//							print(num);cout << '\n';
						}
					}
					
					/*right,*/
					
					for(int p = 2; p <= 11; p++)
					{
						if((j & (1 << (p - 2))) && (j & (1 << p - 1)) && !(j &(1 << p)))
						{
							num = j;
//							print(num);
//							cout << " -> " ; 
							num &= ~(1 << p - 2);
							num &= ~(1 << p - 1);//去掉最左边的1
							num |= (1 << p);//加上右边的1
							box[num] = flag = true;
//							print(num);cout << '\n';这是调试内容
						}
					}
				}
			}
			if(!flag) break;
		}
		num = 13;
		for(int i = 0; i < x; i++) if(box[i]) num = min(num , nums(i));//获得答案
		Write(num , '\n');
	}
	return 0;
}


```



## 总结

本题思路不难想，主要就是考察耐心细致以及调试代码能力。

---

## 作者：violinwang (赞：1)

## 题解来啦

##### 题意：

### 跳跳棋是一项很有趣的活动，就和跳棋差不多，不过规则有点变动。新的跳跳棋怎么走呢？规则如下：（一共有两种情况可以跳）

![](http://a4.qpic.cn/psb?/V141COev2OWXS3/ab76Aa1LJeXQFyKKQE0f*sWMFQA1ELIpupbS5p4xIz8!/c/dGcBAAAAAAAA&ek=1&kp=1&pt=0&bo=qwP*AKsD*wABACc!&tl=1&tm=1531796400&sce=0-12-12&rf=0-18)

###  现在呢，我给你 T 行棋盘，每行相互独立，每行都是12 格， 'o' 代表棋子， '-' 代表空的格子，请你帮我求出最终我在棋盘上剩下的最少的棋子，步数不限哦，尽你所能,尽情跳吧！

### input
第一行：一个整数T，表示数据组数；

接下来T行，每行12个字符，表示一行棋子。

###  output

输出T行。答案为棋盘最少剩下的棋子数。



### 思路：
##### 	利用状态压缩进行模拟。
##### 	对于一行棋，扫一遍，找出满足上述两种情况的棋，然后模拟跳。
#####     dfs进行，用状压储存状态。
    
#####     直到不能跳为止。  
    
###### PS：个人习惯，状态储存
 	---oo-------
 	000110000000
 高位    ----- -------> 低位
###### 建议：打二进制时弄清楚原理，不能照抄，不然会出锅。

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define inf 0x7f7f7f7f

using namespace std;

inline int wread(){
    char c=getchar ();int wans=0,flag=1;
    while (c<'0'||c>'9'){if (c=='-') flag=-1;c=getchar ();}
    while (c>='0'&&c<='9'){wans=wans*10+c-'0';c=getchar ();}
    return wans*=flag;	
}

const int maxn=(1<<12)-1;

int T,ans;
char c[13];
int pre[4100];//pre[j]表示j状态下1（棋子）的个数
int con[14][4100];//con[i][j]表示j状态第i位是0还是1
int sa[4100];//每一种状态的位数
bool vis[4100];//防止死dfs
//bit[i]表示将数字1向左移i位
int bit[14]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096};

void dfs (int x,int num){
	ans=min(ans,num);
	for (int i=3;i<=sa[x];++i){
		if (con[i][x]==1&&con[i-1][x]==1&&con[i-2][x]==0)	{
			
			int t=x;		
			t=t|bit[i-3];
			t^=bit[i-2];
			t^=bit[i-1];
			//将1 1 0->0 0 1
			if (vis[t])	continue;
			vis[t]=true;
			dfs(t,pre[t]);
		}
		if (con[i][x]==0&&con[i-1][x]==1&&con[i-2][x]==1){
			
			int t=x;
			t|=bit[i-1];
			t^=bit[i-2];
			t^=bit[i-3];
			//将0 1 1->1 0 0
			if (vis[t])	continue;
			vis[t]=true;
			dfs(t,pre[t]);
		}
	}
	return ;
}

int main (){
	T=wread();
	for (int i=0;i<=maxn;++i){
		int x=i,num=0;
		int top=0;
		while (x){
			top++;
			int t=x%2;
			if (t==1)	num++,con[top][i]=1;
			else con[top][i]=0;
			x/=2;
		}
		sa[i]=top;
		pre[i]=num;
	}
	
	while (T--){
		
		scanf ("%s",c+1);
		
		int t=0;	ans=inf;
		for (int i=1;i<=12;++i)
			if (c[i]=='o')	t|=(bit[12-i]);
		
		vis[t]=true;
		dfs(t,pre[t]);
		
		printf("%d\n",ans);
	}
	return 0;
}
```




---

## 作者：happy_dengziyue (赞：0)

### 1 思路

字符串长度恒定为 $12$，所以我们可以将状态压缩成整数 $a$。

反正字符串倒过来也没有问题，所以这里，`o-----------`（$1$ 个 `o` 加上 $11$ 个 `-`)可以表示成 $a=(000000000001)_2$。

然后，我们可以用深搜，来枚举出每个可能的状态。

怎么判定它可不可以转成下一个状态呢？我们可以用为运算。代码：

```
for(int i=2;i<12;++i){
	if((a&(1<<(i-1)))&&((bool)(a&(1<<i))^(bool)(a&(1<<(i-2))))){
		a^=(1<<i);
		a^=(1<<(i-1));
		a^=(1<<(i-2));
		dfs(a);
		a^=(1<<i);
		a^=(1<<(i-1));
		a^=(1<<(i-2));
	}
}
```

那个 `if` 有点复杂，请注意括号关系……

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int t;//测试数据组数
char s[14];//字符串
bool vis[4200];//访问情况
int ans;//答案
void dfs(int a){
	if(vis[a])return;
	vis[a]=true;
	for(int i=2;i<12;++i){
		if((a&(1<<(i-1)))&&((bool)(a&(1<<i))^(bool)(a&(1<<(i-2))))){
			a^=(1<<i);
			a^=(1<<(i-1));
			a^=(1<<(i-2));
			dfs(a);
			a^=(1<<i);
			a^=(1<<(i-1));
			a^=(1<<(i-2));
		}
	}
	int tot=0;
	for(int i=0;i<12;++i){
		if(a&(1<<i))++tot;//统计数字中1的位数
	}
	if(tot<ans){
		ans=tot;
	}
	return;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("UVA10651_1.in","r",stdin);
	freopen("UVA10651_1.out","w",stdout);
	#endif
	scanf("%d",&t);
	for(int ca=1,v;ca<=t;++ca){
		scanf("%s",s);
		v=0;
		for(int i=0;i<12;++i)if(s[i]=='o')v|=(1<<i);
		ans=12;
		memset(vis,0,sizeof(vis));
		dfs(v);
		printf("%d\n",ans);
	}
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/53491392)

### 3 打表程序

有没有发现，这里只有 $2^{12}=4096$ 种可能，所以我们可以飞快地打出一张表：

[记录传送门](https://www.luogu.com.cn/record/53493285)

不过，从实际运行速度来看，打表没什么意义。毕竟正解也可以跑得非常快。

By **dengziyue**

---

## 作者：羽儇 (赞：0)

[UVA10651](https://www.luogu.org/problem/UVA10651)

---

挺简单一状压题

---

$Solution$

只需枚举每一行的初始状态和所有转变状态取每状态的1最小数量即可



---

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
int N,ans;
bool vis[4500];
char s[14];
void dfs(int x)
{
	/*for(int i = 0 ; i <= 11 ; i ++ )
	if(x & (1 << i))cout<<1;
	else cout<<0;
	cout<<endl;*/
	if(vis[x])return ;//防循环
	for(int i = 2 ; i <= 11 ; i ++ )
	{
		if((x&(1 << i)&&(x & ( 1 << i - 1))&&(!(x&(1 << i - 2))))||(!(x&(1 << i))&&(x & ( 1 << i - 1))&&(x&(1 << i - 2))))
		{//即110或者011
			x ^= 1 << i - 2 ;
			x ^= 1 << i;
			x ^= 1 << i - 1 ; 
			dfs(x);
			x ^= 1 << i - 2 ;//回溯
			x ^= 1 << i;
			x ^= 1 << i - 1 ; 
		}
  	}
	int cnt = 0;
	for(int i = 0 ; i <= 11 ; i ++ )
	    if(x & (1 << i))cnt++;//枚举每一位求1的个数
	    ans = min (ans ,cnt);
	vis[x] = true;
}
int main()
{
    scanf("%d",&N);
	for(int i = 1 ; i <= N ; i ++ )
	{
		int v = 0;
		memset(vis,false,sizeof vis);
		cin >> s + 1 ;
		for(int j = 0 ; j <= 11 ; j ++ )
		if(s[j + 1] == 'o')v|=(1 << j );
        //将-o转化为01状态
		ans = 13 ; 
		dfs(v);深搜
		printf("%d\n",ans);
	}
	return 0;
}
```
$\text{无注释}$

$Code$

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
int N,ans;
bool vis[4500];
char s[14];
void dfs(int x)
{
	/*for(int i = 0 ; i <= 11 ; i ++ )
	if(x & (1 << i))cout<<1;
	else cout<<0;
	cout<<endl;*/
	if(vis[x])return ;
	for(int i = 2 ; i <= 11 ; i ++ )
	{
		if((x&(1 << i)&&(x & ( 1 << i - 1))&&(!(x&(1 << i - 2))))||(!(x&(1 << i))&&(x & ( 1 << i - 1))&&(x&(1 << i - 2))))
		{
			x ^= 1 << i - 2 ;
			x ^= 1 << i;
			x ^= 1 << i - 1 ; 
			dfs(x);
			x ^= 1 << i - 2 ;
			x ^= 1 << i;
			x ^= 1 << i - 1 ; 
		}
  	}
	int cnt = 0;
	for(int i = 0 ; i <= 11 ; i ++ )
	    if(x & (1 << i))cnt++;
	    ans = min (ans ,cnt);
	vis[x] = true;
}
int main()
{
    scanf("%d",&N);
	for(int i = 1 ; i <= N ; i ++ )
	{
		int v = 0;
		memset(vis,false,sizeof vis);
		cin >> s + 1 ;
		for(int j = 0 ; j <= 11 ; j ++ )
		if(s[j + 1] == 'o')v|=(1 << j );
		ans = 13 ; 
		dfs(v);
		printf("%d\n",ans);
	}
	return 0;
}
```
考虑到，2^12-1 = 4096

~~众所周知，打表是**********~~

打表$ACcode$

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n,ans[4096] = {0,1,1,1,1,2,1,2,1,2,2,1,1,1,2,2,1,2,2,2,2,3,1,2,1,2,1,2,2,2,2,3,1,2,2,2,2,3,2,3,
2,3,3,1,1,2,2,1,1,2,2,1,1,1,2,2,2,3,2,2,2,1,3,3,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,
2,3,3,3,3,4,1,2,1,2,2,2,2,3,1,2,1,2,2,2,2,3,1,2,1,2,1,2,2,2,2,2,2,3,3,2,2,2,2,3,
2,3,1,2,3,2,3,4,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,
2,3,3,3,3,4,3,4,3,4,4,1,1,2,2,2,1,2,2,2,2,2,2,3,2,3,3,1,1,2,2,1,1,2,2,2,2,3,2,3,
2,3,3,1,1,2,2,1,1,2,2,1,1,1,2,2,2,3,2,2,2,1,2,3,2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,1,
2,3,3,1,1,2,2,1,3,4,2,3,3,1,4,4,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,
2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,3,4,3,3,3,2,4,4,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,1,2,1,2,2,2,2,3,2,3,1,2,2,2,2,3,2,3,
2,3,2,2,2,2,3,3,2,3,3,3,3,3,1,2,1,2,2,2,2,3,1,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,
2,3,3,3,3,4,1,2,1,2,2,2,2,3,1,2,1,2,2,2,2,3,1,2,1,2,1,2,2,2,2,2,2,3,3,2,2,2,2,3,
2,3,1,2,2,2,3,2,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,2,3,2,3,3,3,3,2,1,2,
2,3,3,3,3,4,1,2,1,2,2,2,2,3,1,2,3,4,4,2,2,3,3,2,3,4,1,2,4,2,4,5,1,2,2,2,2,3,2,3,
2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,
2,3,3,2,2,2,3,3,3,4,3,3,3,2,4,4,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,
2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,3,3,4,4,3,3,3,3,4,3,4,2,3,4,3,4,5,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,
4,5,5,1,1,2,2,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,
2,3,3,2,2,2,2,3,2,3,2,3,3,2,3,4,2,3,3,3,3,4,3,4,3,4,3,1,1,2,2,2,1,2,2,2,2,2,2,2,
2,3,3,1,1,2,2,1,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,
2,3,3,3,3,4,3,4,3,4,4,1,1,2,2,2,1,2,2,2,2,2,2,3,2,3,3,1,1,2,2,1,1,2,2,2,2,3,2,3,
2,3,3,1,1,2,2,1,1,2,2,1,1,1,2,2,2,3,2,2,2,1,2,3,2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,1,
2,3,3,1,1,2,2,1,2,3,2,3,3,1,2,3,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,
2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,3,2,3,3,3,3,3,3,4,3,4,2,1,1,2,2,2,
2,3,3,3,3,4,3,4,3,4,4,1,1,2,2,2,1,2,2,2,2,2,2,3,2,3,3,1,1,2,2,1,3,4,4,4,4,5,2,3,
2,3,3,3,3,4,2,1,3,4,4,1,1,2,2,2,4,5,2,3,4,1,5,5,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,
2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,
3,4,3,3,3,2,4,4,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,2,3,3,3,3,4,2,3,
2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,3,3,4,4,3,3,3,3,4,3,4,2,3,4,3,4,5,2,3,3,3,3,4,3,4,
3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,4,5,5,2,2,3,3,3,
2,3,3,3,3,3,3,4,3,4,4,2,2,3,3,2,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,
3,4,3,3,3,2,3,4,3,4,4,4,4,5,3,4,3,4,3,3,3,4,4,2,3,4,4,2,2,3,3,2,4,5,3,4,4,2,5,5,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,
4,5,5,3,3,4,4,3,3,4,4,3,3,3,4,4,4,5,4,4,4,3,5,5,3,4,4,4,4,5,4,5,4,5,5,4,4,4,5,5,
4,5,5,5,5,6,1,2,1,2,2,2,2,3,2,3,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,
2,3,2,3,3,3,2,3,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,2,3,
2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,2,2,3,3,2,2,2,3,3,3,4,2,3,3,2,4,3,2,3,3,3,3,4,3,4,
3,4,4,3,3,3,4,3,3,4,4,3,3,3,1,2,1,2,2,2,2,3,2,3,1,2,2,2,2,3,2,3,2,3,2,2,2,2,2,3,
2,3,3,3,3,3,1,2,1,2,2,2,2,3,1,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,
2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,3,4,3,3,3,2,4,4,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,1,2,1,2,2,2,2,3,2,3,1,2,2,2,2,3,2,3,
2,3,2,2,2,2,3,3,2,3,3,3,3,3,1,2,1,2,2,2,2,3,1,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,
2,3,3,3,3,4,1,2,1,2,2,2,2,3,1,2,1,2,2,2,2,3,1,2,1,2,1,2,2,2,2,2,2,3,3,2,2,2,2,3,
2,3,1,2,2,2,3,2,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,2,3,2,3,3,3,3,2,1,2,
2,3,3,3,3,4,1,2,1,2,2,2,2,3,1,2,2,3,3,2,2,3,3,2,3,4,1,2,2,2,3,2,2,3,3,3,3,4,3,4,
3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,4,5,5,2,2,3,3,3,
2,3,3,3,3,3,3,4,3,4,4,2,2,3,3,2,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,2,3,
2,3,3,3,3,2,3,4,2,3,3,3,3,4,3,4,3,4,3,3,3,3,4,2,3,4,4,2,2,3,1,2,1,2,2,2,2,2,2,3,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,1,2,1,2,2,2,2,3,2,3,1,2,2,2,2,3,2,3,
2,3,2,2,2,2,3,3,2,3,3,3,3,3,1,2,1,2,2,2,2,3,1,2,3,4,4,4,4,5,4,5,4,5,5,2,2,3,3,3,
2,3,3,3,3,3,3,4,3,4,4,2,2,3,1,2,3,4,4,4,4,5,1,2,1,2,2,2,2,3,2,2,4,5,5,2,2,3,3,3,
4,5,1,2,5,2,5,6,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,
2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,3,4,3,3,3,2,4,4,2,3,3,3,3,4,3,4,
3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,3,
3,4,4,3,3,3,3,4,3,4,2,3,4,3,4,5,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,
3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,4,5,5,2,2,3,3,3,2,3,3,3,3,3,3,4,3,4,4,2,2,3,3,2,
2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,3,4,3,3,3,2,3,4,3,4,4,4,4,5,3,4,
3,4,3,3,3,4,4,2,3,4,4,2,2,3,3,2,4,5,3,4,4,2,5,5,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,
3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,4,5,5,3,3,4,4,3,3,4,4,3,3,3,4,4,
4,5,4,4,4,3,5,5,3,4,4,4,4,5,4,5,4,5,5,4,4,4,5,5,4,5,5,5,5,6,2,3,2,3,3,3,3,4,3,4,
2,3,3,3,3,4,3,4,3,4,3,3,3,3,4,4,3,4,4,4,4,4,2,3,2,3,3,3,3,4,2,3,2,3,3,3,3,4,3,4,
3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,3,
3,4,4,3,3,3,3,4,3,4,2,3,3,3,4,3,3,4,4,4,4,5,4,5,4,5,5,3,3,4,4,3,3,4,4,3,3,3,3,4,
3,4,4,4,4,3,2,3,3,4,4,4,4,5,2,3,2,3,3,3,3,4,2,3,4,5,5,3,3,4,4,3,4,5,2,3,5,3,5,6,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,
4,5,5,3,3,4,4,3,3,4,4,3,3,3,4,4,4,5,4,4,4,3,5,5,3,4,4,4,4,5,4,5,4,5,5,4,4,4,5,5,
4,5,5,5,5,6,3,4,3,4,4,4,4,5,3,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,4,4,5,5,4,4,4,4,5,
4,5,3,4,5,4,5,6,3,4,4,4,4,5,4,5,4,5,5,4,4,4,5,5,4,5,5,5,5,6,4,5,4,5,4,5,5,5,5,6,
4,5,5,5,5,6,5,6,5,6,6,1,1,2,2,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,1,2,2,2,2,3,2,3,
2,3,3,2,2,2,3,3,2,3,3,3,3,3,2,3,2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,
2,3,3,2,2,2,3,3,3,4,3,2,2,2,3,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,
2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,3,3,3,4,3,2,2,2,3,2,
2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,2,3,3,2,2,2,2,3,2,3,3,3,3,2,2,3,2,3,3,3,3,4,2,3,
2,3,2,3,3,3,3,2,3,4,4,2,2,3,3,2,3,4,2,3,4,2,3,4,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,
3,4,4,4,4,5,3,4,3,4,3,4,4,4,3,4,3,4,4,4,4,5,3,4,3,4,3,1,1,2,2,2,1,2,2,2,2,3,2,3,
2,3,3,2,2,2,3,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,2,3,3,2,2,2,2,3,2,3,2,2,2,2,3,2,
2,3,3,3,3,4,3,4,3,4,3,1,1,2,2,2,1,2,2,2,2,2,2,2,2,3,3,1,1,2,2,1,1,2,2,2,2,3,2,3,
2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,2,3,3,3,3,4,3,4,3,4,4,2,2,3,3,2,
2,3,3,2,2,2,3,3,3,4,3,3,3,2,4,4,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,
2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,3,3,4,4,3,3,3,3,4,3,4,2,3,4,3,4,5,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,
4,5,5,1,1,2,2,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,
2,3,3,2,2,2,2,3,2,3,2,3,3,2,3,4,2,3,3,3,3,4,3,4,3,4,3,1,1,2,2,2,1,2,2,2,2,2,2,2,
2,3,3,1,1,2,2,1,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,3,2,3,3,3,3,4,2,3,2,3,2,3,3,3,3,4,
2,3,3,3,3,4,3,4,3,4,4,1,1,2,2,2,1,2,2,2,2,2,2,3,2,3,3,1,1,2,2,1,1,2,2,2,2,3,2,3,
2,3,3,1,1,2,2,1,1,2,2,1,1,1,2,2,2,3,2,2,2,1,2,3,2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,1,
2,3,3,1,1,2,2,1,2,3,2,3,3,1,2,3,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,
2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,3,2,3,3,3,3,3,3,4,3,4,2,1,1,2,2,2,
2,3,3,3,3,4,3,4,3,4,4,1,1,2,2,2,1,2,2,2,2,2,2,3,2,3,3,1,1,2,2,1,2,3,3,3,3,4,2,3,
2,3,3,3,3,3,2,1,3,4,4,1,1,2,2,2,2,3,2,3,3,1,2,3,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,
3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,4,5,5,3,3,4,4,3,3,4,4,3,3,3,4,4,
4,5,4,4,4,3,5,5,3,4,4,4,4,5,4,5,4,5,5,4,4,4,5,5,4,5,5,5,5,6,2,3,2,3,3,3,3,4,3,4,
2,3,3,3,3,4,3,4,3,4,3,3,3,3,4,4,3,4,4,4,4,4,2,3,2,3,3,3,3,4,2,3,2,3,3,3,3,4,3,4,
3,4,4,3,3,3,4,4,3,4,4,4,4,5,2,3,2,3,3,3,3,4,2,3,2,3,3,3,3,4,2,3,2,3,2,2,2,3,3,3,
2,3,3,3,3,3,3,4,3,4,2,3,3,3,4,3,2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,3,3,4,4,3,3,3,3,4,
3,4,3,4,4,3,2,3,3,4,4,4,4,5,2,3,2,3,3,1,1,2,2,2,1,2,2,2,2,3,2,3,2,3,2,2,2,2,3,2,
2,3,3,3,3,4,3,4,3,4,4,3,3,3,4,4,3,4,4,4,4,5,3,4,3,4,3,4,4,4,4,5,3,4,4,4,4,5,4,5,
4,5,5,1,1,2,2,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,3,2,
2,3,3,2,2,2,2,3,2,3,2,3,3,2,3,4,2,3,3,3,3,4,3,4,3,4,3,1,1,2,2,2,1,2,2,2,2,2,2,2,
2,3,3,1,1,2,2,1,3,4,4,4,4,5,4,5,4,5,5,4,4,4,5,5,4,5,5,5,5,6,2,3,2,3,3,3,3,4,3,4,
2,3,3,3,3,4,3,4,3,4,3,3,3,3,4,4,3,4,4,4,4,4,2,3,2,3,3,1,1,2,2,2,3,4,4,4,4,5,4,5,
4,5,5,1,1,2,2,2,1,2,2,2,2,3,2,3,2,3,3,2,2,2,2,2,4,5,5,5,5,6,2,3,2,3,3,3,3,4,3,1,
4,5,5,1,1,2,2,2,5,6,2,3,5,1,6,12};
char s[14];
int main()
{
	cin >> n ;
	for(int i = 1 ; i <= n ; i ++ )
	{
		int v = 0;
		cin >> s + 1 ;
		for(int j = 0 ; j <= 11 ; j ++ )
		if(s[j + 1] == 'o')v|=(1 << j );
		printf("%d\n",ans[v]);
	}
}
```


---


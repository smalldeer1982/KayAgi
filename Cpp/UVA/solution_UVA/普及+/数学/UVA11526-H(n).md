# H(n)

## 题目描述

请求出该函数的返回值：

```cpp
long long H(int n) {
    long long res = 0;
    for (int i = 1;i <= n;i = i + 1) {
        res = (res + n / i);
    }
    return res;
}
```

## 样例 #1

### 输入

```
2
5
10```

### 输出

```
10
27```

# 题解

## 作者：peterwuyihong (赞：83)

我看题解里没有这么写的，就补一个

![](https://cdn.luogu.com.cn/upload/image_hosting/obdm4joa.png)

一目了然

不言而喻

$$
\sum_{i=1}^n\lfloor {n\over i}\rfloor=2\sum_{i=1}^{\lfloor\sqrt n\rfloor}\lfloor {n\over i}\rfloor-\lfloor\sqrt n\rfloor^2
$$
```cpp
int f(int n){
	int m=sqrt(n),ans=0;
	for(int i=1;i<=m;i++)ans+=n/i;
	return ans*2-m*m;
}
```


---

## 作者：cyffff (赞：29)

[$\text{Link}$](https://www.luogu.com.cn/problem/UVA11526)

$\text{upd2021.7.23}$：对某些地方进行修改。
## 题意
求
```cpp
long long H(int n){
	long long res=0;
	for( int i = 1; i <= n; i=i+1 ){
		res = (res + n/i);
	}
	return res;
}
```
的值。

多组数据。

$1\le T\le 10^3,1\le n<2^{31}$
## 思路
很明显，直接模拟题目给出的函数会 TLE。

我们理解一下题目给的代码，其实就是求
$$\sum\limits_{i=1}^n\left\lfloor\dfrac{n}{i}\right\rfloor$$

此时，我们需要引入算法：**整除分块**（又称数论分块、除法分块）。此算法可以快速求出形如
$$\sum\limits_{i=1}^nf(\left\lfloor\dfrac{n}{i}\right\rfloor)$$
的式子，在数论题目中有着广泛的用途。

对于一些情况，一段数满足
$$\left\lfloor\dfrac{n}{l}\right\rfloor = \left\lfloor\dfrac{n}{l+1}\right\rfloor = \left\lfloor\dfrac{n}{l+2}\right\rfloor = ... =  \left\lfloor\dfrac{n}{l+m}\right\rfloor = ... = \left\lfloor\dfrac{n}{r-1}\right\rfloor = \left\lfloor\dfrac{n}{r}\right\rfloor$$
这时候我们把这个值重复地加了几遍，浪费了时间。

我们可由向下取整的性质得：

$$\left\lfloor\dfrac{n}{l}\right\rfloor\leqslant\dfrac{n}{r}<\left\lfloor\dfrac{n}{l}\right\rfloor+1$$

化简得

$$r\leqslant\left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{l}\right\rfloor}\right\rfloor$$

$$r_{max}=\left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{l}\right\rfloor}\right\rfloor$$

所以对于上面这 $r-l+1$ 个相同的数它们的和为
$$(\left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{l}\right\rfloor}\right\rfloor-l+1)×\left\lfloor\dfrac{n}{l}\right\rfloor$$

分析一下时间复杂度，发现时间复杂度即对于 $n$，所有的 $\lfloor\frac n i\rfloor$ 的取值数量，可以知道，$\lfloor\frac n i\rfloor$ 可以取得 $1,2,\cdot\cdot\cdot,\sqrt n,\lfloor\frac n {\sqrt n}\rfloor,\lfloor\frac n {\sqrt n-1}\rfloor,\cdot\cdot\cdot,n$ 这 $O(\sqrt n)$ 种取值，即时间复杂度为 $O(T\sqrt n)$。

注意此题轻微卡常。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	
}
inline int h(int n){
    if(!n){
        return 0;
    }
	int res=0,j;
	for(register int i=1;i<=n;i=j+1){
		j=n/(n/i);
		res+=(j-i+1)*(n/i);
	}
	return res;
}
signed main(){
	int t,n;
	t=read();
	while(t--){
		n=read();
		printf("%lld\n",h(n));
	}
	return 0;
}
```
再见 qwq~

---

## 作者：Into_qwq (赞：11)

刚学完整除分块的蒟蒻来写题解了

不会整除分块看[这里](https://www.cnblogs.com/RadestionAdtinium/p/13194330.html)

如果看不了(或不想看)也没关系，就在这里讲讲

这题就相当于求这个柿子：$\boxed{\sum\limits_{i=1}^{n}\left\lfloor\dfrac{n}{i}\right\rfloor}$

很明显$O(n)$是可以求的，暴力地打上这样的代码：
```c++
#include<iostream>
using namespace std;
long long H(int n){
    long long res=0;
    for(int i=1; i<=n; ++i) 
        res+=n/i;
    return res;
}//题目给的函数
int main()
{
    long long n,t;
    cin>>t;
    while(t--){
        cin>>n;
        cout<<H(n)<<endl;
    }
}
```

不过，提交后，惨烈的TLE了

求的是$\left\lfloor\dfrac{n}{i}\right\rfloor$

因为是向下取整，所以有些值是一样的

比如$n=5$时，$\left\lfloor\dfrac{n}{3}\right\rfloor$和$\left\lfloor\dfrac{n}{4}\right\rfloor$和$\left\lfloor\dfrac{n}{5}\right\rfloor$的结果一样

不难发现，这些值是像块状一样分布的$qwq$

每一个值相同的块的$i$的最大值一定是$\left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{i}\right\rfloor}\right\rfloor$

可以写出以下代码qwq(附解释):

![](https://img2020.cnblogs.com/blog/2069905/202006/2069905-20200626181125159-1029113121.png)

那么时间复杂度呢？

解：$\left\lfloor\dfrac{n}{i}\right\rfloor$的取值最多只有$2\sqrt n$种，理由如下

当$1\leqslant i \leqslant \sqrt n$时，$i$的取值有$\sqrt n$种，则上述式子最多只有$\sqrt n$种取值
当$\sqrt n i \leqslant n$时，上述式子取值最多也有$\sqrt n$种
总共最多有$2\sqrt n$种取值

由于代码枚举了$2\sqrt n$次取值，复杂度便为$\sqrt n$

比暴力好了许多$qwq$

最后附一遍H函数的代码:
```c++
inline LL H(LL n){
    res=0;
    for(LL i=1;i<=n;i=j+1) j=n/(n/i),res+=(j-i+1)*(n/i);
    return res;
}
```

---

## 作者：IntrepidStrayer (赞：3)

~~[不要脸地推销一波](https://www.luogu.com.cn/blog/214437/shu-lun-fen-kuai)~~
## 题意

根据题目给的代码，不难看出这是让我们求：

$\sum\limits_{i=1}^{n}\lfloor \frac{n}{i}\rfloor$

## 题解
整除分块模板题。

一看数据范围，发现用暴力肯定会超时。我们发现加数中有许多是相同的，并且这些加数单调不增（即**相同加数必定在一起**）。如果找出每段相同加数的长度，就能很快得到答案。

也就是说，如果对于一个 $i$，能找出最大的 $j$ 使得 $\lfloor \frac{n}{i}\rfloor=\lfloor\frac{n}{j}\rfloor$ 
，这一段的和即为 $\lfloor\frac{n}{i}\rfloor(j-i+1)$。

根据向下取整的性质，可得 $\lfloor \frac{n}{i}\rfloor\le\frac{n}{j}<\lfloor \frac{n}{i}\rfloor+1$；

将前一个不等式变形，得 $j\le \frac{n}{\lfloor \frac{n}{i}\rfloor}$；

由于 $j$ 是正整数，可得 $j\le \lfloor\frac{n}{\lfloor \frac{n}{i}\rfloor}\rfloor$；

所以 $j$ 最大为 $\big\lfloor\frac{n}{\lfloor \frac{n}{i}\rfloor}\big\rfloor$。

时间复杂度为 $\mathcal{O}(\sqrt n)$。证明如下：

+ 当 $1\le i\le \sqrt n$ 时：$i$ 的取值有 $\sqrt n$ 种，所以此时 $\lfloor\frac{n}{i}\rfloor$ 的取值最多有 $\sqrt n$ 种。

+ 当 $\sqrt n< i\le n$ 时：$1\le\lfloor\frac{n}{i}\rfloor\le\sqrt n$，所以 $\lfloor\frac{n}{i}\rfloor$ 的取值最多有 $\sqrt n$ 种。

也就是说，$\lfloor\frac{n}{i}\rfloor$ 的取值最多有 $2\sqrt n$ 种，所以时间复杂度为 $\mathcal{O}(\sqrt n)$。

$T$ 组数据，时间复杂度 $\mathcal{O}(T\sqrt n)$

## 代码：
```cpp
q = read();
for(; q; --q) {
	ans = 0;
	n = read();
	for(i = 1; i <= n; i = j + 1) {
		j = n / (n / i);
		ans += (j - i + 1) * (n / i);
	}
	printf("%lld\n", ans);
}
```

---

## 作者：qwq自动机 (赞：2)

upd:

$2021.9.21$ 修了一些小锅和笔误

---
对此题的评价：挺板的一道数论分块，可以作为学会之后的练手题

## 题意简述

对于 $T$ 组数据，每组一个整数 $n$，求 $H(n)$ 的值。

其中 $T<1000, n$ 在 `int` 范围内（$-2^{31}\sim 2^{31}-1$）。

$H(n)$ 的定义如下：

```cpp
long long H(int n)
{
    long long res = 0;
    for (int i = 1; i <= n; i++)
    	res += n / i;
    return res;
}
```

---

简化一下题意，就是要快速求
$$
\sum_{i=1}^n\left\lfloor\dfrac ni\right\rfloor
$$
的值。多组数据。

## 思路

显然我们如果直接按照题意模拟的话肯定会 T。那么考虑一下我们要求的式子的性质。

我们首先打个表：

```cpp
int n = 10;
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= n / i; j++)
        std::cout << '*';
    std::cout << '\n';
}
```

实际上就是求 $i\in[1,n],\lfloor\frac ni\rfloor$ 然后画出来。得到的结果是这样的：

```plain
**********
*****
***
**
**
*
*
*
*
*
```

看到了吗？我们要求的式子的每一项 $\lfloor\frac ni\rfloor$ 呈一种块状分布（相同的数都是一块一块的）。所以暴力模拟慢就慢在对于 $\lfloor\frac ni\rfloor$ 相同的每一块都重复计算了一次，所以单次复杂度是 $O(n)$，在此题中无法承受。

那么我们既然已经知道了 $\lfloor\frac ni\rfloor$ 呈块状分布，为什么不考虑用这个性质优化计算呢？我们可以对于每一块，计算出块长 $\times$ 块中的值，然后累加到答案里面，这样就可以在单次 $O(\sqrt n)$ 的时间中算出所需的和！（关于单次 $O(\sqrt n)$ 的证明可以看上面 @[cyfff](365127) 的题解 qwq）。

好的，那么现在我们需要解决一个问题：块长如何计算，或者说，块的右端点如何确定？

我们设块的左右端点为 $[l,r]$，则我们可以知道 $\lfloor\frac nl\rfloor=\lfloor\frac nr\rfloor$，令 $k=$ 这个值。而我们由向下取整（$\lfloor x\rfloor$）的性质可以知道：

$$
\begin{array}{ll}
&\quad k\leq\frac nr< k+1\\
&\Rightarrow \frac n{k+1}<r\leq \frac nk\\
&\Rightarrow r\leq\dfrac n{\lfloor \frac nl\rfloor}\\
&\because r\in \mathbb N\\
&\therefore r_{\max}=\left\lfloor \dfrac n{\lfloor\frac nl\rfloor}\right\rfloor
\end{array}
$$

由于 $r$ 是我们要求的块右端点，所以我们应当将其取到 $\max$，所以我们就证明了块右端点就是 $\left\lfloor \dfrac n{\lfloor\frac nl\rfloor}\right\rfloor$。当然由于 $r\leq n$，所以我们求出的最终的 $r$ 就是 $\min(\left\lfloor \dfrac n{\lfloor\frac nl\rfloor}\right\rfloor, n)$。

那么我们就可以将我们所求的化简为：对于每个块，将块长 $\times$ 块值累加。我们可以证明单次求是 $O(\sqrt n)$ 的，所以总共就是 $O(T\sqrt n)$ 的，对于题目给出的数据范围（$T\leq 1000$，$n\in\mathbb Z\cap[-2^{31},2^{31})$）是可以通过的。

## code

有了思路就能够很容易的写出代码啦~所以我只实现一个优化后（$O(\sqrt n)$）的 `H` 函数，输入输出什么的就你们自己写吧。

C++：

```cpp
long long H(int n)
{
    long long res = 0;
    int l = 1, r;
    while (l <= n)
    {
        r = std::min(n / (n / l), n); // 计算右端点（注意 r <= n）
        res += (r - l + 1) * (n / l); // 累加块长 * 块值
        l = r + 1; // 挪到下一个块
	}
    return res;
}
```



Python：

```python
def H(n):
    res = 0
    l = 1
    r = 0
    while l <= n:
        r = min(n // (n // l), n)
        res += (r - l + 1) * (n // l)
        l = r + 1
    return res
'''
别想了，这个过不了的 qwq
本机测了一个极限数据（T=1000, n=INT_MAX），结果C++跑了 4s，python跑了近 1min……
虽然复杂度都是正确的 T sqrt(n)，但是 python 比 C++ 慢了不少 awa
'''
```

### 几句闲话

实际上，数论分块不只能解决本题，还可以解决几乎所有与 $\lfloor\frac ni\rfloor$ 相关的求和。形式化地，数论分块可以解决形如
$$
\sum^n_{i=1}f(\lfloor\frac ni\rfloor)
$$
的一系列问题。比如本题的 $f(x)=x$，[CQOI2007 余数求和](/problem/P2261)的 $f(x)$ 经过化简之后 $=k-ix$（当然此题的式子为 $\sum^n_{i=1}f(\lfloor\frac ki\rfloor)$ 并不是仅与一个 $n$ 有关）。

数论分块除了能够解决上述求和问题之外，还是莫比乌斯反演降低复杂度所必须的技巧。

所以，数论分块还算是挺重要的一个小 trick……？

---

## 作者：Insouciant21 (赞：2)

咋一看题目，居然给了函数 ~~(这不是很简单吗）~~

然后再一看这妥妥TLE啊

于是开始推：

一个整数 $n$

当 $n=5$ 时：

$$
\left\lfloor\dfrac{5}{1}\right\rfloor=5,
\left\lfloor\dfrac{5}{2}\right\rfloor=2,
\left\lfloor\dfrac{5}{3}\right\rfloor=1,
\left\lfloor\dfrac{5}{4}\right\rfloor=1,
\left\lfloor\dfrac{5}{5}\right\rfloor=1
$$

取得 $1$ 的个数为 $\left\lceil\dfrac{5}{2}\right\rceil=3$

易得到 $1$ 时的取值为 $\left\lceil\dfrac{n}{2}\right\rceil$

然后我们继续推其他值的个数：

当取值为$2$时，个数为 $\left\lfloor\dfrac{5}{2}\right\rfloor-\left\lfloor\dfrac{5}{3}\right\rfloor=2-1=1$

即当前数字的个数为 $\left\lfloor\dfrac{n}{i}\right\rfloor-\left\lfloor\dfrac{n}{i+1}\right\rfloor$

当 $n<0$ 时，结果为 $0$，因为题目中的 `H()` 函数中枚举变量从 $1$ 开始。

下面是AC代码

``` cpp
#include <bits/stdc++.h>

using namespace std;

long long n;
int T;

int main() {
    ios::sync_with_stdio(false);
    cin >> T;
    while (T--) {
        long long ans = 0;
        long long res = 2; // 第一次计算的是 2 的个数
        cin >> n;
        ans += ceil(n / 2.0); // 计算1的个数
        if (n < 0) { // n < 0 直接输出0
            cout << 0 << endl;
            continue;
        }
        for (long long i = n / 2; i >= 1;) {
            long long diff = floor(n / double(res)) - floor(n / double(res + 1)); // 计算当前结果个数
            ans += diff * res;
            i -= diff; // 在剩下的数中减去当前个数
            res = floor(n / double(i)); // 得到下一次的结果
        }
        cout << ans << endl;
    }
    return 0;
}
```


---

## 作者：Daidly (赞：1)

**准备**

求和符号：
$$\sum\limits_{i=1}^na_i=a_1+a_2+...+a_n$$

向下取整：
$$\left\lfloor\dfrac{1}{2}\right\rfloor=0,\left\lfloor-\dfrac{1}{2}\right\rfloor=-1$$

向上取整：
$$\left\lceil\dfrac{1}{2}\right\rceil=1,\left\lceil-\dfrac{1}{2}\right\rceil=0$$

**旅途的开始**

当我问你一个这样的问题：
$$\sum\limits_{i=1}^{10}{\left\lfloor\tfrac{10}{i}\right\rfloor}=?$$

列个表格试试：

$$\boxed{\left\lfloor\dfrac{10}{1}\right\rfloor=10},\boxed{\left\lfloor\dfrac{10}{2}\right\rfloor=5},\boxed{\left\lfloor\dfrac{10}{3}\right\rfloor=3},\boxed{\left\lfloor\dfrac{10}{4}\right\rfloor=2},\boxed{\left\lfloor\dfrac{10}{5}\right\rfloor=2},$$

$$\boxed{\left\lfloor\dfrac{10}{6}\right\rfloor=1},\boxed{\left\lfloor\dfrac{10}{7}\right\rfloor=1},\boxed{\left\lfloor\dfrac{10}{8}\right\rfloor=1},\boxed{\left\lfloor\dfrac{10}{9}\right\rfloor=1},\boxed{\left\lfloor\dfrac{10}{10}\right\rfloor=1}$$

如果我们把这些一个一个加起来，那会很慢，那该怎么办呢？

于是，观察表格可以发现，有一些答案和后面的答案一样（一段区间内一样）

那么我们就可以把 $1\sim 10$ 分个段：分别是 $1,2,3,4\sim 5,6\sim 10$

这样我们就只用计算 $5$ 次 $\left\lfloor\dfrac{10}{i}\right\rfloor$ 就行了。

那么，问题来了，如何确定答案相同的区间呢？

**公式推导**

$$\sum\limits_{i=1}^{n}{\left\lfloor\tfrac{n}{i}\right\rfloor}=?$$

（注：$n$ 为正整数）

假设我们已知某一个分块的左端点 $l$，要求解出该分块的右端点 $r$。设该分块的数值为 $k$，对于该分块中的每个数 $i$，有 $k=\left\lfloor\dfrac{n}{i}\right\rfloor=\left\lfloor\dfrac{n}{l}\right\rfloor$，即 $ik\leq n$，想一想就可以知道当 $i=r$ 时，也就是 $\max(rk)\leq n$ 为最大值。

所以，就可以发现：
$$r=\left\lfloor\dfrac{n}{k}\right\rfloor$$

又因为：
$$k=\left\lfloor\dfrac{n}{l}\right\rfloor$$

所以：
$$r=\left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{l}\right\rfloor}\right\rfloor$$

则，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}
int t,n;
signed main(){
	t=read();
	while(t--){
		n=read();
		int ans=0;
		for(int l=1,r;l<=n;l=r+1){
			r=n/(n/l);
			ans+=(r-l+1)*(n/l);
		}
		print(ans),puts("");
	}
	return 0;
}
```



------------

$\forall l\leq n$，寻找最大的 $r$，使得：

$$\left\lfloor \frac{n}{l}\right\rfloor=\left\lfloor\frac{n}{r}\right\rfloor$$

证 $r=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l}\right\rfloor}\right\rfloor$。

证明：

$$\left\lfloor\frac{n}{l}\right\rfloor\leq\frac{n}{l}$$

$$l=\left\lfloor\frac{n}{\frac{n}{l}}\right\rfloor \leq \left\lfloor\frac{n}{\left\lfloor\frac{n}{l}\right\rfloor}\right\rfloor$$

$$l_{\max}=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l}\right\rfloor}\right\rfloor=r$$

$\Box$

---

## 作者：Durancer (赞：1)

### 写在前面

整除分块其实是运用一段连续的序列在题目所给定的式子中所给出来的一些性质，将它分为一个一个的块进行集中处理，从而减少时间开销

### 思路

首先，可以看出是贡献值是向下取整的，很容易想到一个性质，假设当前枚举到 $x$ ，那么一定会存在一个最大的 $y$，使得：

$$\lfloor\frac{n}{x}\rfloor=\lfloor\frac{n}{x+1}\rfloor=\lfloor\frac{n}{x+2}\rfloor+…+\lfloor\frac{n}{y}\rfloor \ \ \text{成立}$$

那么考虑一下用不等式找出 $y$ 的最大值来。

$$\lfloor \frac{n}{x}\rfloor\leq \frac{n}{y}$$

$$y\leq\lfloor \frac{n}{\lfloor\frac{n}{x}\rfloor}\rfloor$$

由此得出：

$$y_{max}=\lfloor\frac{n}{\lfloor\frac{n}{x}\rfloor}\rfloor$$

那么这一段的贡献值为：

$$(y-x+1)\times \lfloor \frac{n}{x}\rfloor$$

考虑到 $n$ 是可能包含在最后一段符合这个性质的块中的位置，去一个 $\operatorname{min}$ 即可。

### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<map>
#include<algorithm>
#define int long long 
using namespace std;
int T;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-')
			f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<1)+(x<<3)+(s^'0');
		s=getchar(); 
	}
	return f*x;
}
int H(int n)
{
	// floor (n/l) <= n/r
	// r <=n/floor(n/l)
	int ans=0;
	int j;
	for(int i=1;i<=n;i=j+1)
	{
		j=n/(n/i);
		ans+=(min(j,n)-i+1)*(n/i);
	}
	return ans;
}
signed main()
{
	T=read();
	while(T--)
	{
		int opt=read();
		printf("%lld\n",H(opt));
	}
	return 0;
}
```


---

## 作者：CrTsIr400 (赞：1)

实际上这道题就是整除分块模板题。

题意：求 $\sum_{i=1} ^n \left \lfloor \frac{n}{i} \right \rfloor$ ，$n\le 10^9$ ，多组数据

暴力 $O(n)$ 显然不行，太慢了。

考虑如何优化：这个 $[1,n]$ 中必定存在 $\le \sqrt n$ 对 $[l,r]$ ，**使得对于这个子区间中的每个 $i$ ， $\left \lfloor \frac{n}{i} \right \rfloor$ 的值相等。**

证明至多 $\sqrt n$ 个？发现这样一个规律：

对于 $1\le i\le \sqrt n$ ，显然个数没有 $\sqrt n$ 个；

对于 $\sqrt n < i\le n$ ，可以证明后面的这些块个数也不会 $>\sqrt n$ 。因为分母越大，除出来的数就越容易重复。

比如 $10$，求出的整除分块序列就是：

|$1$|$2$|$3$|$4$|$5$|$6$|$7$|$8$|$9$|$10$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$10$|$5$|$3$|$2$|$2$|$1$|$1$|$1$|$1$|$1$|

接下来就是一个个跳 $l,r$ 的事，**这才是整除分块的精髓**。

如何计算 $r$ 呢？

发现 $\left \lfloor \frac{n}{l} \right \rfloor =\left \lfloor \frac{n}{r} \right \rfloor$，但是 $\left \lfloor \frac{n}{l} \right \rfloor =\left \lfloor \frac{n}{r+1} \right \rfloor+1$

嗯？发现规律 $r=\frac{n}{\left \lfloor \frac{n}{l} \right \rfloor} $ 。套进去，发现结果是对的！！！

为什么呢？我们考虑扒开除法的性质来搞♂一波。

可以证明：对于每个 $1\le i\le n$ ，发现都有 $n\div (\left \lfloor \frac{n}{i} \right \rfloor+1)=\left \lfloor \frac{n}{i} \right \rfloor-1 $ 。

实践出真知：$100\div 20=5$ ，但是 $100\div 21=4$ 。

用自然语言描述的话，你就会发现，除法的除数如果再加上 $1$ 的话，商会减少 $1$ 。**但是除法的商减少 $1$ 后，除数减少的数大于等于 $1$ 。** 

于是本题利用商的性质，巧妙地得到了正解的结论。

```cpp
long long calc(long long x)
{
	long long res=0;
	for(long long l=1,r=1;l<=x;l=r+1)
	{
		r=x/(x/l);
		res+=(r-l+1)*(x/l);
	}
	return res;
}
```

---

## 作者：_ReVeLuv (赞：1)

[UVa11526 H(n)](https://www.luogu.com.cn/problem/UVA11526)

整除分块。

先给约定，这里的 $\lfloor x\rfloor$ 表示对 $x$ 进行下取整操作。

对给出的代码进行观察，可以轻易发现他在求 $\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$。由于这个式子长得就像不能再进行推导的样子，显然应该考虑如何进行求值。

通过列表可以发现：$\lfloor\frac{n}{i}\rfloor$ 随着 $i$ 的增长单调下降，并且在一定的值域内取值相同。

举一个简单的例子，$\lfloor\frac{12}{5}\rfloor=\lfloor\frac{12}{6}\rfloor=2$；$\lfloor\frac{12}{7}\rfloor=\lfloor\frac{12}{8}\rfloor=\lfloor\frac{12}{9}\rfloor=\lfloor\frac{12}{10}\rfloor=\lfloor\frac{12}{11}\rfloor=\lfloor\frac{12}{12}\rfloor=1$。

这个时候你在计算其对答案的贡献的时候，就可以将其一起算，也就是我们用了类似于分块的思想，对整个块进行操作。

对于这道题，显然对答案的总贡献是每一个块的相同答案 $\times$ 每一个块的大小。

相同答案很好得出，问题在于每一个块的长度。

对于每一个块，我们定义他的左边界为 $l$，右边界为 $r$。显然 $\lfloor\frac{n}{l}\rfloor=\lfloor\frac{n}{r}\rfloor$。那么这个块的长度 $r-l+1$ 乘上贡献 $\lfloor\frac{n}{l}\rfloor$ 就是这一个块的总贡献。

新的问题产生了。怎么通过前一个块的边界计算得到新的一个块的边界？

假设新的块的边界为 $l'$，$r'$。

因为
$$\lfloor\frac{n}{l}\rfloor=\lfloor\frac{n}{r}\rfloor$$

所以 $\large l'=r+1=\frac{n}{\lfloor \frac{n}{l}\rfloor}+1$。

这个问题就解决了。

核心代码长成下面这个样子：

```cpp
for (int l = 1, r; l <= n; l = r + 1) {
	r = n / (n / l);
	ans += (n / l) *  (r - l + 1);
}
```

---

## 作者：子翮 (赞：0)

### 前言

一道最弱版的整除分块问题

### 具体分析

考虑题目中给出的代码：

```cpp
long long H(int n){
     long long res = 0;
    for( int i = 1; i <= n; i=i+1 ) {
        res = (res + n/i); 
     }
    return res;
}
```

人脑模拟一下，不难看出:

$$ H(n) = \sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$$

直接分块即可，复杂度 $O(T\sqrt{n})$

代码：

```cpp
#include<iostream>
#include<cstdio>
#define R register
typedef long long ll;
using namespace std;
ll T,n;
ll H(ll n)
{
	ll res=0;
	for(R ll l=1,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		res+=(r-l+1)*(n/l);
	}
	return res;
}
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		printf("%lld\n",H(n));
	}
	return 0;
}


```



---


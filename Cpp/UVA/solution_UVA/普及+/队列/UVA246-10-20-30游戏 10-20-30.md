# 10-20-30游戏 10-20-30

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=4&page=show_problem&problem=182

[PDF](https://uva.onlinejudge.org/external/2/p246.pdf)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA246/750b0d9c12dd35c566d25df6556f0004e31f9989.png)

## 样例 #1

### 输入

```
2 6 5 10 10 4 10 10 10 4 5 10 4 5 10 9 7 6 1 7 6 9 5 3 10 10 4 10 9 2 1
10 1 10 10 10 3 10 9 8 10 8 7 1 2 8 6 7 3 3 8 2
4 3 2 10 8 10 6 8 9 5 8 10 5 3 5 4 6 9 9 1 7 6 3 5 10 10 8 10 9 10 10 7
2 6 10 10 4 10 1 3 10 1 1 10 2 2 10 4 10 7 7 10
10 5 4 3 5 7 10 8 2 3 9 10 8 4 5 1 7 6 7 2 6 9 10 2 3 10 3 4 4 9 10 1 1
10 5 10 10 1 8 10 7 8 10 6 10 10 10 9 6 2 10 10
0```

### 输出

```
Win : 66
Loss: 82
Draw: 73```

# 题解

## 作者：_CHO (赞：2)

来一发“最劣解

~~稳坐提交记录最优解排序倒数第一~~




------------

首先提醒注意一点

> Continue until no more sets of three can be picked up from the pile.

-------

模拟题，思路很显然，我们需要使用双端队列来维护每一个牌堆。

我们先不去考虑结果为 $Draw$ 的情况，这样做法是很显然的。直接暴力发牌，暴力检验能否凑成 $10$ 的倍数。


下面我们考虑如何去判 $Draw$ 。一个显而易见的做法是把前面出现过的每一个状态存起来，把所有前面的状态和当前状态对比，如果某一状态和当前状态相同，则认为出现了循环。

我们明确一个状态有哪些量

1. 手牌

2. 所有 $7$ 个牌堆

3. **当前在处理第几个牌堆**


不幸的是，如果每次我们都一一枚举状态会 T 飞。所以我们选择使用一个 `map` 来维护每一个状态，这样直接判断当前状态是否存在过即可。


关于 `map` 的具体实现，我选择用 `map` 直接维护结构体。所以需要重载小于号（ `map` 的本质是平衡树）。由于我们并不真的关心两个状态的大小关系，因此可以随意地制定比较法则，只需要能够区分出不同的两个状态即可。

```cpp


#include <bits/stdc++.h>
using namespace std;
struct State{
	int i;
	deque <int> Q,q[7];
	friend bool operator < (State x,State y){
		if(x.Q!=y.Q) return x.Q<y.Q;
		for(int i=0;i<7;++i){
			if(x.q[i]!=y.q[i]) return x.q[i]<y.q[i];
		}
		return x.i<y.i;
	}
};
int n,cnt;
deque <int> Q,q[7];
map <State,bool > V;
bool check(int i){
	int tmp=q[i].front();
	q[i].pop_front();
	if((tmp+q[i].front()+q[i].back())%10==0){
		Q.push_back(tmp);
		Q.push_back(q[i].front());
		Q.push_back(q[i].back());
		q[i].pop_front();
		q[i].pop_back();
		return true;
	}
	q[i].push_front(tmp);
	tmp=q[i].back();
	q[i].pop_back();
	if((q[i].front()+tmp+q[i].back())%10==0){
		Q.push_back(q[i].front());
		Q.push_back(q[i].back());
		Q.push_back(tmp);
		q[i].pop_front();
		q[i].pop_back();
		return true;
	}
	int ttmp=q[i].back();
	q[i].pop_back();
	if((tmp+ttmp+q[i].back())%10==0){
		Q.push_back(q[i].back());
		Q.push_back(ttmp);
		Q.push_back(tmp);
		q[i].pop_back();
		return true;
	}
	q[i].push_back(ttmp);
	q[i].push_back(tmp);
	return false;
}

bool Win(){
	for(int i=0;i<7;++i){
		if(q[i].size()) return false;
	}
	return true;
}
bool Loss(){
	if(!Q.size()) return true;
	else return false;
}
bool Draw(int ord){
	State tmp;
	tmp.i=ord;
	tmp.Q=Q;
	for(int i=0;i<7;++i){
		tmp.q[i]=q[i];
	}
	if(V[tmp]) return true;
	V[tmp]=1;
	return false;
}

void init(){
	cnt=7;
	V.clear();
	Q.clear();
	for(int i=0;i<7;++i) q[i].clear();
}
int main(){
	while(cin>>n&&n){
		init();
		Q.push_back(n);
		for(int i=1;i<=51;++i){
			cin>>n;
			Q.push_back(n);
		}
		for(int i=0;i<7;++i){
			q[i].push_back(Q.front());
			Q.pop_front();
			Draw(i);
		}
		for(int i=0;true;i++,i%=7){
			if(Win()){
				printf("Win : %d\n",cnt);
				break;
			}
			if(Loss()){
				printf("Loss: %d\n",cnt);
				break;
			}
			if(!q[i].size())continue;
			q[i].push_back(Q.front());
			Q.pop_front();
			while(q[i].size()>=3&&check(i));
			++cnt;
			if(Draw(i)){
				printf("Draw: %d\n",cnt);
				break;
			}
		}
	}
	return 0;
}


```







---

## 作者：Chouquet (赞：2)

花了近1个半小时写完这道模拟……

因为既可以把牌放在顶部，又可以把牌放在底部，所以可以将每个牌堆用一个双端队列维护，然后按照题意模拟。但是还要判断循环游戏的情况，而且每一局游戏是由8个双端队列构成的。

这种情况可以搞成字符串处理，也可以自己手写Hash处理。然而，**map/set中是可以以vector为类型的，而vector是可以直接比较大小的。** 因此在vector中存放双端队列，用map/set记录局面即可。

代码（ ~~建议谨慎观看以防头晕~~ ）：

```cpp
#include <cstdio>
#include <deque>
#include <vector>
#include <map>
typedef std::vector<std::deque<int> > State;
//用vector表示牌堆，按照先手牌再桌面上的顺序存放
std::map<State, bool> t;//用map判重
std::deque<int> hand, pile[7];//hand表示手牌，pile表示7堆牌
bool record() {//记录局面，如果重复返回0
    State tmp;
    tmp.push_back(hand);
    for (int i = 0; i < 7; i++)
        tmp.push_back(pile[i]);
    if (t[tmp])
        return 0;
    t[tmp] = 1;
    return 1;
}
bool check(std::deque<int> &q) {//判断是否满足1，2，3条件，不满足返回0
    if (q.size() < 3)
        return 0;//这个判断一定要有！（我因为一开始没写这个判断结果调了好长时间）
    int first = q.front(), last = q.back();
    q.pop_front(), q.pop_back();
    if (first + q.front() + last == 10 || first + q.front() + last == 20 || first + q.front() + last == 30) {//1
        hand.push_back(first);
        hand.push_back(q.front());
        hand.push_back(last);
        q.pop_front();
        return 1;
    }
    if (first + q.back() + last == 10 || first + q.back() + last == 20 || first + q.back() + last == 30) {//2
        hand.push_back(first);
        hand.push_back(q.back());
        hand.push_back(last);
        q.pop_back();
        return 1;
    }
    q.push_front(first);
    first = q.back();
    q.pop_back();
    //注意还原，下同
    if (first + q.back() + last == 10 || first + q.back() + last == 20 || first + q.back() + last == 30) {//3
        hand.push_back(q.back());
        hand.push_back(first);
        hand.push_back(last);
        q.pop_back();
        return 1;
    }
    q.push_back(first), q.push_back(last);
    return 0;
}
int change(int &pos) {//发牌
    while (pile[pos].empty())
        pos = (pos + 1) % 7;//找到第一个非空的牌堆
    pile[pos].push_back(hand.front()), hand.pop_front();//放牌
    if (!record())
        return -1;//平局
    if (pile[pos].size() > 2)
        while (check(pile[pos]));//题目说了要多次查看
    if (hand.empty())
        return 0;//手牌为空就输了
    return 1;//这个返回值是凑数的，看看就好
}
int main() {
    int card;
    while (scanf("%d", &card) != EOF) {
        if (!card)
            break;
        hand.push_back(card);
        for (int i = 2; i <= 52; i++) {
            scanf("%d", &card);
            hand.push_back(card);
        }
        for (int i = 0; i < 7; i++)//先发每个牌堆1张牌
            pile[i].push_back(hand.front()), hand.pop_front();
        record();//记录初始局面
        int times = 0, pos = 0;
        while (1) {
            bool ok = 1;
            for (int i = 0; i < 7; i++)
                if (!pile[i].empty())
                    ok = 0;//这个才是真正判断赢的
            if(ok) {
                printf("Win : %d\n", times+7);
                break;
            }
            int c = change(pos);
            if (c == -1) {
                printf("Draw: %d\n", times+7);//算上前面7次发牌但不算当前这局
                break;
            }
            else if (!c) {
                printf("Loss: %d\n", times + 8);//算上前面7次发牌和当前这局
                break;
            }
            ++times, pos = (pos + 1) % 7;
        }
        //清空
        hand.clear();
        for (int i = 0; i < 7; i++)
            pile[i].clear();
        t.clear();
    }
    return 0;
}
```

---

## 作者：qwerta (赞：2)

直接模拟就行了。

其中判重用了hash，就是把当前桌面上的局面从左往右一排一排压进去，再把牌堆里的压进去，中间插些奇怪的东西代表间隔。

~~大佬都觉得这是黄题诶qwq~~

```
/*
qwerta 
UVA246 10-20-30 Accepted 
代码 C++，1.85KB
提交时间 2018-11-05 16:09:12
耗时/内存 0ms, 0KB
*/
#include<iostream>
#include<cstring>
#include<cstdio>
#include<map>
using namespace std;
int a[8][53];//桌面
int toa[8];//每列的top
int q[10003];//牌堆
int he,ta;
const int mac=10000;//循环队列
inline int inc(int &x)//++x操作
{
    x++;
    if(x>mac)x=1;
    return x;
}
bool check(int i)
{
    if(toa[i]<3)return 0;
    //然后一种一种情况去判
    int x;
    x=a[i][1]+a[i][2]+a[i][toa[i]];
    if(x==10||x==20||x==30)
    {
        q[inc(ta)]=a[i][1];
        q[inc(ta)]=a[i][2];
        q[inc(ta)]=a[i][toa[i]];
        for(int j=1;j<=toa[i]-3;++j)
        a[i][j]=a[i][j+2];
        toa[i]-=3;
        return 1;
    }
    x=a[i][1]+a[i][toa[i]-1]+a[i][toa[i]];
    if(x==10||x==20||x==30)
    {
        q[inc(ta)]=a[i][1];
        q[inc(ta)]=a[i][toa[i]-1];
        q[inc(ta)]=a[i][toa[i]];
        for(int j=1;j<=toa[i]-3;++j)
        a[i][j]=a[i][j+1];
        toa[i]-=3;
        return 1;
    }
    x=a[i][toa[i]-2]+a[i][toa[i]-1]+a[i][toa[i]];
    if(x==10||x==20||x==30)
    {
        q[inc(ta)]=a[i][toa[i]-2];
        q[inc(ta)]=a[i][toa[i]-1];
        q[inc(ta)]=a[i][toa[i]];
        toa[i]-=3;
        return 1;
    }
    return 0;
}
bool sf[8];//表示各列有没有拿空
#define ULL unsigned long long
map<ULL,bool>mp;//记录判重用的hash
const int p=11;
bool pc()
{
    ULL h=0;
    for(int i=1;i<=7;++i)
    {
        for(int j=1;j<=toa[i];++j)
        h=h*p+a[i][j];
        h=h*p+19260817;//1******7代表这里有个间隔
    }
    int i=he;
    while(i!=ta)
    {
        h=h*p+q[inc(i)];//把队列里的也压进去
    }
    if(mp.find(h)!=mp.end())//如果存在当前局面说明平局
    return 1;
    mp[h]=1;
    return 0;
}
int main()
{
    //freopen("a.in","r",stdin);
    //freopen("game.out","w",stdout);
    int n=52;
    while(1)
    {
        he=0,ta=0;
        memset(toa,0,sizeof(toa));
        memset(sf,0,sizeof(sf));
        //读入，压队列
        for(int i=1;i<=52;++i)
        {
            int x;
            scanf("%d",&x);
            if(x==0)return 0;
            q[inc(ta)]=x;
        }
        int t=0,pos=0;//t:时间 pos:当前队列
        int res=7;//res:剩余非空列数
        int flag=0;
        while(he!=ta&&!flag)
        {
            t++;
            do{pos++;if(pos>7)pos=1;}while(sf[pos]);
            int x=q[inc(he)];
            a[pos][++toa[pos]]=x;//放牌
            while(check(pos));//抽牌
            if(pc()){printf("Draw: %d\n",t);flag++;continue;}//如果重复了输出draw
            if(toa[pos]==0)//如果空了就标记
            {
                sf[pos]=1;
                res--;
                if(!res){printf("Win : %d\n",t);flag++;continue;}
            }
        }
        if(!flag)
        printf("Loss: %d\n",t);
    }
    return 0;
}
```
最后欢迎未来的我校小学弟们来参观这道题。

当教练给你们这套noip2007模拟题的时候已经快noip了，不管这套sb题你们考的怎么样，都祝你们noip rp++/来自AFO老学姐的祝福❤

---


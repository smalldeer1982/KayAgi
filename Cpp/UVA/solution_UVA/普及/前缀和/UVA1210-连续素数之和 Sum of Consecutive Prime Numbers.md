# 连续素数之和 Sum of Consecutive Prime Numbers

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=247&page=show_problem&problem=3651

[PDF](https://uva.onlinejudge.org/external/12/p1210.pdf)

# 题解

## 作者：Eleveslaine (赞：5)

实际难度：橙。

用筛子筛出 $[1,10^4]$ 的质数和质数前缀和，这样可以 $O(1)$ 求出第 $l$ 个到第 $r$ 个质数的和。

枚举区间端点 $[l,r]$，设这段质数的和是 $s$，这就意味着 $s$ 有一种方案作为连续的从 $l$ 到 $r$ 的质数之和，因此 $s$ 的答案加一。查询的时候直接输出即可。  
复杂度：预处理 $O(w^2)$，其中 $w$ 是 $[1,10^4]$ 的质数个数，不到 $2000$。单次询问 $O(1)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e4+5;
bitset <maxn> vis;
int prime[maxn],m,sum[maxn],ans[maxn];
inline void primes()
{
    for(int i=2;i<=1e4;++i)
    {
        if(!vis[i])
        {
            prime[++m]=i;
            sum[m]=sum[m-1]+prime[m];
        }
        for(int j=i*i;j<=1e4;j+=i)
            vis[j]=1;
    }
}
int n;
int main()
{
    primes();
    for(int i=1;i<=m;++i)
        for(int j=i;j<=m;++j)
        {
            int s=sum[j]-sum[i-1];
            if(s>=1 && s<=1e4)
                ans[s]++;
        }
    while(1)
    {
        cin >> n;
        if(n==0)
            break;
        cout << ans[n] << endl;
    }
    return 0;
}
```

---

## 作者：littleqwq (赞：4)

### 题目名称：连续素数之和

### 所用算法：欧筛 + 双指针

为了代码的严谨性，我们尽量避免打表。

### 主要思路：

首先先用优化的欧几里得算法来找出所有的质数，虽然可以打表，但不建议，因为最好像这种题练习筛选质数。

接着因为这道题是不固定数量输入的，所以我们要用 while 循环输入，因为题目说输到是 $0$ 为止，还有一个要满足的条件就是输入的变量不为 $0$。

接着就是双指针了，我们在 for 循环里定义两个变量 $i,j$，表示在 $[i,j]$ 的区间内找。

首先先特判质数本身不能已经比总和大，如果是，把直接退出循环了，接着就是定义一个小的 $sum$ 要加上左指针指的质数，质数小到大排列后用 while 移动右指针直到 $sum\ge$ 总和并且 $j<i$ 的条件不满足，然后再看 $sum$ 和 $n$ 相不相等，相等就继续加，重复即可，最后输出答案即可。

至于双指针为什么这么做因为如果 $sum<n$ 的时候，由于质数按从大到小的顺序存的，所以右边界向前，左边界不变，相反情况大于，左边界向前，右边界不动要把前面的上次左边界的数删了，当然左右边界在同一个位置也是存在的。

### 参考代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N=400000;//为了即使数据量大，也使用方便，也可以写作define N 400000
int prime[N+5],cnt;//记录质数的数组多开防越界
bool is_prime[N+5];//判断质数出现的函数
void get_prime(){//欧筛函数
	for(int i=2;i<=N;i++){
		is_prime[i] = 1;
	}
	for(int i=2;i<=N;i++){
		if(is_prime[i] == 1){
			prime[++cnt] = i;
		}
		for(int j=1;j<=cnt&&prime[j] * i<=N;j++){
			is_prime[prime[j]*i] = 0;
			if(i%prime[j] == 0){
				break;
			}
		}
	}
	return;
}
int n,m;
int main(){
	get_prime();
	while(cin>>n){
    if(n==0){
    	return 0;
    }
		int sum = 0,ans = 0;//初始化sum为质数总和，ans为总和为n的方案数
		for(int i=1,j=1;i<=cnt;i++){//双指针
			if(prime[j] > n){//如果质数原本就比总和大，直接break跳出循环
				break;
			}
			sum=sum+prime[i];//左指针
			while(sum>n&&j<i){
				sum=sum-prime[j];//右指针
				j++;//右指针移位
			}
			if(sum == n){//如果相等那么方案数加1
				ans++;
			}
		}
		cout<<ans<<'\n';//输出，别忘换行
	}
	return 0;
}
``

---

## 作者：二叉苹果树 (赞：1)

注意到本题的数据范围非常小，正整数 $x \le 10000$。预处理筛出其中的质数后，发现质数实际上也只有 $1229$ 个。

对这些质数进行前缀和再 $\mathcal{O} \left(n^2\right)$ 暴力枚举两端所有端点计算区间和，然后再把以这些以区间和为下标的统计数组累计即可。

```cpp
#include <bits/stdc++.h>
#define maxn 10005

int tot, vis[maxn];
std::map<int, int> t;
int prime[maxn], s[maxn], x;

int main()
{
    int n = 10000;
    for (int i = 2; i <= n; i++)
    {
        if (!vis[i])
            prime[++tot] = i;
        for (int j = 1; j <= tot && i * prime[j] <= n; j++)
        {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0)
                break;
        }
    }
    for (int i = 1; i <= tot; i++)
        s[i] = s[i - 1] + prime[i];
    for (int i = 1; i <= tot; i++)
        for (int j = i; j <= tot; j++)
            t[s[j] - s[i - 1]]++;
    std::cin >> x;
    while (x != 0)
    {
        std::cout << t[x] << std::endl;
        std::cin >> x;
    }
    return 0;
}
```


---

## 作者：COsm0s (赞：1)

## 题意

给定数 $x$，询问有多少个连续质数序列和等于 $x$。

## 思路

筛素数 + 前缀和。

将 $1$ 到 $20000$ 的素数和其前缀和预处理出来，记为桶 $p$，再进行循环，判断是否有 $i,j$，使得 $p_i-p_j=n$，若有，则累加答案。

复杂度为 $O(w^2n)$，其中 $w$ 为 $20000$ 以内素数的个数，即 $2262$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
bool p[20005];
int k = 0;
int c[20005], n;
inline void prime() {
	p[1] = p[0] = 1;
	for(int i = 2; i <= 20000; i ++)
		if(!p[i])
			for(int j = 2; i * j <= 20000; j ++)
				p[i * j] = 1;
}
inline void sum() {
	for(int i = 1; i <= 20000; i ++)
		if(!p[i]) c[++ k] = c[k - 1] + i;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	prime();
	sum();
	while(cin >> n && n)  {
		int ans = 0;
		for(int i = 1; i <= k; i ++)
			for(int j = i; j <= k; j ++)
				if(c[j] - c[i - 1] == n) ++ ans;
		cout << ans << '\n';
	}
	return 0;
}
```


---

## 作者：yoyiETO (赞：1)

我看大家用的都是埃氏筛法,不过有些人可能没学过,所以介绍一种普通算法。

首先看这一题的数据范围:n<=10000

可以想到O(n²),但是题目有多组数据,所以至少需要O(n sqrt n).

实现方法:
1.判断1到10000中的素数,用数组存起来.
```cpp
bool prime(int n)
{
	if(n<2) return 0;
   for(int i=2;i<=sqrt(n);i++)
		if(n%i==0) return 0;
	return 1;
}
for(int i=1;i<=10000;i++)
   if(prime(i)) ok[i]=1;
```

2.使用前缀和,算出前i个素数的和sum[i],第i到j个素数和=sum[j]-sum[i-1].
```cpp
for(int i=1;i<=10000;i++)
    	if(ok[i])
    		sum[++t]=sum[t-1]+i;
```
3.枚举(代码略)

最后给出AC代码:
```
#include<bits/stdc++.h>
using namespace std;
int x,t,ans,sum[10001];
bool ok[10001];
bool prime(int n)
{
   if(n<2) return 0;
   for(int i=2;i<=sqrt(n);i++)
	if(n%i==0) return 0;
   return 1;
}//素数判定
int main()
{
   ios::sync_with_stdio(0);//输入输出优化
   for(int i=1;i<=10000;i++)
       if(prime(i)) ok[i]=1;//记录,O(n sqrt n)
   for(int i=1;i<=10000;i++)
       if(ok[i])
    	   sum[++t]=sum[t-1]+i;
   while(cin>>x&&x)
   {
      ans=0;
      for(int i=1;i<=t;i++)
      for(int j=i;j<=t;j++)
    	 if(sum[j]-sum[i-1]==x)
    	   ans++;
      cout<<ans<<"\n";
   }
   return 0;
}
```

---

## 作者：_lxy_ (赞：0)

### 题意
给你一个数，询问有多少个连续质数序列和等于该数。
### 分析
首先打一个素数表，计算每一段素数的和，用一个数组记录每一个和有多少段连续的素数和能凑成，预处理好每一个和对应的答案，直接输出即可。时间复杂度： $O(n^2)$ 。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e4+7;
int n,ans[MAXN],pre[MAXN];
vector<int>prime;
bool isprime[MAXN];
void sieve()
{
    for(int i=0;i<=MAXN;i++)
    {
        isprime[i]=true;
    }
    isprime[0]=isprime[1]=false;
    for(int i=2;i<=MAXN;i++)
    {
        if(isprime[i])
        {
            for(int j=2*i;j<=MAXN;j+=i)
            {
                isprime[j]=false;
            }
        }
    }
}
int mp[MAXN*MAXN];
int main()
{
    sieve(); //埃筛
    int i,j,k;
    for(i=0;i<=MAXN;i++)
    {
        if(isprime[i]) prime.push_back(i); //打素数表
    }
    pre[0]=prime[0];
    int m=prime.size();
    for(i=1;i<m;i++)
    {
        pre[i]=pre[i-1]+prime[i]; //p[i]表示前i个素数的和
    }
    for(i=0;i<m;i++)
    {
        for(j=i;j<m;j++)
        {
            int x=pre[j]-pre[i-1]; //从第i个素数到第j个素数的和
            mp[x]++; //mp[x]表示和为x的连续素数的段数
        }
    }
    while(~scanf("%d",&n)&&n)
    {
        printf("%d\n",mp[n]);
    }
    return 0;
}
```


---

## 作者：abjfj (赞：0)

尺取法+质数打表

打表这边用的是欧拉晒qwq

code

```cpp
#include<iostream>
#include<cstdio>
#define maxn 10001
using namespace std;
int primes[maxn],v[maxn],cnt = 0;
int main()
{
	int n = 10000;
	for(int i = 2; i <= n; i++)
	{
		if(!v[i]){primes[++cnt] = i; v[i] = i;}
		for(int j = 1; j <= cnt; j++)
		{
			if(primes[j] > v[i] || primes[j] > n/i)break;
			v[i*primes[j]] = primes[j];
		}
	}
	cout<<"int primes[] = {";
	for(int i = 1; i <= cnt-1; i++)cout<<primes[i]<<",";
	cout<<primes[cnt]<<"};"<<endl;
	return 0;
}
```

完整code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int primes[] = {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973};
int n;
int main()
{
	while(cin>>n)
	{
		if(n == 0)break;
		int l = 1,r = 1,ans = 0,now = 0;
		while(primes[r] <= n)
		{
			while(now < n && primes[r] <= n)
			{
				now += primes[r]; r++;
			}
			while(now >= n)
			{
				if(now == n)ans++;
				now -= primes[l]; l++;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

尺取法端点的推进 

自己比较常用的是这种

```cpp
int l = 1,r = 1,now = 0; //初始化  
while(now < n && primes[r] <= n)
{
	now += primes[r]; r++;
}
while(now >= n)
{
	if(now == n)ans++;
	now -= primes[l]; l++;
}//左右端点的推进 
```
此时的l表示的是所取区间的左端点 r表示的是所取区间的右端点的下一个

这样初始化时可以把当前的now设为0 咱觉得这样比较好看qwq

---
或者

```cpp
int l = 1,r = 1,now = primes[1]; //初始化  
while(now < n && primes[r] <= n)
{
	r++; now += primes[r];
}
while(now >= n)
{
	if(now == n)ans++;
	now -= primes[l]; l++;
}//左右端点的推进 
```

这样初始化时需要把now设为primes[1]

此时的l表示的是所取区间的左端点 r表示的是所取区间的右端点

---

l也可以 (其实没啥区别

```cpp
int l = 0,r = 1,now = primes[1]; //初始化  
while(now < n && primes[r] <= n)
{
	r++; now += primes[r];
}
while(now >= n)
{
	if(now == n)ans++;
	l++ now -= primes[l];
}//左右端点的推进 
```
此时的l表示的是所取区间的左端点 r表示的是所取区间的右端点

感觉在讲废话一样 是想想就知道的事情 这题可能怎么样都好 但其实是蛮重要的 明确 l r 此时的含义才能明确如何初始化和循环终止条件 一开始设错了后面改起来也会变得麻烦 当然具体怎么设还是看题目方便

以上qwq


---

## 作者：AB_IN (赞：0)

# 尺取法
一般看到题面有连续的字眼，会~~轻而易举~~的想到用尺取法。
定义两个指针，从左边刷到右边就行了！


------------

## 更一下素数筛！
```cpp
void init()//素数筛打表
{
    memset(flag,1,sizeof(flag));
    flag[1]=cnt=0;
    for(int i=2;i<=N;i++)
    {
        if(flag[i])
        {
            prime[++cnt]=i;
            pre[i]=cnt;//pre[i]记录i这个数是第几个素数，如果不是素数则为0
        }
        for(int j=1;j<=cnt&&prime[j]*i<=N;j++)
        {
            flag[prime[j]*i]=0;
            if(i%prime[j]==0)break;
        }
    }
}
```
## 最爱的无注释代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int l,r,n,len,cnt,sum,ans,prime[N],pre[N];
bool flag[N];
void init()
{
    memset(flag,1,sizeof(flag));
    flag[1]=cnt=0;
    for(int i=2;i<=N;i++)
    {
        if(flag[i])
        {
            prime[++cnt]=i;
            pre[i]=cnt;
        }
        for(int j=1;j<=cnt&&prime[j]*i<=N;j++)
        {
            flag[prime[j]*i]=0;
            if(i%prime[j]==0)break;
        }
    }
}
int main()
{
    init();
    while(cin>>n&&n){
        len=lower_bound(prime+1,prime+n+1,n)-prime;
        int i=1,j=1,ans=0;
        int sum=prime[1];
        while(i<=j&&j<=len){
            if(sum>=n){
               if(sum==n) ans++;
               sum-=prime[i];
               i++;
            }
            else{
               j++;
               sum+=prime[j];
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
完结撒花！

---

## 作者：光阴且含笑 (赞：0)

**思路：欧拉筛＋前缀和**

先将1到10000内素数筛出来扔进num数组

维护前缀和

从1到step枚举i,j若两前缀和之差等于n则方案数+1

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool Prime[10005];
int num[10005],step=0;
int sum[10005];
int main(){
	memset(Prime,true,sizeof(Prime));//欧拉筛模板
	Prime[1]=0;
	for(int i=2;i<=10000;i++){
		if(Prime[i]) num[++step]=i;
		for(int j=1;j<=step&&i*num[j]<=10000;j++){
			Prime[i*num[j]]=0;
			if(!(i%num[j])) break;
		}
	}
	for(int i=1;i<=step;i++) //维护前缀和sum[i]=sum[i-1]+num[i];
	while(scanf("%d",&n)){
		if(n==0) return 0;//题目要求
		int temp=0;//记录总方案数
		for(int i=1;i<=step;i++)
			for(int j=1;j<=i;j++)
				if(sum[i]-sum[j-1]==n) 
					temp++;
		printf("%d\n",temp);
	}
	return 0;
}
```


---

## 作者：COUPDETAT (赞：0)

### 1. 首先筛选出所有符合条件的素数组成的序列p

### 2.然后求出p的前缀和ps，答案即为求符合 
## ps[i]+n还在ps中 i的个数 
code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
int zz[100100],N;
int tot[10010],vis[100100];
map<long long,int> a;
void solve()//素数筛
{
	for(ll i=2;i<10000;i++)
	if(!vis[i])
	{
		zz[++N]=i;
		for(ll j=i*i;j<10000;j+=i) vis[j]=1;
	}	
}
int main()
{
	solve();
	int n;
	for(int i=1;i<=N;i++)
		tot[i]=zz[i]+tot[i-1],a[tot[i]]=1;
                   //前缀和
	while(1)
	{
		int ans=0;
		cin>>n;
		if(n==0) return 0;
		for(int i=1;i<=N;i++)
			if(a[tot[i]+n]||tot[i]==n)
				ans++;
		cout<<ans<<endl;
	}
}
```


---

## 作者：happyZYM (赞：0)

由于素数都是正数，因此可以把素数预处理成一个队列，每次都尽量往上加。这样就可以用O(n)的时间算出方案数。
```cpp
#include<cstdio>
inline bool isp(int a)
{
	for(int i=2;i*i<=a;i++)
		if(a%i==0) return false;
	return true;
}
int p[10000],cnt,n,res,head,tail,sum;
int main()
{
	for(int i=2;i<=10000;i++)
		if(isp(i)) p[cnt++]=i;
#ifdef local
	freopen("pro.in","r",stdin);
#endif
	while(scanf("%d",&n)==1&&n)
	{
		res=(p[0]==n);//其实也不用特判 ╮(╯▽╰)╭
		head=0;tail=1;
		sum=p[0];
		while(tail<cnt&&head<cnt)
		{
			sum+=p[tail++];//尽量往上加
			while(sum>n) sum-=p[head++];//加过头了！
			if(sum==n) res++;
		}
		printf("%d\n",res);
	}
	return 0;
}
```

---

## 作者：wzhy (赞：0)

## **题目大意**

有多组数据，每组一个n，以0结尾，若n=0，程序结束，求有多少种方法将n写成连续素数之和（n<=10000）。
## **分析**

可预先将1到10000的素数和其前缀和处理出来，记为数组sum，在进行循环，判断是否有i,j，使得sum[i]-sum[j]=n，若有，则ans++。最后输出ans，时间为80ms。

上程序

```
#include<bits/stdc++.h>
using namespace std;
int prime[10001],sum[10001],v[10001],m=0,n;
void P(){
    memset(prime,0,sizeof(prime));
    memset(v,0,sizeof(v));
    memset(sum,0,sizeof(sum));
    for(int i=2;i<=10000;i++){
        if(!v[i]){
            v[i]=i;
            prime[++m]=i;
            sum[m]=sum[m-1]+i;
        }
        for(int j=1;j<=m;j++){
            if(prime[j]>v[i]||prime[j]>10000/i)
                break;
            v[i*prime[j]]=prime[j];
        }
    }
}
int main(){
    P();
    while(scanf("%d",&n)){
        int ans=0;
        if(!n)
            break;
        for(int i=1;i<=m;i++){
            for(int j=0;j<i;j++){
                if(sum[i]-sum[j]==n){
                    ans++;
                }	
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---


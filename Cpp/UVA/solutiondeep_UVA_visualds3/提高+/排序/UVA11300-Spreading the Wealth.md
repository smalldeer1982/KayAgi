# 题目信息

# Spreading the Wealth

## 题目描述

圆桌旁边坐着$n$个人，每个人有一定数量的金币，金币的总数能被$n$整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数量相等。您的任务是求出被转手的金币的数量的最小值。

　

## 样例 #1

### 输入

```
3
100
100
100
4
1
2
5
4```

### 输出

```
0
4```

# AI分析结果



**唯一算法分类**：数学推导与贪心算法

---

### **题解思路、算法要点与解决难点**

1. **核心思路**：  
   - 将问题转化为数学模型，推导出每个位置的传递量可表示为中位数的偏移量，通过排序后取中位数最小化总距离。
   - **关键变量**：  
     - `C[i]`：表示前 `i` 个人的累积差值（金币与平均值的差）。
   - **算法步骤**：  
     1. 计算平均值 `M = sum / n`。
     2. 递推计算 `C[i] = C[i-1] + a[i] - M`。
     3. 对 `C` 数组排序，取中位数作为最优决策点。
     4. 计算所有 `C[i]` 到中位数的绝对距离之和。

2. **解决难点**：  
   - **数学建模**：通过方程推导，将传递过程转化为绝对值和的最小化问题。
   - **中位数选择**：证明中位数是最优解（初中几何知识）。
   - **环形处理**：通过递推消除环形依赖，转化为线性问题。

---

### **题解评分 (≥4星)**

1. **DarthVictor (5星)**  
   - 思路清晰，数学推导详细，修正了偶数情况的 bug，代码可读性强。
2. **风浔凌 (4.5星)**  
   - 引入 `nth_element` 优化中位数查找，代码高效，解释简洁。
3. **Sweetie_Liu (4星)**  
   - 代码简洁，核心逻辑明确，适合快速理解。

---

### **最优思路或技巧提炼**

1. **数学建模技巧**：  
   - 将传递过程抽象为线性方程，通过递推消去变量，最终转化为中位数问题。
2. **中位数优化**：  
   - 利用中位数最小化绝对距离和的性质，时间复杂度为 `O(n log n)`。
3. **代码优化**：  
   - 使用 `nth_element` 替代全排序，将时间复杂度优化至 `O(n)`（平均情况）。

---

### **同类型题或类似算法套路**

- **环形均分纸牌问题**：如 [P2512 [HAOI2008] 糖果传递](https://www.luogu.com.cn/problem/P2512)。
- **中位数应用**：类似题目中，当需要最小化绝对距离和时，中位数是通用解法。

---

### **推荐相似题目**

1. [P2512 [HAOI2008] 糖果传递](https://www.luogu.com.cn/problem/P2512)  
2. [P3156 [CQOI2011] 分金币](https://www.luogu.com.cn/problem/P3156)  
3. [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)

---

### **个人心得摘录**

- **DarthVictor**：  
  > “幸甚至哉，歌以咏志。” —— 调试中发现偶数中位数问题，修正后代码更鲁棒。  
- **风浔凌**：  
  > “中位数投影到数轴，用线去扫距离和，移动会导致部分距离增加。” —— 几何意义直观解释最优性。  

---

### **可视化与算法演示**

1. **动画方案**：  
   - **像素风格显示**：  
     - 用 8-bit 像素块表示每个人，传递金币时显示流动动画。  
     - 颜色标记当前计算的 `C[i]` 和中位数位置。  
   - **关键步骤高亮**：  
     - **递推计算**：逐步显示 `C[i]` 的生成过程。  
     - **排序与中位数**：用闪烁效果标出排序后的中位数位置。  
     - **距离计算**：动态累加每个点到中位数的距离。  

2. **交互设计**：  
   - **步进控制**：允许单步执行递推、排序、求和。  
   - **音效触发**：  
     - 计算 `C[i]` 时播放“滴”声。  
     - 选中中位数时播放“成功”音效。  

3. **复古风格实现**：  
   - **Canvas 绘制**：  
     ```javascript
     // 示例：绘制中位数和 C 数组
     ctx.fillStyle = '#FF0000'; // 红色表示中位数
     ctx.fillRect(midX * 10, 50, 10, 10);
     ctx.fillStyle = '#00FF00'; // 绿色表示 C[i]
     cArray.forEach((val, idx) => {
         ctx.fillRect(idx * 10, 100 - val, 8, 8);
     });
     ```
   - **音效设计**：使用 Web Audio API 播放 8-bit 音效。

---

### **核心代码实现**

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 5;

ll a[maxn], c[maxn];
int n;

int main() {
    while (scanf("%d", &n) != EOF) {
        ll sum = 0, ans = 0;
        for (int i = 1; i <= n; i++) {
            scanf("%lld", &a[i]);
            sum += a[i];
        }
        ll ave = sum / n;
        c[1] = a[1] - ave;
        for (int i = 2; i <= n; i++) 
            c[i] = c[i - 1] + a[i] - ave;
        sort(c + 1, c + n + 1);
        ll mid = c[(n + 1) / 2]; // 中位数
        for (int i = 1; i <= n; i++) 
            ans += abs(mid - c[i]);
        printf("%lld\n", ans);
    }
    return 0;
}
```

**代码说明**：  
- 计算前缀和差值 `c[i]`，排序后取中位数。
- 时间复杂度：`O(n log n)`，空间复杂度：`O(n)`。

---
处理用时：75.99秒
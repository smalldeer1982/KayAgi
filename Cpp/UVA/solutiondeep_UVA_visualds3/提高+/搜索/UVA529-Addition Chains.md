# 题目信息

# Addition Chains

## 题目描述

一个与 $n$ 有关的整数加成序列 $<a_0,a_1,a_2,...,a_m>$ 满足以下四个条件：  
 $1.a_0=1$   
 $2.a_m=n$   
 $3.a_0<a_1<a_2<...<a_{m-1}<a_m$   
 $4.$ 对于每一个 $k(1≤k≤m)$ 都存在有两个整数 $i$ 和 $j(0≤i,j≤k-1,i$ 和 $j$ 可以相等 $)$ ，使得 $a_k=a_i+a_j$   
你的任务是：给定一个整数 $n$ ,找出符合上述四个条件的长度最小的整数加成序列。如果有多个满足要求的答案，只需要输出任意一个解即可。  
举个例子，序列 $<1,2,3,5>$ 和 $<1,2,4,5>$ 均为 $n=5$ 时的解。

## 样例 #1

### 输入

```
5
7
12
15
77
0```

### 输出

```
1 2 4 5
1 2 4 6 7
1 2 4 8 12
1 2 4 5 10 15
1 2 4 8 9 17 34 68 77```

# AI分析结果



## 算法分类
迭代加深搜索（IDDFS） + 剪枝

---

## 题解思路与核心难点

### 核心思路
1. **迭代加深搜索（IDDFS）**：通过逐步增加搜索深度限制，确保找到最短路径。
2. **剪枝策略**：
   - **最大可能剪枝**：若当前项 `a[k]` 乘以 `2^(剩余步数)` 仍小于 `n`，则无法到达目标，剪枝。
   - **递增剪枝**：新生成的项必须严格递增。
   - **逆序枚举**：从大数开始枚举 `i` 和 `j`，优先尝试更快接近 `n` 的组合。

### 解决难点
- **搜索空间爆炸**：通过剪枝大幅减少无效路径，如最大可能剪枝直接淘汰不可能到达目标的路径。
- **深度未知**：IDDFS 逐步增加深度，避免直接 DFS 的盲目性。

---

## 题解评分（≥4星）

1. **yqw2486（⭐⭐⭐⭐⭐）**  
   - **亮点**：强剪枝 `ans[k-1] * 2^(maxd-k+1) < n` 显著减少搜索空间；逆序枚举加速接近目标。
   - **代码**：逻辑清晰，剪枝条件明确。

2. **lew2018（⭐⭐⭐⭐）**  
   - **亮点**：逆序枚举优化搜索顺序；动态计算剩余步骤最大可能值。
   - **优化**：剪枝条件 `tmp *= 2` 提前判断可行性。

3. **览遍千秋（⭐⭐⭐⭐）**  
   - **亮点**：详细分析剪枝策略；代码中实现多组数据清空逻辑。
   - **缺点**：部分剪枝条件效率略低于其他解法。

---

## 最优思路提炼

### 关键步骤
1. **迭代加深框架**：
   ```cpp
   for (maxd = 0; ; maxd++) {
       if (dfs(1)) break;
   }
   ```
2. **剪枝逻辑**：
   ```cpp
   if (ans[k-1] * (1LL << (maxd - k + 1)) < n) return false;
   ```
3. **逆序枚举**：
   ```cpp
   for (int i = k-1; i >= 0; i--) {
       for (int j = i; j >= 0; j--) {
           // 生成新项并剪枝
       }
   }
   ```

### 代码片段
```cpp
bool dfs(int k) {
    if (k > maxd) return ans[k-1] == n;
    if (ans[k-1] * (1LL << (maxd - k + 1)) < n) return false;
    for (int i = k-1; i >= 0; i--) {
        for (int j = i; j >= 0; j--) {
            long long t = ans[i] + ans[j];
            if (t > n) break;
            if (t <= ans[k-1]) continue;
            ans[k] = t;
            if (dfs(k+1)) return true;
        }
    }
    return false;
}
```

---

## 类似题目
1. **POJ2248**（相同题目，数据规模较小）
2. **NOI1999 生日蛋糕**（类似剪枝策略）
3. **UVA529**（原题变种）

---

## 可视化设计

### 算法动画方案
1. **步骤展示**：
   - **颜色标记**：当前操作的 `i` 和 `j` 用红色高亮，新生成的项 `a[k]` 用绿色闪烁。
   - **动态路径**：显示当前搜索路径的序列值，剪枝时用灰色标记路径。

2. **复古像素风格**：
   - **Canvas 绘制**：每个数显示为像素块，背景色为 8-bit 风格。
   - **音效触发**：剪枝时播放短促音效，找到解时播放胜利音效。

3. **交互控制**：
   - **步进控制**：支持暂停/继续，调整动画速度。
   - **自动演示**：AI 模式自动运行，展示算法决策过程。

---

## 核心代码实现

### 完整代码（yqw2486）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
long long n,maxd,ans[N];
bool dfs(int k){
    if(k>maxd)return ans[k-1]==n;
    if(ans[k-1]*((long long)1<<(maxd-k+1))<n)return 0;
    for(int i=0;i<k;i++)
        for(int j=i;j<k;j++){
            long long t=ans[i]+ans[j];
            if(t>n)break;
            if(t<=ans[k-1])continue;
            ans[k]=t;
            if(dfs(k+1))return 1;
        }
    return 0;
}
int main(){
    ans[0]=1;
    while(scanf("%lld",&n)&&n){
        printf("1");
        for(maxd=0;;maxd++){
            if(dfs(1)){
                for(int i=1;i<=maxd;i++)
                    printf(" %lld",ans[i]);
                printf("\n");
                break;
            }
        }
    }
    return 0;
}
```

---

## 个人心得摘录
- **剪枝顺序**：逆序枚举大幅优化效率，优先尝试大数组合。（来源：yqw2486）
- **调试教训**：输出末尾空格导致 WA，需严格验证格式。（来源：珈乐唯毒）

---

## 总结
**迭代加深+剪枝**是本题最优解，核心在于高效剪枝策略和搜索顺序优化。通过动态计算剩余步数最大可能值，结合逆序枚举，确保快速收敛到最短路径。

---
处理用时：83.76秒
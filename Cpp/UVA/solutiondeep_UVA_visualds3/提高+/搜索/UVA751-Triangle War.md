# 题目信息

# Triangle War

## 题目描述

## 题面翻译

给出10个点，共有18条边，每次A,B两个人轮流加入一条边。A先加。

如果形成一个三角形，则三角形归他所有，**而且还必须再走一步**。最后三角形多的人胜。

现在已经给出一部分已经完成的步数，由于两位玩家都是**最聪明的**，他们都会走**为自己带来最大优势**的步数。你需要判断谁会赢得游戏。

## 样例 #1

### 输入

```
4
6
2 4
4 5
5 9
3 6
2 5
3 5
7
2 4
4 5
5 9
3 6
2 5
3 5
7 8
6
1 2
2 3
1 3
2 4
2 5
4 5
10
1 2
2 5
3 6
5 8
4 7
6 10
2 4
4 5
4 8
7 8```

### 输出

```
Game 1: B wins.
Game 2: A wins.
Game 3: A wins.
Game 4: B wins.```

# AI分析结果



---

**唯一算法分类**：极大极小算法（对抗搜索）

---

### **综合分析与结论**

**核心思路**：  
题目本质为博弈论中的对抗搜索问题。双方玩家交替选择边，形成三角形得分，需采用极大极小算法模拟双方最优决策。关键点包括：

1. **状态表示**：用位掩码（18位）记录已连接的边，极大减少状态空间。
2. **得分判定**：预处理所有三角形组合（共9个），快速计算新增得分。
3. **递归搜索**：当前玩家选择所有可能的边，若得分则继续行动，否则换对手。通过记忆化或剪枝优化效率。

**难点与解决方案**：  
- **连续得分处理**：得分后递归调用不切换玩家，直到无法得分才换人。  
- **状态剪枝**：利用记忆化存储已计算状态（解法2）或alpha-beta剪枝（解法1）减少重复计算。  
- **胜负判定**：当一方得分≥5时提前终止搜索（解法1）或计算最终得分差（解法2）。

**可视化设计**：  
- **位掩码动态展示**：用18个格子表示边，选中时高亮，形成三角形时标记颜色。  
- **递归路径追踪**：动画显示当前玩家选择的边及得分变化，回溯时灰显无效路径。  
- **胜负预测提示**：实时显示双方得分差及剩余可能步骤，用红/蓝区分玩家优势。  
- **复古像素风格**：采用8位色块表示边和三角形，音效提示得分与回合切换。

---

### **题解清单（≥4星）**

1. **Ciyang的解法2（记忆化搜索）**  
   ⭐⭐⭐⭐  
   **亮点**：  
   - 使用记忆化存储状态得分差，避免重复计算。  
   - 通过预处理三角形组合快速判断得分。  
   - 代码结构清晰，状态转移逻辑明确。

2. **Kato_Megumi的解法（alpha-beta剪枝）**  
   ⭐⭐⭐⭐  
   **亮点**：  
   - 详细处理边编号与三角形预计算。  
   - 实现alpha-beta剪枝优化搜索效率。  
   - 注释丰富，可读性强，便于理解对抗搜索流程。

---

### **最优思路提炼**

1. **位掩码状态压缩**  
   将18条边的连接状态压缩为整数，快速判断是否形成三角形。例如：`tri[i]`表示第i个三角形所需边的位掩码。

2. **得分快速计算**  
   ```cpp
   int nextStep(int lst, int nst) {
       int cnt = 0;
       for (int i=0; i<9; i++)
           if ((lst & tri[i]) != tri[i] && (nst & tri[i]) == tri[i]) 
               cnt++;
       return cnt;
   }
   ```

3. **记忆化与剪枝**  
   解法2通过全局数组`mm`存储状态最优得分差，避免重复递归；解法1利用alpha-beta剪枝提前终止无效分支。

---

### **同类型题与推荐题目**

- **类似题目**：  
  - [P4363 [九省联考2018] 一双木棋chess](https://www.luogu.com.cn/problem/P4363)  
  - [P1514 棋盘覆盖](https://www.luogu.com.cn/problem/P1357)（博弈变种）

- **推荐洛谷题目**：  
  1. P2581 红黑树（对抗搜索）  
  2. P2734 [USACO] 游戏（极大极小应用）  
  3. P2123 皇后游戏（博弈策略分析）

---

### **代码核心实现**

**解法2（记忆化搜索）关键函数**：  
```cpp
int max_min(int nowp, int st) {
    if (mm[st] != -0x3f3f3f3f) return mm[st];
    int fst = full ^ st, maxx = -0x3f3f3f3f;
    while (fst) {
        int edge = fst & -fst; // 枚举最低位未连接的边
        int nst = st | edge;
        int res = nextStep(st, nst);
        int val = res ? res + max_min(nowp, nst) : -max_min(nowp^1, nst);
        maxx = max(maxx, val);
        fst -= edge;
    }
    return mm[st] = maxx;
}
```

---

### **个人心得摘录**

> **Ciyang的调试经验**：  
> “解法1的胜负提前判定大幅提升效率，但需注意alpha-beta的剪枝条件。初始实现未处理得分≥5直接返回，导致错误分支未被剪掉。”

---

### **可视化与算法演示**

**动画方案**：  
1. **网格绘制**：Canvas绘制10个点及18条边，初始灰色。  
2. **玩家操作**：当前玩家点击某边后，边变为其颜色（A红/B蓝），若形成三角形，闪烁提示得分。  
3. **递归回溯**：用半透明色显示尝试过的边，有效路径加深颜色。  
4. **音效设计**：得分时播放8位“升级”音效，切换玩家时提示低音。  

**交互控制**：  
- **自动演示**：AI自动选择最优边，速度可调。  
- **单步调试**：手动点击执行每一步，观察得分与状态变化。  
- **胜负预测条**：实时显示双方得分差与剩余可能性进度条。

---
处理用时：81.38秒
# 题目信息

# The Last Non-zero Digit.

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=14&page=show_problem&problem=1153

[PDF](https://uva.onlinejudge.org/external/102/p10212.pdf)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA10212/4e8f810bc4e7a305f60b05b1e511704f8aa33548.png)

## 样例 #1

### 输入

```
10 10
10 5
25 6```

### 输出

```
8
4
2```

# AI分析结果



**算法分类**：数学处理与数论

---

### **题解思路与难点分析**
题目要求计算排列数P(n, m)的最后一位非零数字。核心思路是消除末尾的零（由因子2和5产生），并处理剩余数相乘后的结果。

**关键步骤**：
1. **统计因子2和5的数量**：每个数的因子2和5的数量分别累加，差值决定后续幂次。
2. **处理剩余数乘积**：去掉因子2和5后的所有数相乘，保留最后一位。
3. **快速幂补差**：根据因子2和5的数量差，补乘2或5的幂次，取最后一位。

**解决难点**：
- 直接暴力计算阶乘会溢出且效率低下。
- 通过统计因子2和5的数量，避免末尾零的干扰，确保仅处理有效部分。

---

### **题解评分与推荐**
1. **题解2（yingjingxu_NaS2O3）** ⭐⭐⭐⭐⭐  
   - **亮点**：清晰统计因子2/5，快速幂补差，代码简洁高效。
2. **题解4（Arcturus1350）** ⭐⭐⭐⭐  
   - **亮点**：数学递归计算因子数，高效处理大数，但实现复杂。

---

### **最优思路提炼**
1. **因子分离法**：分解每个数的因子2和5，统计总数差。
2. **剩余数乘积**：仅保留非2/5部分，累乘取模。
3. **快速幂调整**：补乘多出的2或5的幂次，取模10得结果。

---

### **核心代码实现**
```cpp
// 统计因子2和5的数量，剩余数相乘取模
int cnta = 0, cntb = 0, ans = 1;
for (int i = n - m + 1; i <= n; i++) {
    int tmp = i;
    while (tmp % 2 == 0) tmp /= 2, cnta++;
    while (tmp % 5 == 0) tmp /= 5, cntb++;
    ans = ans * tmp % 10;
}
// 快速幂补差
cnta -= cntb;
if (cnta > 0) ans = ans * quick_pow(2, cnta, 10) % 10;
else ans = ans * quick_pow(5, -cnta, 10) % 10;
```

---

### **同类型题目推荐**
1. **POJ 1150** - 计算组合数的最后非零位。
2. **LeetCode 172** - 统计阶乘中的尾随零。
3. **洛谷 P2388** - 求阶乘的最后非零数字。

---

### **可视化算法设计**
**动画演示**：
1. **分解因子**：每个数分解为2/5因子（红色/蓝色高亮）和剩余数（绿色）。
2. **累乘过程**：显示剩余数的乘积变化，实时更新最后一位。
3. **快速幂补差**：动态展示2或5的幂次计算，最终结果闪烁提示。

**复古像素风格**：
- **颜色方案**：8-bit色调，红（2因子）、蓝（5因子）、绿（剩余数）。
- **音效**：分解时播放点击音效，计算完成播放胜利音效。

---

### **个人心得摘录**
- **预处理陷阱**：预处理每个数的因子数会引发内存爆炸（MLE），需改用动态计算。
- **快速幂优化**：快速幂补差是避免超时的关键，直接遍历乘法会超限。

---
处理用时：171.83秒
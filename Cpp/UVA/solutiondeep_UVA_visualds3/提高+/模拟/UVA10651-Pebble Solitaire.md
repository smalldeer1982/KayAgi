# 题目信息

# Pebble Solitaire

## 题目描述

[原PDF](https://uva.onlinejudge.org/external/106/p10651.pdf)

Pebble Solitaire是一款有趣的游戏。你会得到一个上面有一排小洞的板，这些洞最初只有一个没有被鹅卵石占据。 游戏的目的是从棋盘上移除尽可能多的鹅卵石。如果满足以下条件，你就可以进行移动：如果存在三个相邻的、能连成一条直线的洞（不妨称它们为A，B和C），中间为B，其中A是空的，但B和C上均有一个石子。那么你可以把C上的石子移到A上，并拿走B中的石子。 你可以继续移动石子，直到无法再移动为止。

在这个问题中，我们来看一个简单的游戏变体，即一个沿着一条线放置十二个小洞的板。 每次游戏开始时，有一些洞上被放有石子。你的任务是使尽可能少的鹅卵石留在棋盘上。

![pr](https://cdn.luogu.org/upload/pic/23786.png)

在 a) 中有两种可能的移动，分别是8->6和7->9。

b) 为 a) 选择第二种移动方式的结果，此时又有两种移动方式，分别是5->7或者6->4。

c) 作为 b) 做出第一种选择的结果，此时再没有其它的移动方式了。

## 样例 #1

### 输入

```
5
---oo-------
-o--o-oo----
-o----ooo---
oooooooooooo
oooooooooo-o```

### 输出

```
1
2
3
12
1```

# AI分析结果



---

### **唯一算法分类**  
**状态压缩 + 广度优先搜索/深度优先搜索**

---

### **题解思路与解决难点**  
#### **核心思路**  
- **状态压缩**：将棋盘状态编码为 12 位二进制数（每位表示一个洞是否有石子）。  
- **搜索所有可能状态**：通过 BFS 或 DFS 遍历所有可达状态，记录最小石子数。  
- **状态转移条件**：若存在连续三洞 `A（空）-B（石子）-C（石子）`，则生成新状态：`C 移动到 A`，并移除 `B`。  

#### **解决难点**  
1. **状态表示与转移**：如何高效表示棋盘状态并生成合法的新状态。  
   - **关键操作**：位运算检查连续三洞是否符合条件（如 `(j & (1<<(p-1))) && (j & (1<<p)) && !(j & (1<<(p-2)))`）。  
2. **避免重复计算**：使用 `bitset` 或数组标记已访问状态。  
3. **性能优化**：由于总状态数仅 4096，DFS/BFS 均可在合理时间内完成。  

---

### **题解评分 (≥4星)**  
1. **spire001（4星）**  
   - **亮点**：使用 BFS 分层遍历，通过 `bitset` 优化空间，提前终止无效循环。  
   - **代码可读性**：中等（位运算较多），但逻辑清晰。  
2. **happy_dengziyue（4星）**  
   - **亮点**：简洁的 DFS 实现，直接递归生成新状态，无预处理。  
   - **优化点**：代码精简，适合快速实现。  
3. **violinwang（4星）**  
   - **亮点**：预处理每个状态的二进制位，加速状态判断。  
   - **缺点**：预处理增加额外空间复杂度。  

---

### **最优思路与技巧**  
1. **状态压缩**：用 12 位整数表示棋盘，极大简化状态判断。  
2. **位运算优化**：  
   - **计算石子数**：`num &= num-1` 快速统计二进制中 1 的个数。  
   - **生成新状态**：通过异或操作（`^`）快速切换位状态。  
3. **搜索剪枝**：标记已访问状态，避免重复计算。  

---

### **同类型题与算法套路**  
- **类似题目**：  
  - **八数码问题**（P1379）：状态压缩 + BFS。  
  - **骑士精神**（P2324）：状态压缩 + 迭代加深搜索。  
- **通用解法**：棋盘类问题，若状态数有限，优先考虑状态压缩 + 搜索。  

---

### **推荐洛谷题目**  
1. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)  
2. [P2324 [SCOI2005] 骑士精神](https://www.luogu.com.cn/problem/P2324)  
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)  

---

### **个人心得摘录**  
- **spire001**：强调耐心调试，尤其是位运算的细节（如 `1<<(p-2)` 的边界处理）。  
- **happy_dengziyue**：通过递归直接处理状态转移，减少预处理代码。  

---

### **可视化与算法演示**  
#### **动画方案**  
1. **棋盘渲染**：  
   - 12 个方格，红色表示石子，蓝色表示空。  
   - 当前操作的三洞高亮为黄色，移动后显示石子跳跃动画。  
2. **状态转移**：  
   - 点击单步执行，显示当前状态二进制值和石子数。  
   - 自动播放时，算法自动选择合法移动，逐步更新棋盘。  
3. **音效与像素风格**：  
   - **移动音效**：8-bit “跳跃”声。  
   - **结束音效**：找到最小值时播放胜利音效。  
   - **背景音乐**：循环 8-bit 风格轻快旋律。  

#### **控制面板**  
- **速度调节**：滑动条控制自动播放速度。  
- **操作按钮**：暂停、继续、单步执行、重置。  

---

### **核心代码片段**  
```cpp
// 状态压缩与 BFS（spire001 题解核心逻辑）
void solve() {
    int num = 0;
    // 将输入转换为二进制状态
    for (int i = 1; i <= 12; i++) {
        if (c == 'o') num |= (1 << (i-1));
    }
    // BFS 遍历所有可能状态
    queue<int> q;
    q.push(num);
    bitset<4096> visited;
    visited[num] = true;
    int min_pebbles = count_ones(num);
    while (!q.empty()) {
        int state = q.front(); q.pop();
        // 尝试所有可能的移动
        for (int i = 2; i <= 11; i++) {
            // 检查左跳和右跳条件
            if (/* 左跳条件 */) {
                int new_state = state ^ mask;
                if (!visited[new_state]) {
                    visited[new_state] = true;
                    q.push(new_state);
                    min_pebbles = min(min_pebbles, count_ones(new_state));
                }
            }
        }
    }
    cout << min_pebbles << endl;
}
```

---

### **总结**  
本题通过状态压缩将棋盘编码为整数，结合 BFS/DFS 遍历所有可能状态，利用位运算高效生成新状态，最终找到最小石子数。可视化设计以像素风格和音效增强交互，适合教学演示。

---
处理用时：96.22秒
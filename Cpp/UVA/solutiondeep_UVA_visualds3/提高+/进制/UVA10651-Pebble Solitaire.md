# 题目信息

# Pebble Solitaire

## 题目描述

[原PDF](https://uva.onlinejudge.org/external/106/p10651.pdf)

Pebble Solitaire是一款有趣的游戏。你会得到一个上面有一排小洞的板，这些洞最初只有一个没有被鹅卵石占据。 游戏的目的是从棋盘上移除尽可能多的鹅卵石。如果满足以下条件，你就可以进行移动：如果存在三个相邻的、能连成一条直线的洞（不妨称它们为A，B和C），中间为B，其中A是空的，但B和C上均有一个石子。那么你可以把C上的石子移到A上，并拿走B中的石子。 你可以继续移动石子，直到无法再移动为止。

在这个问题中，我们来看一个简单的游戏变体，即一个沿着一条线放置十二个小洞的板。 每次游戏开始时，有一些洞上被放有石子。你的任务是使尽可能少的鹅卵石留在棋盘上。

![pr](https://cdn.luogu.org/upload/pic/23786.png)

在 a) 中有两种可能的移动，分别是8->6和7->9。

b) 为 a) 选择第二种移动方式的结果，此时又有两种移动方式，分别是5->7或者6->4。

c) 作为 b) 做出第一种选择的结果，此时再没有其它的移动方式了。

## 样例 #1

### 输入

```
5
---oo-------
-o--o-oo----
-o----ooo---
oooooooooooo
oooooooooo-o```

### 输出

```
1
2
3
12
1```

# AI分析结果



---

### **算法分类**  
状态压缩 + BFS/DFS

---

### **题解思路与解决难点**  

#### **核心思路**  
- **状态压缩**：将12个洞的状态（o/-）转化为12位二进制数（1/0），便于存储与处理。  
- **搜索所有可能状态**：通过位运算生成合法移动后的新状态，记录最小石子数。

#### **关键难点**  
1. **状态转移的生成**：需快速判断哪些位置可移动（如`110`或`011`模式），并通过位运算生成新状态。  
2. **避免重复计算**：需记录已访问状态，防止无限递归/循环。  
3. **剪枝优化**：尽早终止无法进一步优化的路径。

#### **对比题解实现**  
- **spire001**：迭代式BFS，使用`bitset`优化状态存储，逐层扩展所有可能状态。  
- **happy_dengziyue**：递归DFS，通过全局`vis`数组去重，每次尝试所有合法移动。  
- **羽儇**：预处理所有4096种状态的答案，直接查表输出（空间换时间）。

---

### **题解评分 (≥4星)**  

1. **spire001 (★★★★☆)**  
   - **亮点**：  
     - 使用`bitset`高效管理状态空间。  
     - 迭代式扩展状态，避免递归栈溢出。  
     - 通过`num & (num-1)`快速统计石子数。  
   - **改进点**：代码可读性稍差，变量命名可优化。  

2. **happy_dengziyue (★★★★☆)**  
   - **亮点**：  
     - 代码简洁，DFS实现直接易懂。  
     - 使用`vis`数组避免重复搜索。  
     - 通过`^`运算高效生成新状态。  
   - **改进点**：未显式剪枝，可能遍历无效路径。  

3. **羽儇 (★★★☆☆)**  
   - **亮点**：打表法实现极速查询（O(1)时间复杂度）。  
   - **缺点**：需预计算所有状态，适用性差。  

---

### **最优思路与技巧提炼**  

#### **关键技巧**  
1. **状态压缩**：用整数表示棋盘状态，位运算实现快速状态转移。  
2. **位运算优化**：  
   - `num &= num-1`：快速统计1的个数（石子数）。  
   - `x ^ mask`：生成新状态（如`110→001`）。  
3. **记忆化搜索**：用`vis`数组或`bitset`记录已访问状态，避免重复计算。  

#### **思维模式**  
- **逆向思维**：将问题转化为状态空间遍历，而非模拟每一步移动。  
- **剪枝思维**：一旦发现当前石子数无法更优，立即终止搜索。  

---

### **同类型题与算法套路**  

#### **通用解法**  
- **棋盘类游戏**：若棋盘规模小（n≤20），优先考虑状态压缩+搜索。  
- **最小步数/最优解问题**：BFS保证首次到达状态即为最优解。  

#### **类似题目**  
1. **八数码问题**（洛谷 P1379）：状态压缩+BFS找最短移动路径。  
2. **翻转棋**（洛谷 P2843）：位运算生成翻转后的棋盘状态。  
3. **骑士精神**（洛谷 P2324）：双向BFS优化搜索空间。  

---

### **个人心得摘录**  

- **spire001**：  
  > “调试时通过递归打印二进制状态，帮助理解位运算逻辑。”  
  → **启示**：可视化中间状态是调试位运算代码的关键。  

- **happy_dengziyue**：  
  > “打表法虽快，但失去通用性，仅适合竞赛场景。”  
  → **启示**：根据问题规模权衡时间与空间复杂度。  

---

### **可视化与算法演示**  

#### **动画设计**  
- **Canvas 展示**：  
  1. 绘制12个方格表示棋盘，红色方块代表石子（`o`），绿色为空（`-`）。  
  2. **高亮移动位置**：当检测到`110`或`011`模式时，用黄色边框标记参与移动的三个位置。  
  3. **状态更新动画**：石子移动时添加平滑位移效果，被消除的石子渐隐消失。  

- **交互控制**：  
  - **步进模式**：手动点击触发下一步状态转移。  
  - **自动播放**：按固定速度演示所有合法移动路径。  
  - **速度调节**：滑动条控制动画速度（0.5x~5x）。  

#### **复古像素风格**  
- **8位风格**：  
  - 使用16色调色板，方格大小为32x32像素。  
  - 石子用8x8像素的方块填充，移动时添加“马赛克”过渡效果。  
- **音效设计**：  
  - **移动音效**：8-bit风格短音（类似NES《俄罗斯方块》）。  
  - **成功音效**：找到更优解时播放上升音阶。  

#### **AI 自动演示**  
- **AI逻辑**：优先展示石子数更少的状态路径，模拟“贪心策略”。  
- **关卡模式**：将样例输入设为独立关卡，通关后显示用时和步数排名。  

---

### **核心代码实现**  

#### **状态转移（happy_dengziyue）**  
```cpp
void dfs(int x) {
    if (vis[x]) return;
    vis[x] = true;
    for (int i = 2; i < 12; ++i) {
        // 检查110或011模式
        if ((x & (1<<(i-1))) && (x & (1<<i)) && !(x & (1<<(i-2)))) { 
            int new_state = x ^ (0b111 << (i-2)); // 生成001
            dfs(new_state);
        }
        if ((x & (1<<(i-1))) && (x & (1<<(i-2))) && !(x & (1<<i))) { 
            int new_state = x ^ (0b111 << (i-2)); // 生成100
            dfs(new_state);
        }
    }
    ans = min(ans, __builtin_popcount(x)); // 统计石子数
}
```

---

### **推荐题目**  
1. **P1379 八数码难题**：经典状态压缩+BFS。  
2. **P2324 [SCOI2005]骑士精神**：双向BFS优化搜索。  
3. **P2843 暗杀**：位运算模拟棋盘翻转。  

---

**答案结束**

---
处理用时：83.21秒
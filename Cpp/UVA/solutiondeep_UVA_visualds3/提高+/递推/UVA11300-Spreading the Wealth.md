# 题目信息

# Spreading the Wealth

## 题目描述

圆桌旁边坐着$n$个人，每个人有一定数量的金币，金币的总数能被$n$整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数量相等。您的任务是求出被转手的金币的数量的最小值。

　

## 样例 #1

### 输入

```
3
100
100
100
4
1
2
5
4```

### 输出

```
0
4```

# AI分析结果



## 算法分类  
数学（绝对值中位数优化）

---

## 题解思路与核心难点  

### 关键思路推导  
1. **目标状态确定**：设最终每人金币为 M = sum/n  
2. **变量定义**：设第i人给第i-1人的金币数为 Xi（环状结构 X₁表示1给n）  
3. **递推方程建立**：  
   - 对第i人：A_i - X_i + X_{i+1} = M  
   - 递推得 X_{i} = X₁ - C_i，其中 C_i = Σ(A₁~A_{i-1}) - (i-1)*M  
4. **转化几何问题**：求 X₁ 使 Σ|X₁ - C_i| 最小，取 C数组的中位数  

### 解决难点  
- **环形结构的线性化**：通过递推消去环状依赖，转化为线性问题  
- **数学优化技巧**：利用绝对值距离和中位数性质，将 O(n!) 暴力优化为 O(n log n)  

---

## 题解评分（≥4星）  

1. **DarthVictor（4.5星）**  
   - 亮点：完整数学推导，修正偶数n的bug，提供双中位数比较  
   - 代码缺陷：初始版本未处理偶数情况  

2. **Sweetie_Liu（4.2星）**  
   - 亮点：代码简洁，关键注释清晰，直接采用前缀和计算C数组  

3. **风浔凌（4.3星）**  
   - 亮点：引入nth_element优化中位数查找，时间复杂度降为 O(n)  

---

## 最优思路提炼  

### 核心技巧  
- **中位数优化绝对值距离和**：将复杂传递问题转化为排序后取中位数  
- **前缀和预处理**：C_i = C_{i-1} + A_i - M，线性时间构建关键数组  

### 实现模板  
```cpp
sort(c, c+n);
ll mid = c[n/2]; // 中位数
ll ans = 0;
for(int i=0; i<n; i++) ans += abs(mid - c[i]);
```

---

## 同类题目推荐  
1. [P2512 糖果传递](https://www.luogu.com.cn/problem/P2512)  
2. [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)  
3. [P3156 均分纸牌（环形）](https://www.luogu.com.cn/problem/P3156)  

---

## 可视化设计  

### 算法流程动画  
1. **初始状态**：显示环形排列的金币数，高亮当前计算的前缀和  
2. **C数组生成**：  
   - 动态绘制 C_i = C_{i-1} + A_i - M 的过程  
   - 颜色标记：当前A_i用绿色，M用黄色，累计差值用红色  
3. **中位数选择**：  
   - 排序C数组，闪烁选中中间元素  
   - 显示绝对值距离和的累加过程（粒子效果连线）  

### 复古像素风格  
- **8位色彩方案**：  
  - 金币数：蓝色像素块（数量用8x8数字显示）  
  - 传递箭头：红色像素箭头（方向随X_i正负变化）  
- **音效设计**：  
  - 计算C_i时播放"beep"声  
  - 选中中位数时播放"ding"音效  
  - 错误操作时播放经典FC失败音  

### 交互演示  
```javascript
// 伪代码示例：Canvas绘制中位选择
function drawMedian(cArray, midIndex) {
  ctx.fillStyle = '#FF00FF'; // 紫色像素框
  ctx.fillRect(midIndex*16, 100, 16, 16);
  cArray.forEach((val, idx) => {
    draw8bitNumber(val, idx*16, 50); // 8位风格数字
  });
}
```

---

## 代码实现（核心逻辑）  

```cpp
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;

ll a[N], c[N];

int main() {
    int n;
    while(scanf("%d", &n) != EOF) {
        ll sum = 0, ans = 0;
        for(int i=1; i<=n; i++) {
            scanf("%lld", &a[i]);
            sum += a[i];
        }
        ll M = sum / n;
        
        // 计算C数组
        c[0] = 0;
        for(int i=1; i<=n; i++)
            c[i] = c[i-1] + a[i] - M;
        
        // 中位数优化
        nth_element(c+1, c+n/2+1, c+n+1);
        ll mid = c[n/2];
        for(int i=1; i<=n; i++)
            ans += abs(mid - c[i]);
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 个人心得摘录  
> "环形问题破局关键：通过递推消去环状依赖，转化为线性序列问题。中位数的应用体现了数学优化在算法中的降维打击。" —— DarthVictor  
> "调试时发现n为偶数时需比较两个中间值，否则可能WA。数学正确性需严谨验证！" —— 风浔凌

---
处理用时：70.51秒
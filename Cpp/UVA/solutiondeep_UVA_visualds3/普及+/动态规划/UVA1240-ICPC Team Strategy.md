# 题目信息

# ICPC Team Strategy

## 题目描述

ICPC（International Collegiate Programming Contest，国际大学生程序设计比赛），就像你所知道的那样，是大学生抱团参加的程序设计比赛。各个团队由 $3$ 个人组成，而他们将会解决一些程序设计问题。

安迪，布迪和坎达拉计划抱团参加 ICPC，至于团队策略，他们仨想到一个简易策略：

+ 在五个小时的比赛的前二十分钟，他们想要读所有的题目，而后他们三个人每个人给每一道题目标一个数字，即某个人 AC 某道题的最小时间，并且一定会 AC。
+ 每个队伍只有一台电脑，因而让一个队伍同时肝两道题是不可能的。
+ 为避免大脑烧毁或心肺骤停（他们比赛过太多次了），他们决定在每道题后交换角色，这样没有人会连续做两道题目。
+ 他们想要尽量多做题目，做题的顺序则无关紧要。

## 样例 #1

### 输入

```
2
3
100 100 80
190 120 90
120 150 100
4
50 20 300 300
200 100 30 250
140 120 100 100```

### 输出

```
2
4```

# AI分析结果



## 算法分类
动态规划（状态压缩）

---

## 题解思路、算法要点与解决难点

### 核心思路对比
1. **AlexandreLea（记忆化搜索）**  
   - **状态设计**：`(sol, las, tot)` 表示已选题目集合（位掩码）、上一个做题的人、当前总时间。  
   - **转移方式**：枚举下一个做题的人（必须与上一个不同）和未选的题目，递归计算最大题数。  
   - **优化点**：记忆化数组避免重复计算，直接剪枝超时状态。

2. **Big_Dinosaur（状压DP预处理最小时间）**  
   - **状态设计**：`dp[i][j]` 表示已选题目集合 `i` 且最后做题者为 `j` 的最小总时间。  
   - **转移方式**：枚举每个可能的题和做题者，从前序状态转移取最小值。  
   - **优化点**：预处理所有可能的最小时间，统计合法状态的最大题数。

### 解决难点
- **状态压缩**：通过位掩码高效表示已选题目集合。  
- **交替限制**：确保相邻题目由不同人完成。  
- **时间约束**：在状态转移中动态累加时间并判断合法性。

---

## 题解评分（≥4星）

1. **AlexandreLea（★★★★）**  
   - 思路清晰，代码简洁，记忆化搜索直接反映问题逻辑。  
   - 正确处理时间从0开始累计，严格限制280分钟。  
   - 核心代码片段：  
     ```cpp
     int dp(int sol, int las, int tot) {
         if (tot >= 280) return 0;
         if (las != 0 && memo[sol][las][tot] != -1) return memo[sol][las][tot];
         int ans = 0;
         for (int i = 1; i <= 3; ++i) {
             if (i != las) {
                 for (int j = 1; j <= n; ++j) {
                     if (!(sol & (1 << (j-1))) && tot + t[i][j] <= 280) {
                         ans = max(ans, 1 + dp(sol | (1 << (j-1)), i, tot + t[i][j]));
                     }
                 }
             }
         }
         return las ? memo[sol][las][tot] = ans : ans;
     }
     ```

2. **Big_Dinosaur（★★★★）**  
   - 预处理最小时间，避免递归开销，高效遍历所有状态。  
   - 状态转移方程正确，初始化严谨。  
   - 核心代码片段：  
     ```cpp
     for (ri i = 1; i < (1 << n); ++i) {
         for (ri k = 1; k <= n; ++k) {
             if ((i >> (k-1)) & 1) {
                 dp[i][1] = min(dp[i][1], min(dp[i^(1<<(k-1))][2], dp[i^(1<<(k-1))][3]) + a[1][k]);
                 dp[i][2] = min(dp[i][2], min(dp[i^(1<<(k-1))][1], dp[i^(1<<(k-1))][3]) + a[2][k]);
                 dp[i][3] = min(dp[i][3], min(dp[i^(1<<(k-1))][1], dp[i^(1<<(k-1))][2]) + a[3][k]);
             }
         }
         if (min({dp[i][1], dp[i][2], dp[i][3]}) <= 280) {
             Ans = max(Ans, cnt(i));
         }
     }
     ```

---

## 最优思路提炼
- **状态压缩**：用位掩码表示已选题目集合，空间复杂度可控。  
- **交替限制处理**：在状态中记录上一个做题者，转移时排除相同者。  
- **时间约束**：动态累加时间并剪枝，或预处理最小时间判断合法性。

---

## 同类型题推荐
1. **P1433 吃奶酪**（状态压缩DP）  
2. **P1171 售货员的难题**（TSP问题，状压DP）  
3. **P1278 单词游戏**（状态压缩+字符串匹配）

---

## 可视化与算法演示设计
### 动画方案
- **像素风格界面**：题目用彩色方块表示，选中后变灰，当前做题者用不同颜色标记。  
- **状态面板**：显示当前已选题目数、剩余时间、上一个做题者。  
- **动态转移**：高亮当前选择的题目和做题者，显示时间累加过程。  
- **音效提示**：每次选题播放“点击”音效，超时或完成时播放不同音效。

### 交互设计
- **步进控制**：支持暂停/继续、单步执行观察状态变化。  
- **自动演示**：AI自动选择最优路径，展示如何达到最大题数。  
- **网格绘制**：Canvas绘制题目网格，状态变化实时更新颜色。  

---

## 个人心得摘录
- **避免 `map`**：AlexandreLea指出使用数组代替 `map` 提升性能，避免超时。  
- **初始化细节**：Big_Dinosaur强调正确初始化 `dp` 数组为极大值，确保状态转移正确。  

---

## 代码实现（关键片段）
### AlexandreLea 记忆化搜索
```cpp
int dp(int sol, int las, int tot) {
    if (tot >= 280) return 0;
    if (las != 0 && memo[sol][las][tot] != -1) return memo[sol][las][tot];
    int ans = 0;
    for (int i = 1; i <= 3; ++i) {
        if (i != las) {
            for (int j = 1; j <= n; ++j) {
                if (!(sol & (1 << (j-1))) && tot + t[i][j] <= 280) {
                    ans = max(ans, 1 + dp(sol | (1 << (j-1)), i, tot + t[i][j]));
                }
            }
        }
    }
    return las ? memo[sol][las][tot] = ans : ans;
}
```

### Big_Dinosaur 状压DP
```cpp
for (ri i = 1; i < (1 << n); ++i) {
    for (ri k = 1; k <= n; ++k) {
        if ((i >> (k-1)) & 1) {
            dp[i][1] = min(dp[i][1], min(dp[i^(1<<(k-1))][2], dp[i^(1<<(k-1))][3]) + a[1][k]);
            dp[i][2] = min(dp[i][2], min(dp[i^(1<<(k-1))][1], dp[i^(1<<(k-1))][3]) + a[2][k]);
            dp[i][3] = min(dp[i][3], min(dp[i^(1<<(k-1))][1], dp[i^(1<<(k-1))][2]) + a[3][k]);
        }
    }
    if (min({dp[i][1], dp[i][2], dp[i][3]}) <= 280) {
        Ans = max(Ans, cnt(i));
    }
}
```

---
处理用时：210.57秒
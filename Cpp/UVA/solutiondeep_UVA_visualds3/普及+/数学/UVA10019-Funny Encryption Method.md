# 题目信息

# Funny Encryption Method

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=12&page=show_problem&problem=960

[PDF](https://uva.onlinejudge.org/external/100/p10019.pdf)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA10019/ab61a55b13f53a52e7e0fb57d2b672a1a2942116.png)

## 样例 #1

### 输入

```
3
265
111
1234```

### 输出

```
3 5
6 3
5 5```

# AI分析结果



---

## **唯一算法分类**
位运算 / 进制转换

---

## **题解思路与算法要点**
### **核心逻辑**
- **十进制转二进制**：统计二进制中1的个数，可通过逐次除以2取余或位运算优化。
- **十六进制转二进制**：将十六进制数的每一位（0-9）视为独立四位二进制，预存每个十进制数字的二进制1的个数，直接查表累加。

### **解决难点**
1. **十六进制的特殊处理**  
   - 关键点：十六进制数的每一位对应固定四位二进制，无需完整转换，只需查表计算。
   - 示例：数字5的十六进制位对应二进制0101，含2个1，预存为表项`a[5] = 2`。
2. **时间复杂度优化**  
   - 内置函数`__builtin_popcount`或`lowbit`可将时间复杂度从$O(\log n)$优化至$O(k)$（$k$为1的个数）。

---

## **题解评分 (≥4星)**
### **4.5星：Siteyava_145**
- **亮点**：直接调用`__builtin_popcount`处理十进制部分，十六进制部分查预存表，代码简洁高效。
- **代码片段**：
  ```cpp
  int x=__builtin_popcount(n); // 十进制处理
  while(n) xx+=__builtin_popcount(n%10), n/=10; // 十六进制逐位查表
  ```

### **4星：_Kouki_**
- **亮点**：预存0-9的二进制1个数，避免重复计算，逻辑清晰。
- **代码片段**：
  ```cpp
  int getnum[10]={0,1,1,2,1,2,2,3,1,2}; // 预存表
  ans += getnum[tmp%10]; // 查表累加
  ```

### **4星：ICU152_lowa_IS8**
- **亮点**：引入`lowbit`优化统计1的个数，适合更大数据范围。
- **代码片段**：
  ```cpp
  int checksum(int n){ // lowbit统计1的个数
      int ans=0;
      for(int i=n; i; i-=lowbit(i)) ans++;
      return ans;
  }
  ```

---

## **最优思路与技巧提炼**
### **关键技巧**
1. **预存表加速**  
   - 将0-9的每个数字对应的二进制1个数预先计算并存储，避免重复位运算。
   - **适用场景**：固定范围内的离散值处理（如进制位、字符映射）。
2. **内置函数优化**  
   - 使用`__builtin_popcount`直接统计二进制1的个数，依赖编译器优化。
   - **注意**：需确保题目允许调用非标准库函数。
3. **lowbit技巧**  
   - 通过`t & (-t)`快速定位最低位的1，循环消除所有1，时间复杂度最优。

---

## **同类型题与算法套路**
### **通用解法**
- **二进制统计问题**：统计某数的二进制表示特性（如1的个数、最低位1的位置）。
- **进制转换优化**：预存进制位映射表，避免重复计算。

### **推荐题目**
1. **P1143 进制转换**（洛谷，基础进制转换）
2. **P1062 数列**（二进制表示与数列构造）
3. **P7072 [CSP-J2020] 直播获奖**（位运算优化排名统计）

---

## **个人心得摘录**
- **Amberhart**：调试中发现十六进制处理需逐位拆分，否则会死循环。
- **ICU152_lowa_IS8**：`lowbit`灵感来自树状数组，强调算法迁移能力。

---

## **可视化算法设计**
### **动画方案**
- **核心流程**：  
  1. **十进制处理**：数字逐次除以2，高亮余数为1的步骤，右侧同步显示二进制位堆积。  
  2. **十六进制处理**：分解数字每位（如265→2/6/5），每步显示查表结果（2→1，6→2，5→2），底部累加总数。
  
- **交互设计**：  
  - **像素风格**：使用8位色调色板（红、绿、蓝）标记当前操作位。  
  - **音效**：每次统计1时播放“哔”声，完成时播放8位胜利音效。  
  - **自动演示**：按步执行，支持暂停/继续，速度可调。

### **代码片段（Canvas绘图）**
```javascript
// 绘制十进制转换过程（伪代码）
function drawDecimalStep(n, step) {
    let bits = [];
    while (n > 0) {
        bits.push(n % 2);
        n = Math.floor(n / 2);
    }
    // 高亮当前步骤的余数
    ctx.fillStyle = bits[step] === 1 ? '#FF0000' : '#00FF00';
    drawBit(step, bits[step]);
}
```

---

## **完整代码示例**
### **最优实现（_Kouki_ 思路）**
```cpp
#include <cstdio>
int getnum[10] = {0,1,1,2,1,2,2,3,1,2}; // 预存表

int main() {
    int T, n;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        int cnt10 = 0, cnt16 = 0, tmp = n;
        // 十进制处理
        while (tmp) {
            cnt10 += tmp % 2;
            tmp /= 2;
        }
        // 十六进制处理
        tmp = n;
        while (tmp) {
            cnt16 += getnum[tmp % 10];
            tmp /= 10;
        }
        printf("%d %d\n", cnt10, cnt16);
    }
    return 0;
}
```

---
处理用时：85.27秒
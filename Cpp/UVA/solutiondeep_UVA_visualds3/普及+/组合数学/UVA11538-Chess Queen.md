# 题目信息

# Chess Queen

## 题目描述

你一定知道国际象棋是怎么玩的，以及皇后是怎么运作的吧。如果两个皇后在同一列，同一行或者同一对角线上，她们就会互相攻击。

例如，有两个皇后（一白一黑）放置在$2×2$的棋盘上，那么有$12$中放置方式可以使她们互相攻击。如下图所示。（见PDF版题面）

给出棋盘的大小，请你计算有多少种放置皇后的方式，可以使她们互相攻击。

## 样例 #1

### 输入

```
2 2
100 223
2300 1000
0 0```

### 输出

```
12
10907100
11514134000```

# AI分析结果



### 唯一算法分类  
组合数学

---

### 题解思路与算法分析  

#### **核心思路**
将问题拆解为三个互斥情况：同行攻击、同列攻击、同对角线攻击。通过组合数学公式直接计算每种情况的数量，最终求和。关键推导点在于对角线的数学建模与求和化简。

#### **解决难点**
1. **对角线长度分布建模**：当 n ≤ m 时，对角线长度序列为 1,2,...,n-1, [n重复(m-n+1次)], n-1,...,1。需将每个长度对应的组合数累加。
2. **求和公式化简**：将复杂的累加式转化为封闭式公式，避免遍历计算。核心公式推导为 ∑i² 与 ∑i 的经典组合恒等式应用。
3. **数值溢出处理**：使用 unsigned long long 类型确保大数计算不溢出。

#### **算法流程**
1. **输入处理**：交换 n,m 确保 n ≤ m。
2. **同行/列计算**：公式为 mn(m+n-2)。
3. **对角线计算**：公式为 2n(n-1)(3m-n-1)/3。
4. **结果相加**：总方案数 = 行方案 + 列方案 + 对角线方案。

---

### 题解评分（≥4星）  

1. **TemplateClass（5星）**  
   - 思路清晰，数学推导完整，公式化简最简洁。  
   - 代码直接套用最终公式，无冗余计算。  
   - 最佳实践：交换 n,m 简化推导，数据类型选择合理。

2. **Sternenlicht（4星）**  
   - 分步推导详细，代码注释清晰。  
   - 变量命名规范，swap 操作显式处理输入条件。

3. **xiezheyuan（4星）**  
   - 提供详细公式推导步骤，适合数学验证。  
   - 代码结构简洁，逻辑与数学推导一一对应。

---

### 最优思路提炼  
**关键技巧**：  
1. **数学建模优先**：将物理问题（棋盘布局）转化为数学序列求和问题。  
2. **组合恒等式应用**：利用 ∑i² = n(n+1)(2n+1)/6 等公式快速化简复杂求和。  
3. **对称性简化**：交换 n,m 统一处理条件分支，减少代码复杂度。  
4. **封闭式公式计算**：避免循环累加，直接 O(1) 计算结果。

---

### 同类型题与算法套路  
**通用套路**：  
- **棋盘攻击问题**：通过分情况（行、列、对角线）建模，组合数学计算。  
- **组合计数优化**：寻找规律将累加式转化为闭合公式。  

**推荐题目**：  
1. [P2789 直线交点数](https://www.luogu.com.cn/problem/P2789)  
2. [P1357 食物链](https://www.luogu.com.cn/problem/P1357)  
3. [CF615B Longtail Hedgehog](https://codeforces.com/problemset/problem/615/B)  

---

### 可视化与算法演示设计  
**动画方案**：  
1. **棋盘绘制**：Canvas 绘制 n×m 网格，不同攻击路径用颜色区分（红-行、蓝-列、绿-对角线）。  
2. **公式分步高亮**：  
   - 显示当前计算部分（如行方案），对应棋盘区域闪烁。  
   - 对角线长度分布以动态条形图展示，长度变化伴随音效。  
3. **复古像素风格**：  
   - 8-bit 音效：计算完成时播放 "NES 过关" 音效，错误时播放 "爆炸" 音效。  
   - 像素字体与棋盘格子，背景循环播放 chiptune 音乐。  
4. **交互控制**：  
   - 速度滑块调节公式展开速度。  
   - 单步执行：点击按钮逐步显示行、列、对角线的计算结果。  

**代码片段（伪代码）**：  
```javascript
// 绘制棋盘
ctx.fillStyle = '#8B8B8B';
for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
        ctx.fillRect(i * 20, j * 20, 18, 18);
    }
}

// 高亮当前计算部分
function highlightAttack(type) {
    switch (type) {
        case 'row': // 红色闪烁行
            ctx.fillStyle = 'rgba(255,0,0,0.5)';
            break;
        case 'diag': // 绿色填充对角线
            drawDiagonals('green');
            break;
    }
    requestAnimationFrame(update);
}
```

---

### 核心代码实现  
**Sternenlicht 题解代码**：  
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;

int main() {
    unsigned LL n, m;
    while (cin >> n >> m && n && m) {
        if (n > m) swap(n, m);
        cout << n * m * (m + n - 2) 
             + 2 * n * (n - 1) * (3 * m - n - 1) / 3 
             << endl;
    }
    return 0;
}
```

**代码要点**：  
- `swap(n, m)` 确保 n ≤ m，统一处理公式条件。  
- 直接套用最终组合公式，无循环计算。  
- 使用 `unsigned LL` 防止溢出。

---
处理用时：90.43秒
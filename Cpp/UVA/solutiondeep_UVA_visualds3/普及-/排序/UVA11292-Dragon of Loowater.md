# 题目信息

# Dragon of Loowater

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/tqycbsg2.png)

从前，在 Loowater 王国，一场小麻烦变成了一个大问题。Loowater 中部的 Rellau 溪岸一直是大雁繁殖的理想之地。由于缺乏天敌，大雁的数量失控。Loowater 的人民大多远离大雁。偶尔会有一只大雁袭击人们，可能会咬掉一两个手指，但总的来说，人民把大雁当作一个小麻烦忍受着。

有一天，一次奇怪的变异发生了，一只大雁产下了一条多头的喷火龙。当这条龙长大后，它威胁要把 Loowater 王国烧成灰烬。Loowater 遇到了一个大问题。国王十分惊恐，召集他的骑士们去屠龙，拯救王国。

骑士们解释道：“要屠龙，我们必须砍下它所有的头。每个骑士只能砍掉龙的一个头。龙的头大小不一。为了砍掉一个头，骑士必须至少和龙头的直径一样高。骑士工会要求，砍掉一个头的骑士必须得到相当于其身高每厘米一枚金币的报酬。”

有足够的骑士来打败这条龙吗？国王召集他的顾问们来帮他决定该雇佣多少骑士以及选择哪些骑士。在花费大量金钱建造米尔公园后，国王想要将屠龙的开支降到最低。作为顾问之一，你的任务是帮助国王。你非常认真地对待这个任务：如果失败了，你和整个王国都将被烧成灰烬！

## 样例 #1

### 输入

```
2 3
5
4
7
8
4
2 1
5
5
10
0 0```

### 输出

```
11
Loowater is doomed!```

# AI分析结果



# 【算法分类】
**贪心算法**

---

# 【题解思路与难点分析】

## **核心思路**
- **排序+双指针贪心匹配**：将龙头直径与骑士身高分别排序，从小到大依次匹配。每个龙头选择能砍掉它的最小身高骑士，确保总费用最低。

## **解决难点**
1. **正确性证明**：需证明贪心策略（最小可用骑士优先匹配最小头）能获得全局最优解。反证法可证，若存在更优方案，必可通过交换得到更小费用。
2. **多组数据处理**：循环读取输入直到 `n=0, m=0`，每次需重置变量与数组。
3. **无解判断**：若排序后骑士数量不足或存在头直径超过所有骑士身高，则无法解决。

## **算法流程**
1. 输入龙头与骑士数据。
2. 排序龙头数组 `A` 和骑士数组 `B`。
3. 双指针遍历：`cur` 指向当前待处理的头，`i` 遍历骑士。若 `B[i] >= A[cur]`，则雇佣该骑士，累加费用并移动 `cur`。
4. 若 `cur` 未遍历完所有头，输出失败。

---

# 【题解评分 ≥4星】

1. **尚君子（★★★★☆）**  
   - **亮点**：代码简洁，变量命名清晰，双指针逻辑直观。  
   - **代码片段**：
     ```cpp
     sort(A, A+n); sort(B, B+m);
     int cur = 0, cost = 0;
     for (int i=0; i<m; i++) {
         if (B[i] >= A[cur]) {
             cost += B[i];
             if (++cur == n) break;
         }
     }
     ```

2. **Kyrie_Harry_Irving（★★★★☆）**  
   - **亮点**：代码风格简洁，逻辑与尚君子一致，变量名稍简。  
   - **核心逻辑**：同双指针遍历，无冗余步骤。

3. **张亦弛（★★★★☆）**  
   - **亮点**：详细注释与初始化处理，适合初学者理解。  
   - **代码片段**：
     ```cpp
     while (a <= n) {
         if (b > m) break;
         if (head[a] <= killer[b]) {
             ans += killer[b];
             a++; b++;
         } else b++;
     }
     ```

---

# 【最优思路提炼】
- **排序贪心**：排序后，用最小可用骑士处理最小头。
- **双指针遍历**：避免重复匹配，时间复杂度最优（O(n log n + m log m)）。
- **极值处理技巧**：如雨季题解中插入极大值防止 `lower_bound` 越界。

---

# 【同类型题推荐】
1. **P1090 合并果子**：贪心选择最小代价合并。
2. **P1208 [USACO1.3]混合牛奶**：排序后选择单价最低的牛奶。
3. **P1223 排队接水**：贪心安排最小等待时间。

---

# 【可视化设计】
**动画方案**：
1. **像素风格排序展示**：  
   - 龙头与骑士显示为两列像素方块（红/蓝），排序后按高度排列。
   - 高亮当前匹配的龙头与骑士，成功匹配时播放“金币音效”。
2. **双指针移动**：  
   - 用箭头标记当前指针位置，匹配后移动指针。
3. **失败/成功动画**：  
   - 成功：龙头全消失，显示总费用；失败：龙头喷火，播放8-bit失败音效。

**交互功能**：
- **速度调节**：滑动条控制动画速度。
- **单步执行**：按钮逐帧观察匹配过程。
- **音效开关**：启用/禁用操作音效与背景音乐。

---

# 【核心代码实现】
```cpp
// 尚君子题解完整代码
#include <cstdio>
#include <algorithm>
using namespace std;

const int maxn = 20000 + 5;
int A[maxn], B[maxn];
int main() {
    int n, m;
    while (scanf("%d%d", &n, &m) == 2 && n && m) {
        for (int i = 0; i < n; i++) scanf("%d", &A[i]);
        for (int i = 0; i < m; i++) scanf("%d", &B[i]);
        sort(A, A + n);
        sort(B, B + m);
        int cur = 0, cost = 0;
        for (int i = 0; i < m; i++) {
            if (B[i] >= A[cur]) {
                cost += B[i];
                if (++cur == n) break;
            }
        }
        printf(cur < n ? "Loowater is doomed!\n" : "%d\n", cost);
    }
    return 0;
}
```

---
处理用时：82.01秒
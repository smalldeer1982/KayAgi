# 题目信息

# 分子量 Molar mass

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=448&page=show_problem&problem=4461

[PDF](https://uva.onlinejudge.org/external/15/p1586.pdf)

## 样例 #1

### 输入

```
4
C
C6H5OH
NH2CH2COOH
C12H22O11```

### 输出

```
12.010
94.108
75.070
342.296```

# AI分析结果



**算法分类**  
字符串处理，模拟

---

**题解思路与核心难点**  
1. **核心逻辑**：遍历分子式字符串，逐个处理每个元素及其后的数字下标。若元素后无数字，则默认下标为1。
2. **关键难点**：
   - **多位数下标处理**：需连续读取多个数字字符并转换为整数（如`C12`中的`12`）。
   - **边界条件**：元素位于字符串末尾或其后紧跟其他元素时，需正确识别下标为1。
3. **数据结构**：使用 `map` 或数组存储原子量，简化代码逻辑。
4. **优化点**：通过指针跳跃或特判末尾字符，避免重复处理。

---

**题解评分（≥4星）**  
1. **Zlc晨鑫（4星）**  
   - 思路清晰，逐个字符判断元素后是否为数字，直接处理多位数。
   - 代码可读性强，边界条件处理正确（如末尾元素无需特判）。
   - 示例输入处理正确，无冗余代码。

2. **hzg0226（4星）**  
   - 逻辑简洁，通过条件判断直接区分元素后是否为数字或字母。
   - 使用 `pos` 遍历字符串，无需复杂索引管理，代码直观。

3. **Snowlanuck（4星）**  
   - 巧妙添加末尾标记字符`P`，简化越界判断。
   - 通过 `isalpha` 和 `isdigit` 函数组合处理，逻辑清晰。

---

**最优思路与技巧**  
1. **核心技巧**：对每个元素字符，向后扫描连续数字字符并转换为整数。若无数字，则视为下标1。
2. **代码实现**：
   ```cpp
   for (int i = 0; i < s.size(); i++) {
       if (isalpha(s[i])) {
           int num = 0;
           if (i + 1 == s.size() || isalpha(s[i + 1])) {
               sum += get_value(s[i]);
           } else {
               while (i + 1 < s.size() && isdigit(s[i + 1])) {
                   num = num * 10 + (s[++i] - '0');
               }
               sum += get_value(s[i - num_digits]) * (num ? num : 1);
           }
       }
   }
   ```
3. **优化点**：使用 `map` 存储原子量，避免重复分支判断。

---

**同类题目推荐**  
1. **P1994 有机物燃烧**：类似字符串解析，需处理元素与系数。
2. **P1067 多项式输出**：字符串模拟，处理系数与格式。
3. **P1022 计算器的改良**：解析方程中的变量与系数。

---

**可视化与算法演示**  
1. **动画设计**：
   - **字符高亮**：当前处理的元素标记为绿色，后续数字标记为黄色。
   - **步骤分解**：遍历字符串时，动态显示当前元素和下标计算过程。
   - **总和更新**：每次处理完一个元素后，更新总和并显示公式（如 `C12 → +12.01*12`）。
2. **复古像素风格**：
   - 使用 8-bit 字体和方格显示字符串，元素与数字用不同颜色区分。
   - 音效设计：元素处理成功时播放“哔”声，总和更新时播放“叮”声。
3. **交互功能**：支持暂停/继续、单步执行，速度可调。

---

**代码片段（核心逻辑）**  
以 **hzg0226** 的代码为例：
```cpp
for (int pos = 0; pos < fenzishi.size(); pos++) {
    char yuansu = fenzishi[pos];
    if (pos + 1 == fenzishi.size() || isalpha(fenzishi[pos + 1])) {
        sum += atom[yuansu]; // 无数字，下标为1
    } else {
        int num = 0;
        while (pos + 1 < fenzishi.size() && isdigit(fenzishi[pos + 1])) {
            num = num * 10 + (fenzishi[++pos] - '0'); // 跳跃处理数字
        }
        sum += atom[yuansu] * num;
    }
}
```

---

**个人心得摘录**  
- **Snowlanuck**：添加标记字符`P`简化边界判断，避免复杂越界检查。
- **EnderXie**：通过字符串转换（如插入空格）利用 `stringstream` 简化解析，但需注意输入格式兼容性。
- **调试教训**：多位数字处理需注意指针跳跃，否则会导致重复计算或遗漏（如 `C12H` 中的 `H` 未被处理）。

---
处理用时：274.26秒
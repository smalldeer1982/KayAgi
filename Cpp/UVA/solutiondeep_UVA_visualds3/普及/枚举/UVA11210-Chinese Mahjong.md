# 题目信息

# Chinese Mahjong

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=2151

[PDF](https://uva.onlinejudge.org/external/112/p11210.pdf)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11210/00db9c6ee014cb07d2ff71e0aff3d224225bbbd1.png)

## 样例 #1

### 输入

```
1S 1S 2S 2S 2S 3S 3S 3S 7S 8S 9S FA FA
1S 2S 3S 4S 5S 6S 7S 8S 9S 1T 3T 5T 7T
0```

### 输出

```
Case 1: 1S 4S FA
Case 2: Not ready```

# AI分析结果



## 算法分类
**回溯算法 + 枚举**

---

## 题解思路与核心难点

### 核心算法流程
1. **枚举候选牌**：遍历34种可能添加的牌（需排除已有4张的情况）
2. **检查胡牌条件**：
   - **找将牌**：遍历所有牌，尝试选取两张作为对子
   - **分解剩余牌**：用DFS/回溯尝试将剩余牌拆分为4组刻子或顺子
3. **合法性校验**：
   - 顺子需满足同花色且连续（如1S2S3S合法，8T9T1S不合法）
   - 刻子需三张相同牌
   - 总牌数为14张（13原牌+1候选）

### 解决难点对比
| 题解差异点       | Luan_233                       | Parabola                     | 残阳如血                     |
|------------------|--------------------------------|------------------------------|------------------------------|
| **牌型表示**     | 分5类数组（万/筒/索/风/三元） | 统一编号0-34                 | 统一编号0-34                 |
| **顺子检查**     | 显式范围限制（i<=7等）        | 数学约束（i%9 <=6）          | 预处理合法顺子位置           |
| **回溯方式**     | 递归层级控制（deep>=4终止）   | 剩余牌数递减                 | 固定分阶段（先刻子后顺子）   |
| **优化点**       | 提前剪枝（牌数非3倍数）       | 按花色分组处理               | 优先处理字牌减少分支         |

---

## 题解评分（≥4星）

### 1. Parabola（★★★★☆）
- **亮点**：代码简洁，使用统一编号映射，输出顺序处理清晰
- **核心代码**：
```cpp
bool check(int k) {
    memset(c, 0, sizeof c);
    for(int i=0; i<13; ++i) ++c[tile[i]];
    ++c[k];
    if(c[k]>4) return false;
    // ...回溯检查逻辑
}
```

### 2. 残阳如血（★★★★☆）
- **亮点**：递归逻辑分层明确，预处理合法顺子位置
- **关键片段**：
```cpp
bool search(int dep) {
    for(int i=0; i<34; i++) if(c[i]>=3) { // 刻子检查
        c[i] -=3;
        if(search(dep+1)) return true;
        c[i] +=3;
    }
    // ...顺子检查
}
```

### 3. SIGSEGV（★★★★☆）
- **亮点**：严格处理输出顺序，包含特殊牌型快速判断
- **心得摘录**：
> "输出要按筒，索，万，东南西北，中發白的顺序...打多了容易错顺序"

---

## 最优技巧提炼

### 关键数据结构
- **统一编号映射**：将各类牌映射为0-34的连续编号，简化后续处理
```cpp
const string mj[] = {"1T","2T",...,"BAI"};
map<string, int> m; // 建立双向映射
```

### 回溯优化技巧
1. **分层剪枝**：优先处理字牌（无法形成顺子），减少递归分支
2. **增量检查**：从最小编号牌开始处理，避免重复组合
3. **状态恢复**：在递归返回时及时恢复牌数，确保回溯正确性

### 合法性校验
```cpp
// 顺子合法性判断（以万牌为例）
if(i%9 <=6 && c[i] && c[i+1] && c[i+2]) {
    c[i]--; c[i+1]--; c[i+2]--;
    if(dfs(...)) return true;
    c[i]++; c[i+1]++; c[i+2]++;
}
```

---

## 类似题目推荐
1. **洛谷P1784 数独**（回溯+剪枝）
2. **LeetCode 37. Sudoku Solver**（矩阵回溯）
3. **UVA 167 八皇后**（经典回溯问题）

---

## 可视化设计

### 动画方案
![麻将回溯可视化](https://i.imgur.com/9sXmJqC.gif)
（想象：左侧为当前牌堆，右侧展示候选牌添加与分组过程）

#### 核心元素：
1. **牌堆展示**：用不同颜色区分万（红）、筒（蓝）、索（绿）、字牌（黄）
2. **高亮标记**：
   - 当前候选牌：闪烁金色边框
   - 已选将牌：紫色底色
   - 刻子/顺子组：动态收缩为组块
3. **回溯路径**：用半透明线条显示递归路径，失败分支变灰

#### 复古风格实现
```javascript
// 示例：8位风格牌绘制
function drawTile(ctx, x, y, num) {
    ctx.fillStyle = ['#FF5555','#5555FF','#55FF55','#FFFF55'][Math.floor(num/9)];
    ctx.fillRect(x, y, 32, 48); // 像素化牌面
    ctx.fillStyle = '#000';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText(mj[num], x+4, y+12);
}
```

#### 音效设计
- **添加牌**：8-bit "blip" 音效（[JSFiddle示例](https://jsfiddle.net/7s2xoq9d/)）
- **成功分组**：上升音阶（C-E-G）
- **回溯失败**：低音"buzz"

---

## 代码实现（核心逻辑）
以Parabola题解为例的关键函数：
```cpp
bool dfs(int step) {
    if(step == 4) return true; // 成功分组4次
    // 尝试刻子
    for(int i=0; i<34; ++i) if(c[i]>=3) {
        c[i] -= 3;
        if(dfs(step+1)) { c[i] +=3; return true; }
        c[i] +=3;
    }
    // 尝试顺子
    for(int i=0; i<=24; ++i) 
        if(i%9<=6 && c[i] && c[i+1] && c[i+2]) {
            c[i]--; c[i+1]--; c[i+2]--;
            if(dfs(step+1)) { c[i]++; c[i+1]++; c[i+2]++; return true; }
            c[i]++; c[i+1]++; c[i+2]++;
        }
    return false;
}
```

---
处理用时：83.15秒
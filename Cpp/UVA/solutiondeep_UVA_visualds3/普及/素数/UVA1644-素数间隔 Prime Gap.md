# 题目信息

# 素数间隔 Prime Gap

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=825&page=show_problem&problem=4519

[PDF](https://uva.onlinejudge.org/external/16/p1644.pdf)

# AI分析结果



# 素数间隔 Prime Gap 题解分析

## 唯一算法分类
筛法求素数

---

## 综合分析与结论

### 核心思路
题目要求快速判断给定的数是否为素数，若非素数则输出相邻两素数的间隔。核心难点在于高效生成素数表并快速查找相邻素数。所有题解均采用**预处理素数表**的方法，主要差异体现在筛法选择（欧拉筛 vs 埃氏筛）和查找方式（线性查找 vs 二分查找）。

### 算法流程与可视化设计
1. **欧拉筛预处理**  
   - **关键变量**：`visit[]` 标记合数，`prime[]` 存储素数  
   - **高亮步骤**：外层循环每个数i，内层用已知素数筛除i的倍数  
   - **动画效果**：在Canvas中绘制数轴，用红色标记被筛掉的合数，绿色标记新发现的素数  

2. **查找相邻素数**  
   - **二分查找优化**：在预处理好的素数数组中，通过二分快速定位第一个大于n的素数位置  
   - **高亮对比**：线性查找（黄色指针逐步移动） vs 二分查找（蓝色跳跃指针）  

### 复古像素风实现
- **颜色方案**：16色FC风格，素数用绿色方块，合数红色，当前处理数黄色闪烁  
- **音效设计**：  
  - 筛除合数时播放“哔”声  
  - 找到相邻素数时播放胜利音效  
- **自动演示**：按固定间隔执行筛法步骤，可暂停观察当前筛的状态  

---

## 题解清单（≥4星）

### 1. 封禁用户（4星）
- **亮点**：完整的欧拉筛实现，处理输入逻辑清晰  
- **优化点**：线性查找可改进为二分  
- **代码节选**：
  ```cpp
  for(register int j=1; prime[j]*i<=1299709&&j<=ans; ++j) {
      visit[i*prime[j]] = true;
      if(!(i%prime[j])) break;
  }
  ```

### 2. xixike（4星）
- **亮点**：结合二分查找提升效率  
- **关键代码**：
  ```cpp
  int l=1, r=tot;
  while(l<=r){
      int mid=(l+r)>>1;
      if(p[mid]<=n) l=mid+1;
      else r=mid-1;
  }
  ```

### 3. 珅肐（4星）
- **亮点**：使用`lower_bound`简化查找逻辑  
- **代码亮点**：
  ```cpp
  int o = lower_bound(prime+1, prime+cnt+1, n) - prime;
  printf("%d\n", prime[o] - prime[o-1]);
  ```

---

## 最优思路提炼

### 关键技巧
1. **欧拉筛法**：时间复杂度O(n)，每个合数仅被标记一次  
2. **预处理+二分**：将查询复杂度从O(n)降至O(log n)  
3. **输入处理技巧**：先读一次再进循环，避免漏判结束条件  

### 同类型题套路
- 预处理素数表 → 快速查询类问题  
- 区间素数间隔 → 转化为数组相邻元素差  

---

## 推荐练习题
1. **P3383** 线性筛素数（模板题）  
2. **P1217** 回文素数（筛法+特殊性质判断）  
3. **P3912** 素数个数统计（大数据范围筛法）  

---

## 个人心得摘录
- **封禁用户**："while循环前要先读一次，否则会死循环"  
- **Hoichai**："UVA输入要持续读直到n=0，类似岛国题目格式"  
- **yoyiETO**："埃氏筛i*i<=n足够，不需要全筛"  

---

## 核心代码实现

### 欧拉筛主体
```cpp
void euler_sieve() {
    memset(visit, 0, sizeof(visit));
    int cnt = 0;
    for(int i=2; i<=MAXN; ++i){
        if(!visit[i]) prime[++cnt] = i;
        for(int j=1; j<=cnt && i*prime[j]<=MAXN; ++j){
            visit[i*prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
```

### 二分查找相邻素数
```cpp
int find_gap(int n) {
    if(!visit[n]) return 0; // n是素数
    int l = 1, r = prime_cnt;
    while(l < r) {
        int mid = (l+r)/2;
        if(prime[mid] > n) r = mid;
        else l = mid + 1;
    }
    return prime[l] - prime[l-1];
}
```

---

## 可视化设计要点

### 像素动画实现
1. **数轴绘制**：在Canvas中绘制0~1299709的数轴，每个像素代表1000个数  
2. **筛法过程**：  
   - 当前数i用黄色方块表示  
   - 当i为素数时，其倍数用红色闪烁标记  
3. **音效触发**：  
   - 每筛除一个合数触发短促"滴"声  
   - 找到目标间隔时播放8-bit胜利音乐  

### 交互功能
- **速度滑块**：控制筛法执行速度（10ms~1000ms/步）  
- **单步执行**：按空格键逐步执行筛法  
- **高亮模式**：开启后显示当前筛的素数和被标记的合数  

通过将算法过程转化为直观的像素动画，学习者可清晰观察欧拉筛的运作机制及二分查找的高效性。

---
处理用时：74.96秒
# 题目信息

# Shoemaker's Problem

## 题目描述

有 $n$ 个任务，每个任务从接手开始每分钟罚款 $S_i$ 元，直到完成任务为止。然而每个任务需要花 $T_i$ 的时间去完成。你只能把一件任务完成才能去做下一件事情，问如何安排任务处理顺序，使得总罚款最小。注意，每个任务在第 $0$ 时刻就全部交给了你。

## 样例 #1

### 输入

```
1
4
3 4
1 1000
2 2
5 5```

### 输出

```
2 1 3 4```

# AI分析结果



**唯一算法分类**  
贪心算法（邻项交换法）

---

### **题解思路与算法要点**  
**核心思路**：通过贪心策略确定任务处理顺序。对于两个任务 $a$ 和 $b$，比较其先后处理的总罚款差异，推导出排序条件：  
$$T_a \cdot S_b < T_b \cdot S_a \implies a \text{ 优先于 } b$$  
等价于按 $S_i / T_i$ 降序排列。  

**实现要点**：  
1. **结构体存储**：每个任务的 $T_i$、$S_i$ 和原始编号。  
2. **排序函数**：比较相邻任务的乘积关系，确保局部最优。  
3. **输出处理**：末尾无空格，多测试用例间用空行分隔。  

**解决难点**：  
- **贪心策略证明**：需数学推导邻项交换的代价差异，确保全局最优。  
- **输出格式**：严格处理换行和空格，避免格式错误。  

---

### **题解评分**  
1. **Otue (★★★★★)**  
   - **亮点**：代码简洁，正确使用 `sort` 实现贪心排序，输出格式处理严谨。  
   - **代码示例**：  
     ```cpp
     bool cmp(stu x, stu y) {
         if (x.x * y.y == x.y * y.x) return x.id < y.id;
         return x.x * y.y < x.y * y.x;
     }
     ```
2. **saixingzhe (★★★★★)**  
   - **亮点**：变量命名清晰，比较条件直接，正确处理多测试用例换行。  
   - **代码示例**：  
     ```cpp
     bool cmp(Node a, Node b) {
         return a.s * b.t == a.t * b.s ? a.id < b.id : a.s * b.t > a.t * b.s;
     }
     ```
3. **yyyh_h (★★★★☆)**  
   - **亮点**：结构体命名明确，输出逻辑简洁，注释清晰。  
   - **改进点**：变量名 `x`/`y` 可更直观。  

---

### **最优思路提炼**  
**关键技巧**：  
1. **邻项比较法**：通过比较 $T_i \cdot S_j$ 和 $T_j \cdot S_i$ 确定顺序，避免全局时间计算。  
2. **稳定性处理**：若两任务等价（乘积相等），按原始编号排序。  

**适用场景**：任务调度问题中，需最小化时间累积代价的贪心排序。  

---

### **类似题目推荐**  
1. **P1233 木棍加工**：贪心排序最小化启动时间。  
2. **P1080 国王游戏**：邻项比较法确定最优排列。  
3. **P2123 皇后游戏**：类似贪心策略处理双关键字排序。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **像素风格界面**：任务显示为方块，标注 $T_i$ 和 $S_i$，颜色区分优先级。  
2. **邻项比较**：高亮当前比较的两个任务，显示乘积计算过程。  
3. **自动排序演示**：逐步交换任务位置，展示总罚款变化。  

**交互功能**：  
- **步进控制**：手动触发排序步骤，观察比较逻辑。  
- **音效提示**：任务交换时播放 8-bit 音效，完成时播放胜利音效。  

**复古效果**：  
- **Canvas 渲染**：任务方块以网格排列，背景循环播放 8-bit 音乐。  
- **积分系统**：正确排序后获得积分，错误尝试扣分。  

---

### **代码实现片段**  
**核心排序逻辑**：  
```cpp
struct Task { int t, s, id; };
bool compare(Task a, Task b) {
    int prod1 = a.t * b.s, prod2 = b.t * a.s;
    return prod1 == prod2 ? a.id < b.id : prod1 < prod2;
}
```

**输出处理逻辑**：  
```cpp
for (int i = 1; i <= n; i++) {
    cout << tasks[i].id << (i == n ? "" : " ");
}
```

---

### **总结**  
通过邻项交换法推导贪心策略，结合严格输出格式处理，确保算法高效且正确。可视化设计以像素风格和交互式排序增强理解，适用于时间敏感型调度问题。

---
处理用时：147.82秒
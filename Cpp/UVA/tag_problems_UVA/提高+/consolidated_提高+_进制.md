---
title: "Pebble Solitaire"
layout: "post"
diff: 提高+/省选-
pid: UVA10651
tag: ['模拟', '状态合并', '进制']
---

# Pebble Solitaire

## 题目描述

[原PDF](https://uva.onlinejudge.org/external/106/p10651.pdf)

Pebble Solitaire是一款有趣的游戏。你会得到一个上面有一排小洞的板，这些洞最初只有一个没有被鹅卵石占据。 游戏的目的是从棋盘上移除尽可能多的鹅卵石。如果满足以下条件，你就可以进行移动：如果存在三个相邻的、能连成一条直线的洞（不妨称它们为A，B和C），中间为B，其中A是空的，但B和C上均有一个石子。那么你可以把C上的石子移到A上，并拿走B中的石子。 你可以继续移动石子，直到无法再移动为止。

在这个问题中，我们来看一个简单的游戏变体，即一个沿着一条线放置十二个小洞的板。 每次游戏开始时，有一些洞上被放有石子。你的任务是使尽可能少的鹅卵石留在棋盘上。

![pr](https://cdn.luogu.org/upload/pic/23786.png)

在 a) 中有两种可能的移动，分别是8->6和7->9。

b) 为 a) 选择第二种移动方式的结果，此时又有两种移动方式，分别是5->7或者6->4。

c) 作为 b) 做出第一种选择的结果，此时再没有其它的移动方式了。

## 输入格式

输入的第一行为一个n，接下来有n行分别为不同的n个游戏。 每个游戏包括一行输入，正好有十二个字符，按顺序描述板的十二个空腔。每一个字符都是'-'或'o'（英语字母表中的第十五个小写字符）。‘-’（负号）表示空洞，而“o”表示洞里面有一块鹅卵石。正如你在样本中发现的那样，输入可能是不能再移动的。

## 输出格式

对于输入中的n个游戏中的每一个，输出在那一个游戏中板上能够在移动中留下的最小数量的鹅卵石。

## 输入输出样例

##### 输入样例#1：
```cpp
5
---oo-------
-o--o-oo----
-o----ooo---
oooooooooooo
oooooooooo-o
##### 输出样例#1：
```cpp
1
2
3
12
1

感谢@Ezios 提供的翻译

## 样例 #1

### 输入

```
5
---oo-------
-o--o-oo----
-o----ooo---
oooooooooooo
oooooooooo-o
```

### 输出

```
1
2
3
12
1
```



---

---
title: "校长的烦恼 Headmaster's Headache"
layout: "post"
diff: 提高+/省选-
pid: UVA10817
tag: ['动态规划 DP', '状态合并', '进制']
---

# 校长的烦恼 Headmaster's Headache

## 题目描述

斯普林菲尔德（春之田野？？？）学院的校长正在考虑为某些科目招聘新老师 现在有一批申请岗位的老师 每个老师能教一个或多个科目 校长想要选择一些申请者以保证每个科目都至少有两名老师能教 同时总共花的钱要最小

## 输入格式

输入由多组测试组成，它们的格式如下： 第一行包含三个给定的整数S，M和N， S (<=8)是科目的总数 M(<=20)是在职教师数，N(<=100)是应聘者的数量

接下来M行每行描述一个在职教师 首先给出雇佣他的花费C (10000<=C<=50000) ,接下来是他能教的科目列表 科目用1—S的整数表示 你必须保证继续聘用他们

之后N行，以同样格式给出应聘者的信息

输入以一个空测试S=0结束，你不应当处理它 （这句有些别扭，不过懂意思就好）

## 输出格式

对于每组测试，输出符合条件的最小花费
翻译贡献者UID：60885

## 样例 #1

### 输入

```
2 2 2
10000 1
20000 2
30000 1 2
40000 1 2
0 0 0
```

### 输出

```
60000
```



---

---
title: "Nuts for nuts.."
layout: "post"
diff: 提高+/省选-
pid: UVA10944
tag: ['枚举', '进制']
---

# Nuts for nuts..

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=21&page=show_problem&problem=1885

[PDF](https://uva.onlinejudge.org/external/109/p10944.pdf)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA10944/eab44d58cb45ad772b3f67192aa37528e61e5fe1.png)

## 输入格式

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA10944/a1c24b72a850b0c3c74a01bb376efca80cd04044.png)

## 输出格式

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA10944/aa27c38474cbf5db18725d954fc07f00ee41663b.png)

## 样例 #1

### 输入

```
5 5
L....
#....
#....
.....
#....
5 5
L....
#....
#....
.....
#....
```

### 输出

```
8
8
```



---

---
title: "古代象形符号 Ancient Messages"
layout: "post"
diff: 提高+/省选-
pid: UVA1103
tag: ['连通块', '进制', '构造']
---

# 古代象形符号 Ancient Messages

## 题目描述

为了理解早期文明，考古学家经常研究用古代语言编写的文本。在3000多年前的埃及使用的一种语言是基于称为象形文字的字符。如图显示了六个象形文字及其名称，在这个题目中，您需要编写一个程序来识别这六个字。

![]("C:\Users\白文礼\Desktop\4_1.png")

输入INPUT：
```

## 输入格式

输入由几个测试用例组成，每个测试用例描述一个包含一个或多个的图像。 象形文字选自图所示的那些。图像以一系列水平扫描线的形式给出，这些水平扫描线由黑色像素（由1表示）和白色像素（由0表示）组成。在输入数据中，每个扫描线以十六进制表示法编码。 例如，序列将表示八个像素10011100（一个黑色像素，后面是两个白色像素，依此类推） 十六进制表示法为9c。 在十六进制中仅使用数字和小写字母a到f编码。每个测试用例的第一行包含两个整数，H和W。H（0＜H≤200）是 图像中的扫描行数。 W（0＜W≤50）是每行中十六进制字符的数量 。 接下来的H行包含图像的十六进制字符，从上到下。
输入图像符合以下规则：
图像仅包含图1中所示的象形文字。
每个图像至少包含一个有效的象形文字。
图像中的每个黑色像素都是有效象形文字的一部分。
每个象形文字由一组连邻的黑色像素组成，即每个黑色像素至少和一个位于其顶部，底部，左侧或右侧的其他黑色像素相临。
象形文字间不相连，一个象形文字中不包含其他象形文字。
对角线顶点接触的两个黑色像素必然具有共同的相邻的黑色像素。
象形文字可能会扭曲，但其在拓扑结构上一定等同于图1中的一个符号。 （两个图形的拓扑结构等同是说一个图形通过扭曲拖拽可以成为另一个图形，但是不能撕裂。） 
在输入所有测试用例之后换行并输入两个零，表示结束。

输入样例
100 25 
0000000000000000000000000 
0000000000000000000000000 
...(50 lines omitted)... 
00001fe0000000000007c0000 
00003fe0000000000007c0000 
...(44 lines omitted)... 
0000000000000000000000000 
0000000000000000000000000
150 38 
00000000000000000000000000000000000000
00000000000000000000000000000000000000 
...(75 lines omitted)... 
0000000003fffffffffffffffff00000000000 
0000000003fffffffffffffffff00000000000 
...(69 lines omitted)... 
00000000000000000000000000000000000000
00000000000000000000000000000000000000 
0 0
```

输出OUTPUT：

```

## 输出格式

对于每个测试用例，输出其测试用例编号，后跟一个字符串，字符串包含的每一个字符都代表一个图像中的象形文字，具体对应关系如下：
Ankh：A
Wedjat：J
Djed：D 
Scarab：S
Was：W
Akhet：K

输出样例
Case 1: AKW
Case 2: AAAAA
```



---

---
title: "Tiling Dominoes"
layout: "post"
diff: 提高+/省选-
pid: UVA11270
tag: ['动态规划 DP', '进制', '插头 DP']
---

# Tiling Dominoes

## 题目描述

题目大意

给定一个m×n的矩形网格，用1×2多米诺骨牌完全平铺。 请注意，即使一个平铺的旋转与另一个平铺相匹配，它们仍算作不同的平铺。 下面显示了一个平铺示例。

## 输入格式

输入包括多组数据。每组数据占一行，包含两个整数m，n（n×m≤100）。输入结束标志为文件结束符（EOF）。

## 输出格式

对于每组数据输出一行，输出总数。

## 样例 #1

### 输入

```
2 10
4 10
8 8
```

### 输出

```
89
18061
12988816
```



---

---
title: "Even Parity"
layout: "post"
diff: 提高+/省选-
pid: UVA11464
tag: ['递推', '枚举', '进制', '概率论']
---

# Even Parity

## 题目描述

给你一个 $n \times n$ 的 $01$ 矩阵（每个元素非 $0$ 即 $1$），你的任务是把尽量少的 $0$ 变成 $1$，使得原矩阵便为偶数矩阵（矩阵中每个元素的上、下、左、右的元素（如果存在的话）之和均为偶数）。

## 输入格式

输入的第一行为数据组数 $T$（$T \le 30$）。每组数据：第一行为正整数 $n$（$1 \le n \le 15$）；接下来的 $n$ 行每行包含 $n$ 个非 $0$ 即 $1$ 的整数，相邻整数间用一个空格隔开。

## 输出格式

对于每组数据，输出被改变的元素的最小个数。如果无解，输出 $-1$。

## 样例 #1

### 输入

```
3
3
0 0 0
0 0 0
0 0 0
3
0 0 0
1 0 0
0 0 0
3
1 1 1
1 1 1
0 0 0
```

### 输出

```
Case 1: 0
Case 2: 3
Case 3: -1
```



---

---
title: "Hackers' Crackdown"
layout: "post"
diff: 提高+/省选-
pid: UVA11825
tag: ['数学', '状态合并', '进制']
---

# Hackers' Crackdown

## 题目描述

假如你是一个黑客，侵入了一个有着 $n$ 台计算机（编号为$0,1,2,3....n-1$）的网络。一共有 $n$ 种服务，每台计算机都运行着所有服务。对于每台计算机，你都可以选择一项服务，终止这台计算机和所有与它相邻计算机的该项服务（如果其中一些服务已经停止，那他们继续保持停止状态）。你的目标是让尽量多的服务完全瘫痪(即：没有任何计算及运行着该服务)

## 输入格式

输入包含多组数据，每组数据的第一行为整数 $n(1\leq n\leq 16)$ : 以下 $n$ 行每行描述一台计算机相邻的计算机，其中第一个数 $m$ 为相邻计算机个数，接下来的 $m$ 个整数为这些计算机的编号。输入结束标志 $n=0$。

## 输出格式

对于每组数据，输出完全瘫痪的服务的数量。

## 样例 #1

### 输入

```
3
2 1 2
2 0 2
2 0 1
4
1 1
1 0
1 3
1 2
0
```

### 输出

```
Case 1: 3
Case 2: 2
```



---


# 裂变

## 题目描述

1S/256M

问题背景

在一个魔法世界中，有一种神奇的宝石，一对宝石可以用两种方法裂变成一对略有差异的宝石，初始时，你有两块大小相同的宝石，每块的大小都是1单位。现在，你希望通过一系列的列表操作，使得一对大小都是1单位的宝石，至少有一块宝石的大小等于目标大小n单位。

操作规则如下:

裂变操作一：你可以将一对大小为x,y的宝石裂变成一对大小为x+y,y的宝石。

裂变操作二：你可以将一对大小为x,y的宝石裂变成一对大小为x,x+y的宝石。

输入：

第一行输入一个正整数n，表示目标宝石的大小。

输出：

输出一个整数，表示达到目标所需的最少操作次数。

样例输入：

2


样例输出：

1


数据范围

对于40%的数据，1 ≤ n ≤ 1000
对于100%的数据，1 ≤ n ≤ 10^5

样例解释

1,1通过裂变一就达到1,2

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct gemstone{
    int gem1=1,gem2=1,step=0;
};
queue<gemstone>q;
int main(){
    cin>>n;
    q.push({1,1,0});
    while(!q.empty()){
        gemstone x=q.front();
        q.pop();
        int g1=x.gem1;
        int g1=x.gem1;
        int g2=x.gem2;
        int s=x.step;
        if(g1+g2==n){
            cout<<s+1;
            break;
        }
        q.push({g1,g1+g2,s+1});
        q.push({g1+g2,g2,s+1});
    }
    return 0;
}
}
```

---

# 谁是冠军（win）

## 题目描述

谁是冠军（win）

1S/256M

【题目描述】

小方参加了小区里的乒乓球排位赛。已知一共有 
𝑛
n 位选手报名，举办方为了看看有没有节目效果，决定先进行 
𝑚
m 场比赛。每场比赛都是挑选 2 位选手进行，并且不会出现平局的情况。在每场比赛完以后，我们视胜者选手的实力比败者选手的实力强。如果出现 A 打败 B ，B 打败 C ，C 打败 A 的情况，我们认为他们的实力是相同的。

现在给出了 
𝑚
m 场比赛的情况，最终冠军是属于实力最强者。根据当前已有的 
𝑚
m 场比赛情况，请你帮助小方判断目前为止最多有多少个选手可能获得冠军（如果已知两人实力一样强，则这两人都不能成为冠军）

【输入格式】

第一行输入两个数 
𝑛
,
𝑚
n,m 表示参赛人数和比赛场数。

接下来 
𝑚
m 行，每行输入两个数 
𝑎
a 和 
𝑏
b ，表示 
𝑎
a 战胜了 
𝑏
b。

【输出格式】

输出一个数，表示最多可能有多少名选手获得冠军。

【输入样例】
3 2
1 2
1 3

【输出样例】
1

【数据范围】

对于 
30
%
30% 的数据保证，
1
≤
𝑛
,
𝑚
≤
1
0
3
,
0
<
𝑎
,
𝑏
≤
𝑛
1≤n,m≤10
3
,0<a,b≤n

对于 
100
%
100% 的数据保证，
1
≤
𝑛
,
𝑚
≤
1
0
5
,
0
<
𝑎
,
𝑏
≤
𝑛
1≤n,m≤10
5
,0<a,b≤n

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],c[100005],sum=0;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a[i]>>b[i];
    }
    for(int i=1;i<=n;i++){
        c[b[i]]=1;
    }
    for(int i=1;i<=n;i++){
        if(c[i]==0){
            sum+=1;
            sum+=1;
        }
    }
    cout<<sum;
    return 0;
}
}
```

---

# 派

## 题目描述

派
1000ms/128mb

【问题描述】

我的生日要到了！根据习俗，我需要将一些派分给大家。我有N个不同口味、不同大小的派。有F个朋友会来参加我的派对，每个人会拿到一块派（必须一个派的一块，不能由几个派的小块拼成；可以是一整个派）。

我的朋友们都特别小气，如果有人拿到更大的一块，就会开始抱怨。因此所有人拿到的派是同样大小的（但不需要是同样形状的），虽然这样有些派会被浪费，但总比搞砸整个派对好。当然，我也要给自己留一块，而这一块也要和其他人的同样大小。

请问我们每个人拿到的派最大是多少？每个派都是一个高为1，半径不等的圆柱体。

【输入格式】

第一行包含两个正整数N和F，1 ≤ N, F ≤ 10 000，表示派的数量和朋友的数量。

第二行包含N个1到10000之间的整数，表示每个派的半径。

【输出格式】

输出每个人能得到的最大的派的体积，精确到小数点后四位

【输入样例1】

3 3
4 3 3



【输出样例1】

25.1327


【输入样例2】

1 24
5



【输出样例2】

3.1416


【输入样例3】

10 5
1 4 2 3 4 5 6 5 4 2


【输出样例3】

50.2655

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f,a[10005];
bool check(double x){
    int t=0;
    for(int i=1;i<=n;i++){
        t+=int(a[i]/x);
    }
    if(t<f+1){
        return true;
    }
    return false;
}
int main(){
int main(){
    cin>>n>>f;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]=a[i]*a[i];
    }
    double l=0,r=100000000;
    while(r-l>0.00001){
        double mid=(l+r)/2;
        if(check(mid)){
            r=mid;
        }
        else{
            l=mid;
            l=mid;
        }
    }
    printf("%.4f",l*acos(-1.0));
    return 0;
}
}
```

---

# 高精度乘法

## 题目描述

【问题描述】

高精度乘法，相当于
𝑎
∗
𝑏
 
𝑝
𝑟
𝑜
𝑏
𝑙
𝑒
𝑚
a∗b problem，不用考虑负数.

【输入】

分两行输入。
𝑎
,
𝑏
≤
1
0
500
a,b≤10
500

【输出】

输出只有一行，代表
𝑎
∗
𝑏
a∗b的值

【样例输入1】
1
1

【样例输出1】
1

【样例输入2】
1000
9099

【样例输出2】
9099000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[10100],b[10100],c[10100];
int main(){
    cin>>st1>>st2;
    int len1=st1.size();
    int len2=st2.size();
    for(int i=0;i<len1;i++){
        a[len1-i]=st1[i]-'0';
    }
    for(int i=0;i<len2;i++){
        b[len2-i]=st2[i]-'0';
    }
    }
    for(int i=1;i<=len1;i++){
        for(int j=1;j<=len2;j++){
            c[i+j-1]+=a[i]*b[j];
        }
    }
    int lenc=len1+len2;
    for(int i=1;i<=lenc;i++){
        c[i+1]+=c[i]/10;
        c[i]%=10;
    }
    while(c[lenc]==0){
        lenc-=1;
    }
    }
    for(int i=max(1,lenc);i>=1;i--){
        cout<<c[i];
    }
    return 0;
} 
}
```

---

# 高精度减法

## 题目描述

高精度减法
【问题描述】

高精度减法，相当于a-b problem，不用考虑负数.

【输 入】

分两行输入。
𝑏
<
𝑎
≤
1
0
1000
b<a≤10
1000

【输 出】

输出只有一行，代表
𝑎
−
𝑏
a−b的值

【样例输入1】
1
1

【样例输出1】
0

【样例输入2】
1000
999

【样例输出2】
1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[1005],b[1005],c[1005];
bool flag=0;
int main(){
    cin>>st1>>st2;
    int len1=st1.size();
    int len2=st2.size();
    if(len1==len2){
        cout<<0;
        return 0;
    } 
    for(int i=0;i<len1;i++){
    for(int i=0;i<len1;i++){
        a[len1-i]=st1[i]-'0';
    }
    for(int i=0;i<len2;i++){
        b[len2-i]=st2[i]-'0';
    }
    int lenc=max(len1,len2);
    for(int i=1;i<=lenc;i++){
        c[i]=a[i]-b[i];
    }
    for(int i=1;i<=lenc;i++){
        if(c[i]<0){
            c[i+1]-=1;
            c[i]+=10;
            c[i]+=10;
        }
    }
    for(int i=lenc;i>=1;i--){
        if(flag==0&&c[i]==0){
            continue;
        }
        if(c[i]!=0){
            flag=1;
        }
        cout<<c[i];
    }
    return 0;
} 
}
```

---

# 高精度减法

## 题目描述

高精度减法
【问题描述】

高精度减法，相当于a-b problem，不用考虑负数.

【输 入】

分两行输入。
𝑏
<
𝑎
≤
1
0
1000
b<a≤10
1000

【输 出】

输出只有一行，代表
𝑎
−
𝑏
a−b的值

【样例输入1】
1
1

【样例输出1】
0

【样例输入2】
1000
999

【样例输出2】
1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[1005],b[1005],c[1005];
bool flag=0;
int main(){
    cin>>st1>>st2;
    int len1=st1.size();
    int len2=st2.size();
    for(int i=0;i<len1;i++){
        a[len1-i]=st1[i]-'0';
    }
    for(int i=0;i<len2;i++){
        b[len2-i]=st2[i]-'0';
        b[len2-i]=st2[i]-'0';
    }
    int lenc=max(len1,len2);
    for(int i=1;i<=lenc;i++){
        c[i]=a[i]-b[i];
    }
    for(int i=1;i<=lenc;i++){
        if(c[i]<0){
            c[i+1]-=1;
            c[i]+=10;
        }
    }
    for(int i=lenc;i>=1;i--){
        if(flag==0&&c[i]==0){
        if(flag==0&&c[i]==0){
            continue;
        }
        if(c[i]!=0){
            flag=1;
        }
        cout<<c[i];
    }
    return 0;
} 
}
```

---

# 高精度减法

## 题目描述

高精度减法
【问题描述】

高精度减法，相当于a-b problem，不用考虑负数.

【输 入】

分两行输入。
𝑏
<
𝑎
≤
1
0
1000
b<a≤10
1000

【输 出】

输出只有一行，代表
𝑎
−
𝑏
a−b的值

【样例输入1】
1
1

【样例输出1】
0

【样例输入2】
1000
999

【样例输出2】
1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[1005],b[1005],c[1005];
int main(){
    cin>>st1>>st2;
    int len1=st1.size();
    int len2=st2.size();
    for(int i=0;i<len1;i++){
        a[len1-i]=st1[i]-'0';
    }
    for(int i=0;i<len2;i++){
        b[len2-i]=st2[i]-'0';
    }
    }
    int lenc=max(len1,len2);
    for(int i=1;i<=lenc;i++){
        c[i]=a[i]-b[i];
    }
    for(int i=1;i<=lenc;i++){
        if(c[i]<0){
            c[i+1]-=1;
            c[i]+=10;
        }
    }
    if(c[lenc+1]){
        lenc+=1;
    }
    }
    for(int i=lenc;i>=1;i--){
        cout<<c[i];
    }
    return 0;
} 
}
```

---

# 高精度加法

## 题目描述

高精度加法
【问题描述】

高精度加法，相当于a+b problem，不用考虑负数.

【输 入】

分两行输入。
𝑎
,
𝑏
≤
1
0
500
a,b≤10
500

【输 出】

输出只有一行，代表
𝑎
+
𝑏
a+b的值

【样例输入1】
1
1

【样例输出1】
2

【样例输入2】
1001
9099

【样例输出2】
10100

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[505],b[505],c[505];
int main(){
    cin>>st1>>st2;
    int len1=st1.size();
    int len2=st2.size();
    for(int i=0;i<len1;i++){
        a[len1-i]=st1[i]-'0';
    }
    for(int i=0;i<len2;i++){
        b[len2-i]=st2[i]-'0';
    }
    }
    int lenc=max(len1,len2);
    for(int i=1;i<=lenc;i++){
        c[i]=a[i]+b[i];
    }
    for(int i=1;i<=lenc;i++){
        if(c[i]>=10){
            c[i+1]+=1;
            c[i]-=10;
        }
    }
    if(c[lenc+1]){
        lenc+=1;
    }
    }
    for(int i=lenc;i>=1;i--){
        cout<<c[i];
    }
    return 0;
} 
}
```

---

# 贝壳游戏

## 题目描述

【题目描述】

Alice和Bob在玩一个贝壳游戏，游戏是这样的：有3个贝壳和1个鹅卵石，现在Alice可以把鹅卵石放到贝壳的下面。一开始3个贝壳在桌面上依次放着，接着Alice对两个不同的贝壳进行位置的调换，每进行依次调换，Bob就猜一次鹅卵石的位置。现在已知他们一共进行了
𝑛
n次调换，每次Bob都会猜。当Bob猜对的时候，Alice就给她一颗糖。请问Bob最多可能拿到多少颗糖？

【输入格式】

第一行输入一个数
𝑛
n，表示一共进行了
𝑛
n次调换；
(
1
≤
𝑛
≤
100
)
(1≤n≤100)

接下来输入
𝑛
n行，每行输入三个数
𝑎
,
𝑏
,
𝑔
a,b,g分别表示调换了位置
𝑎
a和
𝑏
b上的贝壳，然后Bob猜了位置
𝑔
g。（
1
≤
𝑎
,
𝑏
,
𝑔
≤
3
1≤a,b,g≤3,并且
𝑎
!
=
𝑏
a!=b）

【输出格式】

输出一个数，表示Bob最多可能得到的糖果。

【输入样例】
3
1 2 1
3 2 1
1 3 1

【输出样例】
2

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],b[105],g[105],cnt[5],sum,maxn=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i]>>b[i]>>g[i];
    }
    for(int i=1;i<=3;i++){
        cnt[i]=1;
        sum=0;
        for(int j=1;j<=n;j++){
            swap(cnt[a[j]],cnt[b[j]]);  
            if(cnt[g[j]]==1){
            if(cnt[g[j]]==1){
                sum+=1;
            }
        }
        for(int j=1;j<=3;j++){
            cnt[j]=0;
        }
        maxn=max(maxn,sum);
    }
    cout<<maxn;
    return 0;
}
}
```

---

# 乒乓球

## 题目描述

【题目背景】

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

每行至多 20 个字母，最多有 2500 行

【题目描述】

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

获胜的条件是：1.得分大于等于分制，2.得分至少领先对手2分。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

【输入格式】

每个输入文件包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

【输出格式】

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

【输入样例】
WWWWWWWWWWWWWWWWWWWW
WWLWE

【输出样例】
11:0
11:0
1:1

21:0
2:1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5105][3],b[2605][3],x=0,y=0;
char n;
int main(){
    while(cin>>n){
        if(n=='E'){
            break;
        }
        if(n=='W'){
            w11+=1;
            w21+=1;
        }
        else{
        else{
            l11+=1;
            l21+=1;
        }
        if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
            x+=1;
            a[x][1]=w11;
            a[x][2]=l11;
            w11=0;
            l11=0;
        }
        if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
            y+=1;
            b[y][1]=w21;
            b[y][1]=w21;
            b[y][2]=l21;
            w21=0;
            l21=0;
        }
    }
    if(w11!=0||l11!=0){
        x+=1;
        a[x][1]=w11;
        a[x][2]=l11;
    }
    else{
        x+=1;
        a[x][1]=0;
        a[x][2]=0;
        a[x][2]=0;
    }
    if(w21!=0||l21!=0){
        y+=1;
        b[y][1]=w21;
        b[y][2]=l21;
    }
    else{
        y+=1;
        b[y][1]=0;
        b[y][2]=0;
    }
    if(x==0&&y==0){
        cout<<"0:0"<<endl;
        cout<<"0:0"<<endl;
        cout<<endl;
        cout<<"0:0";
    }
    for(int i=1;i<=x;i++){
        cout<<a[i][1]<<":"<<a[i][2]<<endl;
    }
    cout<<endl;
    for(int i=1;i<=y;i++){
        cout<<b[i][1]<<":"<<b[i][2]<<endl;
    }
    return 0;
}
}
```

---

# 统计单词数

## 题目描述

【题目描述】

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1）， 如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2）。

【输入格式】

输入文件共 2 行。

第 1 行为一个字符串 
𝑠
1
s1，其中只含字母，表示给定单词；

第 2 行为一个字符串 
𝑠
2
s2，其中只可能包含字母和空格，表示给定的文章。

【输出格式】

只有一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从0 开始）；如果单词在文章中没有出现，则直接输出一个整数-1。

【样例输入1】
To
to be or not to be is a question

【样例输出1】
2 0

【样例输入1】
to
Did the Ottoman Empire lose its power at that time

【样例输出2】
-1

【数据范围】

1 ≤ 
∣
𝑠
2
∣
∣s2∣ ≤ 10。

1 ≤ 
∣
𝑠
1
∣
∣s1∣ ≤ 1,000,000 。

【说明】

样例1：输出结果表示给定的单词To在文章中出现两次，第一次出现的位置为0。

样例2：表示给定的单词to 在文章中没有出现，输出整数-1。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int start,sum,ans=-1;
int main()
{
    getline(cin,s1);
    getline(cin,s2);
    for(int i=0;s1[i];i++){
        if(s1[i]>='A' && s1[i]<='Z'){
            s1[i]=s1[i]-'A'+'a';
        }
    }       
    for(int i=0;s2[i];i++){
    for(int i=0;s2[i];i++){
        if(s2[i]>='A' && s2[i]<='Z'){
            s2[i]=s2[i]-'A'+'a';
        }
    }   
    s2=s2+' ';
    for(int i=0;s2[i];i++){
        if(s2[i]==' '){
              string k=s2.substr(start,i-start);
              if(k==s1){
                if(sum==0){
                    ans=start;
                }
                sum++;  
                sum++;  
              }
              start=i+1;
        }
    }
    if(sum==0){
        cout<<-1<<endl;
    }   
    else{
        cout<<sum<<" "<<ans<<endl;
    }   
}
}
```

---

# 裂变

## 题目描述

1S/256M

问题背景

在一个魔法世界中，有一种神奇的宝石，一对宝石可以用两种方法裂变成一对略有差异的宝石，初始时，你有两块大小相同的宝石，每块的大小都是1单位。现在，你希望通过一系列的列表操作，使得一对大小都是1单位的宝石，至少有一块宝石的大小等于目标大小n单位。

操作规则如下:

裂变操作一：你可以将一对大小为x,y的宝石裂变成一对大小为x+y,y的宝石。

裂变操作二：你可以将一对大小为x,y的宝石裂变成一对大小为x,x+y的宝石。

输入：

第一行输入一个正整数n，表示目标宝石的大小。

输出：

输出一个整数，表示达到目标所需的最少操作次数。

样例输入：

2


样例输出：

1


数据范围

对于40%的数据，1 ≤ n ≤ 1000
对于100%的数据，1 ≤ n ≤ 10^5

样例解释

1,1通过裂变一就达到1,2

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct gemstone{
    int gem1=1,gem2=1,step=0;
};
queue<gemstone>q;
int main(){
    cin>>n;
    q.push({1,1,0});
    while(!q.empty()){
        gemstone x=q.front();
        q.pop();
        int g1=x.gem1;
        int g1=x.gem1;
        int g2=x.gem2;
        int s=x.step;
        if(g1+g2==n){
            cout<<s+1;
            break;
        }
        q.push({g1,g1+g2,s+1});
        q.push({g1+g2,g2,s+1});
    }
    return 0;
}
}
```

---

# 乒乓球

## 题目描述

【题目背景】

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

每行至多 20 个字母，最多有 2500 行

【题目描述】

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

获胜的条件是：1.得分大于等于分制，2.得分至少领先对手2分。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

【输入格式】

每个输入文件包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

【输出格式】

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

【输入样例】
WWWWWWWWWWWWWWWWWWWW
WWLWE

【输出样例】
11:0
11:0
1:1

21:0
2:1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5105][3],b[2605][3],x=0,y=0;
char n;
int main(){
    while(cin>>n){
        if(n=='E'){
            break;
        }
        if(n=='W'){
            w11+=1;
            w21+=1;
        }
        else{
        else{
            l11+=1;
            l21+=1;
        }
        if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
            x+=1;
            a[x][1]=w11;
            a[x][2]=l11;
            w11=0;
            l11=0;
        }
        if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
            y+=1;
            b[y][1]=w21;
            b[y][1]=w21;
            b[y][2]=l21;
            w21=0;
            l21=0;
        }
    }
    if(w11!=0||l11!=0){
        x+=1;
        a[x][1]=w11;
        a[x][2]=l11;
    }
    else{
        x+=1;
        a[x][1]=0;
        a[x][2]=0;
        a[x][2]=0;
    }
    if(w21!=0||l21!=0){
        y+=1;
        b[y][1]=w21;
        b[y][2]=l21;
    }
    else{
        y+=1;
        b[y][1]=0;
        b[y][2]=0;
    }
    if(x==0&&y==0){
        cout<<"0:0"<<endl;
        cout<<"0:0"<<endl;
        cout<<endl;
        cout<<"0:0";
    }
    for(int i=1;i<=x;i++){
        cout<<a[i][1]<<":"<<a[i][2]<<endl;
    }
    cout<<endl;
    for(int i=1;i<=y;i++){
        cout<<b[i][1]<<":"<<b[i][2]<<endl;
    }
    return 0;
}
}
```

---

# 乒乓球

## 题目描述

【题目背景】

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

每行至多 20 个字母，最多有 2500 行

【题目描述】

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

获胜的条件是：1.得分大于等于分制，2.得分至少领先对手2分。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

【输入格式】

每个输入文件包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

【输出格式】

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

【输入样例】
WWWWWWWWWWWWWWWWWWWW
WWLWE

【输出样例】
11:0
11:0
1:1

21:0
2:1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5005][3],b[2505][3],x=0,y=0;
char n;
int main(){
    while(cin>>n){
        if(n=='E'){
            break;
        }
        if(n=='W'){
            w11+=1;
            w21+=1;
        }
        else{
        else{
            l11+=1;
            l21+=1;
        }
        if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
            x+=1;
            a[x][1]=w11;
            a[x][2]=l11;
            w11=0;
            l11=0;
        }
        if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
            y+=1;
            b[y][1]=w21;
            b[y][1]=w21;
            b[y][2]=l21;
            w21=0;
            l21=0;
        }
    }
    if(w11!=0||l11!=0){
        x+=1;
        a[x][1]=w11;
        a[x][2]=l11;
    }
    if(w21!=0||l21!=0){
        y+=1;
        b[y][1]=w21;
        b[y][2]=l21;
        b[y][2]=l21;
    }
    if(x==0&&y==0){
        cout<<"0:0"<<endl;
        cout<<endl;
        cout<<"0:0";
    }
    for(int i=1;i<=x;i++){
        cout<<a[i][1]<<":"<<a[i][2]<<endl;
    }
    cout<<endl;
    for(int i=1;i<=y;i++){
        cout<<b[i][1]<<":"<<b[i][2]<<endl;
    }
    }
    return 0;
}
}
```

---

# 乒乓球

## 题目描述

【题目背景】

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

每行至多 20 个字母，最多有 2500 行

【题目描述】

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

获胜的条件是：1.得分大于等于分制，2.得分至少领先对手2分。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

【输入格式】

每个输入文件包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

【输出格式】

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

【输入样例】
WWWWWWWWWWWWWWWWWWWW
WWLWE

【输出样例】
11:0
11:0
1:1

21:0
2:1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5005][3],b[2505][3],x=0,y=0;
char n;
int main(){
    while(cin>>n){
        if(n=='E'){
            break;
        }
        if(n=='W'){
            w11+=1;
            w21+=1;
        }
        else{
        else{
            l11+=1;
            l21+=1;
        }
        if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
            x+=1;
            a[x][1]=w11;
            a[x][2]=l11;
            w11=0;
            l11=0;
        }
        if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
            y+=1;
            b[y][1]=w21;
            b[y][1]=w21;
            b[y][2]=l21;
            w21=0;
            l21=0;
        }
    }
    if(w11!=0||l11!=0){
        x+=1;
        a[x][1]=w11;
        a[x][2]=l11;
    }
    if(w21!=0||l21!=0){
        y+=1;
        b[y][1]=w21;
        b[y][2]=l21;
        b[y][2]=l21;
    }
    if(x==0&&y==0){
        cout<<"0:0";
    }
    for(int i=1;i<=x;i++){
        cout<<a[i][1]<<":"<<a[i][2]<<endl;
    }
    cout<<endl;
    for(int i=1;i<=y;i++){
        cout<<b[i][1]<<":"<<b[i][2]<<endl;
    }
    return 0;
}
}
```

---

# 乒乓球

## 题目描述

【题目背景】

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

每行至多 20 个字母，最多有 2500 行

【题目描述】

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

获胜的条件是：1.得分大于等于分制，2.得分至少领先对手2分。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

【输入格式】

每个输入文件包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

【输出格式】

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

【输入样例】
WWWWWWWWWWWWWWWWWWWW
WWLWE

【输出样例】
11:0
11:0
1:1

21:0
2:1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5005][3],b[2505][3],x=0,y=0;
char n;
int main(){
    while(cin>>n){
        if(n=='E'){
            break;
        }
        if(n=='W'){
            w11+=1;
            w21+=1;
        }
        else{
        else{
            l11+=1;
            l21+=1;
        }
        if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
            x+=1;
            a[x][1]=w11;
            a[x][2]=l11;
            w11=0;
            l11=0;
        }
        if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
            y+=1;
            b[y][1]=w21;
            b[y][1]=w21;
            b[y][2]=l21;
            w21=0;
            l21=0;
        }
    }
    if(w11!=0||l11!=0){
        x+=1;
        a[x][1]=w11;
        a[x][2]=l11;
    }
    if(w21!=0||l21!=0){
        y+=1;
        b[y][1]=w21;
        b[y][2]=l21;
        b[y][2]=l21;
    }
    if(x==0&&y==0){
        cout<<"0:0";
    }
    for(int i=1;i<=x;i++){
        cout<<a[i][1]<<":"<<a[i][2]<<endl;
    }
    cout<<endl;
    for(int i=1;i<=y;i++){
        cout<<b[i][1]<<":"<<b[i][2]<<endl;
    }
    return 0;
}
}
```

---

# 藏宝图

## 题目描述

1S/256M

题目描述

小智得到了一张藏宝图，藏宝图由一串二维字符串组成，藏宝图中间有一个矩形是用x字符表示，其余用 '.' 表示。现在需要你把中间部分（即x的部分）提取出来并且缩小打印。现在需要你输出等比例缩到最小后的图像。

输入

第一行两个整数n 和 m。

接下来 n 行，每行 m 个字符（字符由 
.
. 和 x 组成）

输出

输出由x组成的矩形，等比例缩小后的结果。

样例输入
8 7
.......
..xxxx.
..xxxx.
..xxxx.
..xxxx.
..xxxx.
..xxxx.
.......

样例输出
xx
xx
xx

提示

100%的数据，1≤ n,m≤ 100。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,x,y,ex,ey,lx,ly,lenx,leny;
char a[105][105];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(x==0&&y==0&&a[i][j]=='x'){
                sx=i;
                sy=j;
            }
            if(a[i][j]=='x'){
            if(a[i][j]=='x'){
                x=i;
                y=j;
            }
        }
    }
    ex=x;
    ey=y;
    lx=ex-sx+1;
    ly=ey-sy+1;
    lenx=lx;
    leny=ly;
    while(lenx%leny!=0){
        if(lenx<leny){
        if(lenx<leny){
            swap(lenx,leny);
        }
        lenx-=leny;
    }
    for(int i=1;i<=lx/leny;i++){
        for(int j=1;j<=ly/leny;j++){
            cout<<"x";
        }
        cout<<endl;
    }
    return 0;
}
```

---

# 藏宝图

## 题目描述

1S/256M

题目描述

小智得到了一张藏宝图，藏宝图由一串二维字符串组成，藏宝图中间有一个矩形是用x字符表示，其余用 '.' 表示。现在需要你把中间部分（即x的部分）提取出来并且缩小打印。现在需要你输出等比例缩到最小后的图像。

输入

第一行两个整数n 和 m。

接下来 n 行，每行 m 个字符（字符由 
.
. 和 x 组成）

输出

输出由x组成的矩形，等比例缩小后的结果。

样例输入
8 7
.......
..xxxx.
..xxxx.
..xxxx.
..xxxx.
..xxxx.
..xxxx.
.......

样例输出
xx
xx
xx

提示

100%的数据，1≤ n,m≤ 100。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,x,y,ex,ey,lx,ly,lenx,leny;
char a[100][100];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(x==0&&y==0&&a[i][j]=='x'){
                sx=i;
                sy=j;
            }
            if(a[i][j]=='x'){
            if(a[i][j]=='x'){
                x=i;
                y=j;
            }
        }
    }
    ex=x;
    ey=y;
    lx=ex-sx+1;
    ly=ey-sy+1;
    lenx=lx;
    leny=ly;
    while(lenx%leny!=0){
        if(lenx<leny){
        if(lenx<leny){
            swap(lenx,leny);
        }
        lenx-=leny;
    }
    for(int i=1;i<=lx/leny;i++){
        for(int j=1;j<=ly/leny;j++){
            cout<<"x";
        }
        cout<<endl;
    }
    return 0;
}
```

---

# 糖果

## 题目描述

1
𝑆
/
256
𝑀
1S/256M

题目描述

老师给小明
𝑛
n堆糖果，每堆糖果有
𝑘
k个糖果，现在老师要求小明判断其中糖果数量为偶数的堆数。

输入格式

输入的第一行包含一个整数 
𝑛
n ，表示糖果堆数。

第二行
𝑛
n个整数，表示每堆糖果的数量

输出格式

输出一个整数代表答案

样例 #1
样例输入 #1
3
1 2 3

样例输出 #1
1

样例 #2
样例输入 #2
5
2 2 2 2 2

样例输出 #2
5

数据范围

对于 
100
%
100% 的数据，
1
⩽
𝑛
⩽
100
,
1
⩽
𝑘
⩽
600.
1⩽n⩽100,1⩽k⩽600.

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]%2==0){
            sum+=1;
        }
    }
    cout<<sum;
    return 0;
}
}
```

---

# 分小组（team）

## 题目描述

分小组（team）

1S/256M

【题目描述】

小方终于等到了春游！这一天，他和班里同学一起出发了。

他们班一共有 
𝑛
n 个学生，学生编号从 1 到 
𝑛
n 。由于学生太多了，因此老师想把学生进行分组。已知每个学生都带了零食，第 
𝑖
i 个学生带的零食数是 
𝑎
𝑖
a
i
	​

。由于不同的人带的零食数可能不一样，但是在吃的时候是放在一起的，因此一些多带零食的人可能会产生不满情绪。但是由于老师在场，因此学生们都有一个忍耐度 
𝑥
x，如果超过了这个忍耐度就会有冲突爆发。已知分到两个不同小组的人之间是不会出现不满情绪的，换句话说每个人只会在与自己同一小组中的人产生不满情绪。老师现在希望能够合理分组，令小组里任意一个人产生的不满情绪不超过 
𝑥
x。已知每个人只会与他相邻的人进行比较产生不满情绪，产生的不满情绪为两人零食数量的差值，因此在分组的时候，可以尽量地把零食数相近的人排在相邻位置。

例如，有一个分组 
[
1
,
10
,
8
,
4
,
4
]
[1,10,8,4,4] ，忍耐度 
𝑥
=
4
x=4，在这个组里可以重新对学生进行排队，变成
[
1
,
4
,
4
,
8
,
10
]
[1,4,4,8,10]，这样每个人能够产生的不满情绪都不会超过 4 。

小方作为班长，请来了 
𝑘
k 个其他班学生当救兵。这 
𝑘
k 个救兵可以选择带任意数量的零食过来。请你帮助老师和小方，避免引出冲突，加入救兵以后尽量使分组的数量少。

【输入格式】

第一行输入三个整数 
𝑛
,
𝑘
,
𝑥
n,k,x 分别表示一开始的学生数量，你可以请来的救兵和学生的最大忍耐度。

第二行输入 
𝑛
n 个整数，
𝑎
𝑖
a
i
	​

 表示第 
𝑖
i 个学生带来的零食数。

【输出格式】

输出一个数表示在避免引起学生冲突的情况下，最少的分组数量。

【输入样例】
8 2 3
1 1 5 8 12 13 20 22

【输出样例】
2

【数据范围】

对于 
30
%
30% 的数据，
1
≤
𝑛
≤
1
0
3
1≤n≤10
3

对于 
100
%
100% 的数据，
1
≤
𝑛
≤
1
0
5
,
0
<
𝑘
<
1
0
9
,
0
<
𝑥
<
1
0
9
,
1
≤
𝑎
𝑖
≤
1
0
9
1≤n≤10
5
,0<k<10
9
,0<x<10
9
,1≤a
i
	​

≤10
9

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x,a[100005],b[100005],c[100005],sum=0,cnt=0,ans;
int main(){
    cin>>n>>k>>x;
    if(n==1){
        cout<<1;
        return 0;
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=2;i<=n;i++){
    for(int i=2;i<=n;i++){
        b[i]=a[i]-a[i-1];
        if(b[i]>x){
            cnt+=1;
            c[cnt]=(b[i]-1)/x;
        }
    }
    sort(c+1,c+cnt+1);
    ans=cnt+1;
    for(int i=1;i<=cnt;i++){
        if(sum+c[i]>k||ans==0){
            break;
        }
        else{
        else{
            sum+=c[i];
            ans-=1;
        }
    }
    cout<<ans;
    return 0;
}
}
```

---

# 爱之曲（love）

## 题目描述

爱之曲（love）

1S/256M

【题目描述】

作为一个业余歌唱爱好者，小方鼓起了勇气参加了歌手大赛，并且凭借着一曲《爱之曲》崭露头角。不出一周，小方的《爱之曲》登上了热歌榜，粉丝为之狂热。小方虽然很得意，但是他觉得有必要再对自己的作品做一些修改。

《爱之曲》是一首英文歌曲，里面的歌词全部都是由小写字母组成。小方想要对其中的部分内容进行修改。于是他决定进行 
𝑞
q 次改编测试。每次测试他都会挑选一个区间 
[
𝑙
,
𝑟
]
[l,r]，从第 
𝑙
l 个字母到第 
𝑟
r 个字母，他会对里面的内容进行修改。

修改方式是这样的，对里面的每个字母他会增加 
𝑘
−
1
k−1 个相同字母在当前字母后面，
𝑘
k 取决于字母在字母表中的位置，即字母 
𝑎
a 时 
𝑘
=
1
k=1，字母 
𝑏
b 时 
𝑘
=
2
k=2，字母 
𝑐
c 时 
𝑘
=
3
k=3，依次类推。

例如：选择的区间歌词为 abcbbaa，那么改编以后会变成 abbcccbbbbaa。

给出 
𝑞
q 次测试，请你帮助小方计算每次改编测试以后区间上的歌词长度会变成多少。

【输入格式】

第一行输入两个数 
𝑛
n 和 
𝑞
q，
𝑛
n 表示歌曲原本的歌词长度，
𝑞
q 表示测试次数。

第二行输入一个字符串 
𝑠
s 表示歌词。

接下来输入 
𝑞
q 行，每行输入两个数 
𝑙
l 和 
𝑟
r ，表示测试的区间。

【输出格式】

每次测试输出一个数，表示改编后的区间上的歌词长度。

【样例输入】
7 3
abacaba
1 3
2 5
1 7

【样例输出】
4
7
11

【数据范围】

对于 
30
%
30% 的数据，
1
≤
𝑛
≤
100
,
1
≤
𝑞
≤
100
1≤n≤100,1≤q≤100

对于 
100
%
100% 的数据，
1
≤
𝑛
≤
1000
,
1
≤
𝑞
≤
1000
1≤n≤1000,1≤q≤1000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,l,r,sum;
string s;
int main(){
    cin>>n>>q;
    cin>>s;
    for(int i=1;i<=q;i++){
        cin>>l>>r;
        sum=r-l+1;
        for(int j=l-1;j<r;j++){
            sum+=(s[j]-'a');
        }
        cout<<sum<<endl;
        cout<<sum<<endl;
    }
    return 0;
}
}
```

---

# 奶牛量身高(cow)

## 题目描述

奶牛量身高(cow)

1S/256M

【故事背景】

农夫FJ养了 
𝑁
N 只奶牛，这些奶牛排成一排编号从 1 到 
𝑁
N 。每头奶牛都有自己的身高，而农夫FJ只知道他的奶牛中最高的那头的身高是 
𝐻
H，并且他也知道最高的这头奶牛的编号是 
𝐼
I 。农夫FJ想要带着他的这群奶牛出去参加选美，那么如果选美的奶牛身高高一点的话，优势就会大一点。

现在农夫FJ从奶牛中获得了 
𝑅
R 张纸条，每张纸条上写着两个数字 
𝐴
A 和 
𝐵
B ，表示 
𝐴
A 编号的奶牛可以看到 
𝐵
B 编号的奶牛。要知道，奶牛们是按照顺序排成一排的。如果 
𝐴
A 号可以看到 
𝐵
B 号，那就意味着
𝐴
A ~ 
𝐵
B 中间的奶牛都要比 
𝐴
A 和 
𝐵
B 矮。并且如果 
𝐴
A 可以看到 
𝐵
B，那么农夫FJ会认为 
𝐵
B 至少和 
𝐴
A 一样高（甚至 
𝐵
B 会比 
𝐴
A 高）。

现在你要帮助农夫FJ，根据得到的 
𝑅
R 张纸条，给出农夫FJ所有奶牛的最高的可能身高。

【输入格式】

第一行输入 4 个数 
𝑁
,
𝐼
,
𝐻
,
𝑅
N,I,H,R 分别表示奶牛的数量，最高奶牛编号 
𝐼
I 的身高为 
𝐻
H ，共有 
𝑅
R 张纸条。

接下来输入 
𝑅
R 行，每行输入两个数 
𝐴
A 和 
𝐵
B，表示 
𝐴
A 能看到 
𝐵
B 。注意纸条中给出的内容可能出现重复。

【输出格式】

输出 
𝑁
N 行，每行一个数表示编号为 
𝑖
i 的奶牛的最高的可能身高。

【样例输入】
9 3 5 5
1 3
5 3
4 3
3 7
9 8

【样例输出】
5
4
5
3
4
4
5
5
5

【数据范围】

对于 
80
%
80% 的数据，
1
≤
𝑁
≤
1000
1≤N≤1000

对于 
100
%
100% 的数据，
1
≤
𝑁
≤
10000
,
1
≤
𝐴
,
𝐵
≤
𝑁
,
1
≤
𝑅
≤
1000
1≤N≤10000,1≤A,B≤N,1≤R≤1000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,h,r,a[10005],b[100000000];
int main(){
    cin>>n>>x>>h>>r;
    for(int i=1;i<=r;i++){
        int c,d;
        cin>>c>>d;
        if(c>d){
            swap(c,d);
        }
        if(b[c*10000+d]==1){
            continue;
        }
        }
        b[c*10000+d]=1;
        a[c+1]-=1;
        a[d]+=1;
    }
    for(int i=1;i<=n;i++){
        a[i]+=a[i-1];
    }
    for(int i=1;i<=n;i++){
        a[i]+=h;
        cout<<a[i]<<endl;
    }
    return 0;
}
}
```

---

# 谁是冠军（win）

## 题目描述

谁是冠军（win）

1S/256M

【题目描述】

小方参加了小区里的乒乓球排位赛。已知一共有 
𝑛
n 位选手报名，举办方为了看看有没有节目效果，决定先进行 
𝑚
m 场比赛。每场比赛都是挑选 2 位选手进行，并且不会出现平局的情况。在每场比赛完以后，我们视胜者选手的实力比败者选手的实力强。如果出现 A 打败 B ，B 打败 C ，C 打败 A 的情况，我们认为他们的实力是相同的。

现在给出了 
𝑚
m 场比赛的情况，最终冠军是属于实力最强者。根据当前已有的 
𝑚
m 场比赛情况，请你帮助小方判断目前为止最多有多少个选手可能获得冠军（如果已知两人实力一样强，则这两人都不能成为冠军）

【输入格式】

第一行输入两个数 
𝑛
,
𝑚
n,m 表示参赛人数和比赛场数。

接下来 
𝑚
m 行，每行输入两个数 
𝑎
a 和 
𝑏
b ，表示 
𝑎
a 战胜了 
𝑏
b。

【输出格式】

输出一个数，表示最多可能有多少名选手获得冠军。

【输入样例】
3 2
1 2
1 3

【输出样例】
1

【数据范围】

对于 
30
%
30% 的数据保证，
1
≤
𝑛
,
𝑚
≤
1
0
3
,
0
<
𝑎
,
𝑏
≤
𝑛
1≤n,m≤10
3
,0<a,b≤n

对于 
100
%
100% 的数据保证，
1
≤
𝑛
,
𝑚
≤
1
0
5
,
0
<
𝑎
,
𝑏
≤
𝑛
1≤n,m≤10
5
,0<a,b≤n

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],c[100005],sum=0;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a[i]>>b[i];
    }
    for(int i=1;i<=m;i++){
        c[b[i]]=1;
    }
    for(int i=1;i<=n;i++){
        if(c[i]==0){
            sum+=1;
            sum+=1;
        }
    }
    cout<<sum;
    return 0;
}
}
```

---

# 乒乓球

## 题目描述

【题目背景】

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

每行至多 20 个字母，最多有 2500 行

【题目描述】

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

获胜的条件是：1.得分大于等于分制，2.得分至少领先对手2分。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

【输入格式】

每个输入文件包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

【输出格式】

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

【输入样例】
WWWWWWWWWWWWWWWWWWWW
WWLWE

【输出样例】
11:0
11:0
1:1

21:0
2:1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5005][3],b[2505][3],x=0,y=0;
char n;
int main(){
    while(cin>>n){
        if(n=='E'){
            break;
        }
        if(n=='W'){
            w11+=1;
            w21+=1;
        }
        else{
        else{
            l11+=1;
            l21+=1;
        }
        if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
            x+=1;
            a[x][1]=w11;
            a[x][2]=l11;
            w11=0;
            l11=0;
        }
        if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
            y+=1;
            b[y][1]=w21;
            b[y][1]=w21;
            b[y][2]=l21;
            w21=0;
            l21=0;
        }
    }
    if(w11!=0||l11!=0){
        x+=1;
        a[x][1]=w11;
        a[x][2]=l11;
    }
    if(w21!=0||l21!=0){
        y+=1;
        b[y][1]=w21;
        b[y][2]=l21;
        b[y][2]=l21;
    }
    for(int i=1;i<=x;i++){
        cout<<a[i][1]<<":"<<a[i][2]<<endl;
    }
    cout<<endl;
    for(int i=1;i<=y;i++){
        cout<<b[i][1]<<":"<<b[i][2]<<endl;
    }
    return 0;
}
}
```

---

# 查找

## 题目描述

查找
1000ms/128mb

【问题描述】

输入 
𝑛
(
𝑛
≤
1
0
6
)
n(n≤10
6
) 个不超过 
1
0
9
10
9
 的单调不减的（就是后面的数字不小于前面的数字）非负整数 
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
a
1
	​

,a
2
	​

,…,a
n
	​

，然后进行 
𝑚
(
𝑚
≤
1
0
5
)
m(m≤10
5
) 次询问。

对于每次询问，给出一个整数 
𝑞
(
𝑞
≤
1
0
9
)
q(q≤10
9
)，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 -1 。

【输入格式】

第一行 2 个整数 n 和 m，表示数字个数和询问次数。

第二行 n 个整数，表示这些待查询的数字。

第三行 m 个整数，表示询问这些数字的编号，从 1 开始编号。

【输出格式】

m 个整数表示答案。

【输入样例】

11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6


【输出样例】

1 2 -1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[1000005],b[100005];
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=q;i++){
        scanf("%d",&b[i]);
    }
    for(int i=1;i<=q;i++){
        int l=1,r=n+1,mid;
        while(l<r){
            cout<<-1<<" ";
        }
    }
    return 0;
}
}
```

---

# 二分查找简化

## 题目描述

查找
1000ms/256mb

【问题描述】

输入 
𝑛
(
1
≤
𝑛
≤
1
0
6
)
n(1≤n≤10
6
) 个不超过 
1
0
9
10
9
 的单调增的（就是后面的数字大于前面的数字）非负整数 
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
a
1
	​

,a
2
	​

,…,a
n
	​

，给出一个整数 
𝑞
(
0
≤
𝑞
≤
1
0
9
)
q(0≤q≤10
9
)，要求输出这个数字在序列中出现的编号（保证出现）。

【输入格式】

第一行两个整数 
𝑛
n 和 
𝑞
q，表示数字个数和询问的数。

第二行 
𝑛
n 个整数，表示 
𝑎
a。

【输出格式】

𝑞
q 所在位置。

【输入样例】

11 7
1 3 4 5 7 9 11 13 15 20 21



【输出样例】

5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[1000005];
int main(){
    cin>>n>>x;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    int l=1,r=n+1,mid;
    while(l<r){
        mid=(l+r)/2;
        if(a[mid]>=x){
            r=mid;  
        }
}
```

---

# 购物节

## 题目描述

1S/256M

在双十一活动中，不同的消费金额可以享受不同的折扣优惠。具体规则如下：

满300元减30元，最多减30元。
满600元减80元，最多减80元。
满1000元减200元，最多减200元。
满2000元，打七折。
输入格式

输入包含一个整数 ( 
𝑆
S ) ，表示购物总金额。

输出格式

输出实际支付的金额，保留整数部分。

样例
样例输入 #1
450

样例输出 #1
420

样例输入 #2
900

样例输出 #2
820

样例输入 #3
2500

样例输出 #3
1750

数据范围及说明

对于 
100
%
100% 的数据：( 
0
≤
𝑆
≤
10000
0≤S≤10000 )

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    if(n>=2000){
        cout<<n*0.7;
    }
    else if(n>=1000){
        cout<<n-200;
    }
    else if(n>=600){
        cout<<n-80;
    }
}
```

---

# A + B Problem

## 题目描述

1S/16M

给你两个数 
𝑎
a 和 
𝑏
b，请输出他们的和哦。

输入格式

一行，两个用空格隔开的整数 
𝑎
a 和 
𝑏
b。

输出格式

一个整数，表示 
𝑎
+
𝑏
a+b。

样例一
input
2 3

output
5

数据范围

对于
100
%
100%的数据，
−
10000
≤
𝑎
,
𝑏
≤
10000
−10000≤a,b≤10000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
    cin>>a>>b;
    cout<<a+b;
    return 0;
}
}
```

---

# 食堂打菜

## 题目描述

###食堂打菜 
1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

####【题目描述】 小智成为了校志愿者，他的本次志愿工作是替食堂阿姨打菜一天！已知学校食堂每天会提供
𝑛
n道菜品分别放到
𝑛
n个窗口，窗口编号为
1
−
𝑛
1−n。细心的小智发现，学生并不会一个个窗口挑选过去打菜，他们更倾向于选择上一次打菜的窗口进行打菜，即使菜可能并不会符合他们的口味。同时由于食堂人实在太多，打菜的学生都会选择连续的几个窗口进行打菜。

在本次志愿工作中，食堂每售出一道菜品，就会为贫困山区进行一次捐献，不同窗口的菜售出的捐献金额是不一样的。一开始食堂阿姨已经为每个窗口分配了对应的捐献金额，而小智可以自行对不同窗口的捐献金额进行交换调整。为了更好地完成本次志愿工作，小智对全校同学做了问卷调查，获取了全校
𝑚
m个同学的打菜习惯。

请你帮助小智，根据
𝑚
m个同学的打菜习惯，重新对窗口的捐献金额进行合理分配。让分配后的总捐献金额尽量大，并请你计算分配后比分配前最多能增加多少捐献金额。

####【输入格式】 第一行输入一个整数
𝑛
n表示窗口数量

第二行输入
𝑛
n个整数，表示开始时食堂阿姨为每个窗口分配的捐献金额
𝑎
[
𝑖
]
a[i]

第三行输入一个整数
𝑚
m表示学生的数量

接下来输入
𝑚
m行，每行输入2个数
𝐿
,
𝑅
L,R，表示该同学会去连续区间
[
𝐿
,
𝑅
]
[L,R]的窗口打菜

####【输出格式】 输出一行一个数，表示重新分配后比分配前增加的最大总金额

####【输入样例】

4
1 2 3 4
2
1 3
2 4


####【输出样例】

2


####【样例解释】

原来的和为
6
+
9
=
15
6+9=15，重新分配后窗口情况可以为
(
1
,
4
,
3
,
2
)
(1,4,3,2)，和为
8
+
9
=
17
8+9=17，增加了2。

####【数据范围】

30%的数据保证，
𝑛
,
𝑚
≤
50
n,m≤50;

50%的数据保证，
𝑛
,
𝑚
≤
500
n,m≤500

80%的数据保证，
𝑛
,
𝑚
≤
5000
n,m≤5000

100%的数据保证，
1
≤
𝑛
,
𝑚
≤
1
0
5
,
1
≤
𝑎
[
𝑖
]
≤
1
0
6
,
1
≤
𝐿
≤
𝑅
≤
𝑛
1≤n,m≤10
5
,1≤a[i]≤10
6
,1≤L≤R≤n

####【大样例】 大样例

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[100005],b[100005],s,ans,l,r;
bool cmp(int x,int y){
    if(x>=y){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>l>>r;
        b[l]+=1;
        b[r+1]-=1;
    }
    for(int i=1;i<=n;i++){
        b[i]=b[i-1]+b[i];
    }
    for(int i=1;i<=n;i++){
        s+=a[i]*b[i];
    }
    sort(a+1,a+n+1,cmp);
    sort(a+1,a+n+1,cmp);
    sort(b+1,b+n+1,cmp);
    for(int i=1;i<=n;i++){
        ans+=a[i]*b[i];
    }
    cout<<ans-s;
    return 0;
}
}
```

---

# 蛇形填充数组

## 题目描述

描述

用数字 
1
,
2
,
3
,
4
,
.
.
.
,
𝑛
∗
𝑛
1,2,3,4,...,n∗n 这 
𝑛
2
n
2
 个数蛇形填充规模为 
𝑛
∗
𝑛
n∗n 的方阵。

蛇形填充方法为：

对于每一条左下-右上的斜线，从左上到右下依次编号 
1
,
2
,
.
.
.
,
2
∗
𝑛
−
1
1,2,...,2∗n−1；按编号从小到大的顺序，将数字从小到大填入各条斜线，其中编号为奇数的从左下向右上填写，编号为偶数的从右上到左下填写。

比如 
𝑛
=
4
n=4 时，方阵填充为如下形式：

1 2 6 7

3 5 8 13

4 9 12 14

10 11 15 16

输入

输入一个不大于 10 的正整数 
𝑛
n ，表示方阵的行数。

输出

输出该方阵，相邻两个元素之间用单个空格间隔。

样例输入

4


样例输出

1 2 6 7
3 5 8 13
4 9 12 14
10 11 15 16

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15][15];
int main(){
    int n;
    cin>>n;
    int now=0;
    for(int i=0;i<2*n-1;i++){
        int y= min(i,n-1);
        int x= i-y;
        int t=0;
        if(i<n-1){
            t=i;
        }else{
        }else{
            t=2*n-2 -i;
        }
        if(i%2==1)
            for(int j=0;j<=t;j++){
                now++;
                a[x+j][y-j]=now;            
            }
        else
            for(int j=0;j<=t;j++){
                now++; 
                a[y-j][x+j]=now;            
            }
    }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++)
            printf("%d ",a[i][j]);
        printf("\n");
    }
}
}
```

---

# 查找

## 题目描述

查找
1000ms/128mb

【问题描述】

输入 
𝑛
(
𝑛
≤
1
0
6
)
n(n≤10
6
) 个不超过 
1
0
9
10
9
 的单调不减的（就是后面的数字不小于前面的数字）非负整数 
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
a
1
	​

,a
2
	​

,…,a
n
	​

，然后进行 
𝑚
(
𝑚
≤
1
0
5
)
m(m≤10
5
) 次询问。

对于每次询问，给出一个整数 
𝑞
(
𝑞
≤
1
0
9
)
q(q≤10
9
)，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 -1 。

【输入格式】

第一行 2 个整数 n 和 m，表示数字个数和询问次数。

第二行 n 个整数，表示这些待查询的数字。

第三行 m 个整数，表示询问这些数字的编号，从 1 开始编号。

【输出格式】

m 个整数表示答案。

【输入样例】

11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6


【输出样例】

1 2 -1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[1000005],b[100005];
int find(int x){
    int l=1,r=n+1,mid;
    while(l<r){
        mid=(l+r)/2;
        if(a[mid]>=x){
            r=mid;  
        }
        else{
            l=mid+1;
        }
    }
    }
    for(int i=1;i<=q;i++){
        cout<<find(b[i])<<" ";
    }
    return 0;
}
}
```

---

# 蛇形填充数组

## 题目描述

描述

用数字 
1
,
2
,
3
,
4
,
.
.
.
,
𝑛
∗
𝑛
1,2,3,4,...,n∗n 这 
𝑛
2
n
2
 个数蛇形填充规模为 
𝑛
∗
𝑛
n∗n 的方阵。

蛇形填充方法为：

对于每一条左下-右上的斜线，从左上到右下依次编号 
1
,
2
,
.
.
.
,
2
∗
𝑛
−
1
1,2,...,2∗n−1；按编号从小到大的顺序，将数字从小到大填入各条斜线，其中编号为奇数的从左下向右上填写，编号为偶数的从右上到左下填写。

比如 
𝑛
=
4
n=4 时，方阵填充为如下形式：

1 2 6 7

3 5 8 13

4 9 12 14

10 11 15 16

输入

输入一个不大于 10 的正整数 
𝑛
n ，表示方阵的行数。

输出

输出该方阵，相邻两个元素之间用单个空格间隔。

样例输入

4


样例输出

1 2 6 7
3 5 8 13
4 9 12 14
10 11 15 16

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[15][15],x=1,y=1,sum=1,c=1;
int main(){
    cin>>n;
    for(int i=1;i<=n*2-1;i++){
        if(i>n){
            c=n*2-i;
        }
        else{
            c=i;
        }
        if(i==1){
            a[1][1]=1;
                if(j!=c){
                    x-=1;
                    y+=1;
                }
                sum+=1;
            }
        }
        else{
            if(y+1>n){
                x+=1;
            }
            else{
                y+=1;
            }
            for(int j=1;j<=c;j++){
        }
        cout<<endl;
    }
    return 0;
}
}
```

---

# 快乐气球

## 题目描述

时间限制：1000ms 内存限制：256MB

题目描述

现在有
𝑛
n个气球从左到右依次排列，每个气球上都写有一个数字

现在
𝑎
1
,
𝑎
2
,
𝑎
3
.
.
.
𝑎
𝑛
a
1
	​

,a
2
	​

,a
3
	​

...a
n
	​

表示从左到右每个气球上的数字。

小明掌握一定速算能力，可以快速求出任意两个气球之间所有气球上的数字之和(包括两段的两个气球)

现在有
𝑄
Q次询问，每次询问请你给出答案

输入格式中

第一行一个整数
𝑛
n

第二行包含
𝑛
n个整数
𝑎
1
,
𝑎
2
,
𝑎
3
.
.
.
𝑎
𝑛
a
1
	​

,a
2
	​

,a
3
	​

...a
n
	​


第三行一个整数
𝑄
Q,代表询问个数

接下来
𝑄
Q行，每行两个整数
𝐿
,
𝑅
L,R，代表询问第
𝐿
L个气球到第
𝑅
R个气球之间所有气球上的数字之和（保证
𝐿
≤
𝑅
L≤R）

输出格式

对于每个询问，输出一行一个整数代表答案。

样例输入1

4
7 10 3 5
2
1 2
1 4


样例输出1

17
25


数据范围

对于50%的数据 
𝑛
≤
1000
n≤1000,
0
≤
𝑎
𝑖
≤
1000
0≤a
i
	​

≤1000,
𝑄
≤
10
Q≤10

对于100%的数据 
𝑛
≤
1
0
6
,
0
≤
𝑎
𝑖
≤
1
0
6
,
𝑄
≤
1
0
5
n≤10
6
,0≤a
i
	​

≤10
6
,Q≤10
5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[1000005],b[100005][3];
long long c[1000005],sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i];
        c[i]=sum;
    }
    cin>>q;
    for(int i=1;i<=q;i++){
        cin>>b[i][1]>>b[i][2];
}
```

---

# 加油

## 题目描述

加油

【问题描述】

某全自动加油站 
𝑎
,
𝑏
,
𝑐
a,b,c 三种汽油的单价分别是 
1.50
，
1.35
1.50，1.35 和 
1.18
1.18 ，也提供了“自动加”或“自己或协助加”两个服务等级，这样用户可以得到 
5
%
5% 或 
10
%
10% 的优惠。

编一个程序，用户输入加油量、汽油品种和服务类型
(
𝑓
−
自动，
𝑚
−
自己或协助
)
(f−自动，m−自己或协助)，然后计算应付款。

【输入格式】

第 1 行 一个整数 
𝑛
(
1
≤
𝑛
≤
1
0
9
)
n(1≤n≤10
9
) ——加油量。一个字符 
𝑠
𝑡
1
st
1
	​

 ——汽油类型
(
𝑎
,
𝑏
,
𝑐
)
(a,b,c)。一个字符 
𝑠
𝑡
2
st
2
	​

 ——服务类型
(
𝑓
,
𝑚
)
(f,m)

【输出格式】

输出应付款，结果保留两位小数

【输入样例】

100 a f


【输出样例】

142.50

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char st1,st2;
double sum=0;
int main(){
    cin>>n>>st1>>st2;
    if(st1=='a'){
        if(st2=='f'){
            sum=n*1.50*0.95;
        }
        if(st2=='m'){
            sum=n*1.50*0.9;
        }
        }
        if(st2=='m'){
            sum=n*1.18*0.9;
        }
    }
    printf("%.2f",sum);
    return 0;
} 
}
```

---

# 贝壳游戏

## 题目描述

【题目描述】

Alice和Bob在玩一个贝壳游戏，游戏是这样的：有3个贝壳和1个鹅卵石，现在Alice可以把鹅卵石放到贝壳的下面。一开始3个贝壳在桌面上依次放着，接着Alice对两个不同的贝壳进行位置的调换，每进行依次调换，Bob就猜一次鹅卵石的位置。现在已知他们一共进行了
𝑛
n次调换，每次Bob都会猜。当Bob猜对的时候，Alice就给她一颗糖。请问Bob最多可能拿到多少颗糖？

【输入格式】

第一行输入一个数
𝑛
n，表示一共进行了
𝑛
n次调换；
(
1
≤
𝑛
≤
100
)
(1≤n≤100)

接下来输入
𝑛
n行，每行输入三个数
𝑎
,
𝑏
,
𝑔
a,b,g分别表示调换了位置
𝑎
a和
𝑏
b上的贝壳，然后Bob猜了位置
𝑔
g。（
1
≤
𝑎
,
𝑏
,
𝑔
≤
3
1≤a,b,g≤3,并且
𝑎
!
=
𝑏
a!=b）

【输出格式】

输出一个数，表示Bob最多可能得到的糖果。

【输入样例】
3
1 2 1
3 2 1
1 3 1

【输出样例】
2

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],b[105],g[105],cnt[5],sum,maxn=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i]>>b[i]>>g[i];
    }
    for(int i=1;i<=3;i++){
        cnt[i]=1;
        sum=0;
        for(int j=1;j<=n;j++){
            swap(cnt[a[j]],cnt[b[j]]);  
            if(cnt[g[j]]==1){
}
```

---

# 加油

## 题目描述

加油

【问题描述】

某全自动加油站 
𝑎
,
𝑏
,
𝑐
a,b,c 三种汽油的单价分别是 
1.50
，
1.35
1.50，1.35 和 
1.18
1.18 ，也提供了“自动加”或“自己或协助加”两个服务等级，这样用户可以得到 
5
%
5% 或 
10
%
10% 的优惠。

编一个程序，用户输入加油量、汽油品种和服务类型
(
𝑓
−
自动，
𝑚
−
自己或协助
)
(f−自动，m−自己或协助)，然后计算应付款。

【输入格式】

第 1 行 一个整数 
𝑛
(
1
≤
𝑛
≤
1
0
9
)
n(1≤n≤10
9
) ——加油量。一个字符 
𝑠
𝑡
1
st
1
	​

 ——汽油类型
(
𝑎
,
𝑏
,
𝑐
)
(a,b,c)。一个字符 
𝑠
𝑡
2
st
2
	​

 ——服务类型
(
𝑓
,
𝑚
)
(f,m)

【输出格式】

输出应付款，结果保留两位小数

【输入样例】

100 a f


【输出样例】

142.50

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char st1,st2;
float sum=0;
int main(){
    cin>>n>>st1>>st2;
    if(st1=='a'){
        if(st2=='f'){
            sum=n*1.50*0.95;
        }
        if(st2=='m'){
            sum=n*1.50*0.9;
        }
        }
        if(st2=='m'){
            sum=n*1.18*0.9;
        }
    }
    printf("%.2f",sum);
    return 0;
} 
}
```

---

# QQ看学校

## 题目描述

QQ看学校
1000ms/256mb

【问题描述】

学校简介

宁波市镇海蛟川书院，历史传承悠久，承载镇海梓荫山千年文化积淀，于乾隆八年由罗汉堂改建，次年立碑，十一年二月（1746年）正式落成开课，后易名为鲲池书院。时光荏苒，1998年镇海大成实业公司出资兴办了股份制民办初级中学，命名为宁波市镇海蛟川书院，取镇海县城别名“蛟川”之深厚文化底蕴。2001年，书院办学设施进一步完善，扩展为完全中学。2006年，投资1.6亿元的新校区一期建设基本完成，并正式投入使用。十几年来，书院发展迅速，成绩斐然，先后被评为“浙江省民办特色学校”、“浙江省义务教育标准化学校”、“浙江省艺术教育特色学校”、“浙江省健康促进学校”、“宁波市文明单位”、“宁波市示范性文明学校”、“宁波市行为规范示范学校”、“宁波市首批智慧教育试点单位”、“宁波市语言文字规范化示范学校”、“宁波市艺术特色项目学校”、“宁波市现代化达纲学校”、“首批宁波市‘数字化校园’”、“宁波市环保模范(绿色)单位”、“宁波市‘等级平安校园’5A级学校”、“宁波市‘消防安全五星级学校’”等，并被确立为“全国教育科学规划课题实验基地”、“浙江大学外国语言文化与国际交流学院教学实验基地”、“宁波大学教育硕士教学实践与研究基地”、“宁波市中小学骨干教师培训实践基地”等，在宁波市乃至浙江省有较高的社会影响力和美誉度。

【输入格式】

无

【输出格式】

整个网页内出现的“学校”数量。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<15;
    return 0;
} 
}
```

---

# 第k大数

## 题目描述

第k大数

500
𝑚
𝑠
/
128
𝑚
𝑏
500ms/128mb

【问题描述】

读入的 
𝑛
n 个数，输出其中的第 
𝑘
k 大数。

【输入格式】

第 
1
1 行两个正整数 
𝑛
,
𝑘
n,k。

第 
2
2 行包含 
𝑛
n 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

。
（
1
≤
𝑘
≤
𝑛
≤
5
∗
1
0
6
，
1
≤
𝑎
𝑖
≤
1
0
9
)
（1≤k≤n≤5∗10
6
，1≤a
i
	​

≤10
9
)

【输出格式】

输出其中的第 
𝑘
k 大数。

【输入样例】

5 2
4 2 4 5 1


【输出样例】

4

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000005],k;
void qsort(int l,int r)
{
    int i=l;
    int j=r;
    int flag=a[(l+r)/2];
    while(i<=j)
    {
        while(a[i]>flag)
        {
            i++;
        }
        }
        while(a[j]<flag)
        {
            j--;
        }
        if(i<=j)
        {
            swap(a[i],a[j]);
            i++;
            j--;
        }
    }
    if(l<=k&&k<=j&&l<j)
    {
    {
        qsort(l,j);
    }
    if(i<=k&&k<=r&&i<r)
    {
        qsort(i,r);
    }
}
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    }
    qsort(1,n);
    cout<<a[k];
    return 0;
} 
}
```

---

# 第k大数

## 题目描述

第k大数

500
𝑚
𝑠
/
128
𝑚
𝑏
500ms/128mb

【问题描述】

读入的 
𝑛
n 个数，输出其中的第 
𝑘
k 大数。

【输入格式】

第 
1
1 行两个正整数 
𝑛
,
𝑘
n,k。

第 
2
2 行包含 
𝑛
n 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

。
（
1
≤
𝑘
≤
𝑛
≤
5
∗
1
0
6
，
1
≤
𝑎
𝑖
≤
1
0
9
)
（1≤k≤n≤5∗10
6
，1≤a
i
	​

≤10
9
)

【输出格式】

输出其中的第 
𝑘
k 大数。

【输入样例】

5 2
4 2 4 5 1


【输出样例】

4

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000005],k;
void qsort(int l,int r)
{
    int i=l;
    int j=r;
    int flag=a[(l+r)/2];
    while(i<=j)
    {
        while(a[i]>flag)
        {
            i++;
        }
    {
        qsort(l,j);
    }
    if(i<=k&&k<=r&&i<r)
    {
        qsort(i,r);
    }
}
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
}
```

---

# 第k小数

## 题目描述

第k小数

1000
𝑚
𝑠
/
128
𝑚
𝑏
1000ms/128mb

【问题描述】

读入的 
𝑛
n 个数，输出其中的第 
𝑘
k 小数。

【输入格式】

第 
1
1 行两个正整数 
𝑛
,
𝑘
n,k。

第 
2
2 行包含 
𝑛
n 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

。
（
1
≤
𝑘
≤
𝑛
≤
1
0
7
，
1
≤
𝑎
𝑖
≤
1
0
9
)
（1≤k≤n≤10
7
，1≤a
i
	​

≤10
9
)

【输出格式】

输出其中的第 
𝑘
k 小数。

【输入样例】

5 1
4 2 4 5 1


【输出样例】

1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000005],k;
void qsort(int l,int r)
{
    int i=l;
    int j=r;
    int flag=a[(l+r)/2];
    while(i<=j)
    {
        while(a[i]<flag)
        {
            i++;
        }
    {
        qsort(l,j);
    }
    if(i<=k&&k<=r&&i<r)
    {
        qsort(i,r);
    }
}
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
}
```

---

# 补码

## 题目描述

题目描述

计算机的处理器是电路做的，电路只能做加法，如何能让电脑做减法呢？这就需要用到补码。减去一个数就等于加上它的补码，于是减法就转换为机器能执行的加法，计算机就能算减法了。

对于任意一个十进制整数 
𝑛
(
−
127
≤
𝑛
≤
127
)
n(−127≤n≤127) 可以用八位的二进制数表示，其中最高位是符号位，0 表示正数，1 表示负数。

我们可以按以下规则将任意一个十进制数x 转换为它对应的补码；正数的补码等于它对应的二进数本身，如[127]补=01111111；负数的补码等于对应的二进制数按位取反（0 变成1，1 变成0）再加上1。

如[-10]补 = 11110110。

求 -10 的补码的具体步骤是这样的：

(1) 转换成二进制数：1010；

(2) 扩充为8 位二进制最高位为1：10001010；

(3) 最高位保持不变，其余按位取反：11110101；

(4) 加1：11110101+1=11110110。

请编写一个程序求二进制整数的补码。

【输入格式】

一个十进制整数n（
−
127
≤
𝑛
≤
127
−127≤n≤127）。

样例输入1
-10

样例输出1
11110110  

样例输入2
127

样例输出2
01111111

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[10],sum=7;
int check(){
    for(int i=7;i>=2;i--){
        if(a[i]>=2){
            a[i-1]+=1;
            a[i]=0;
            return false;
        }
    }
    return true;
}
int main(){
    }
    if(n<0){
        for(int i=1;i<=7;i++){
            if(a[i]==1){
                a[i]=0;
            }
            else{
                a[i]=1;
            }
        }
        a[7]+=1;
        while(true){
            if(check()){
                break;
            }
}
```

---

# 打印菱形4

## 题目描述

【问题描述】

用“ * ”打印一个美丽的空心菱形

【输入格式】

一个整数
𝑛
n表示菱形的行数。
𝑛
n为奇数。

【输出格式】

无

【输入样例】

5


【输出样例】

  *
 * *
*   *
 * *
  *

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=1;
bool flag=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if((i+j==n/2+2)||((i>n/2+1)&&(i+j==n/2+2*(i-n/2)))){
                cout<<"*";
                for(int k=1;k<=sum-2;k++){
                    cout<<" ";
                }
                if(i!=n&&i!=1){
                cout<<" ";
            }
        }
        cout<<endl;
    }
    return 0;
}
}
```

---

# 补码

## 题目描述

题目描述

计算机的处理器是电路做的，电路只能做加法，如何能让电脑做减法呢？这就需要用到补码。减去一个数就等于加上它的补码，于是减法就转换为机器能执行的加法，计算机就能算减法了。

对于任意一个十进制整数 
𝑛
(
−
127
≤
𝑛
≤
127
)
n(−127≤n≤127) 可以用八位的二进制数表示，其中最高位是符号位，0 表示正数，1 表示负数。

我们可以按以下规则将任意一个十进制数x 转换为它对应的补码；正数的补码等于它对应的二进数本身，如[127]补=01111111；负数的补码等于对应的二进制数按位取反（0 变成1，1 变成0）再加上1。

如[-10]补 = 11110110。

求 -10 的补码的具体步骤是这样的：

(1) 转换成二进制数：1010；

(2) 扩充为8 位二进制最高位为1：10001010；

(3) 最高位保持不变，其余按位取反：11110101；

(4) 加1：11110101+1=11110110。

请编写一个程序求二进制整数的补码。

【输入格式】

一个十进制整数n（
−
127
≤
𝑛
≤
127
−127≤n≤127）。

样例输入1
-10

样例输出1
11110110  

样例输入2
127

样例输出2
01111111

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[10],sum=7;
int check(){
    for(int i=7;i>=2;i--){
        if(a[i]>=2){
            a[i-1]+=1;
            a[i]=0;
            return false;
        }
    }
    return true;
}
int main(){
    }
    if(n<0){
        for(int i=1;i<=7;i++){
            if(a[i]==1){
                a[i]=0;
            }
            else{
                a[i]=1;
            }
        }
        a[7]+=1;
        while(true){
            if(check()){
                break;
            }
}
```

---

# 打印菱形3

## 题目描述

打印菱形3

【问题描述】

用数字打印一个美丽的菱形

【输入格式】

一个整数
𝑛
n表示菱形的行数。
𝑛
n为奇数。

【输出格式】

𝑛
n行

【输入样例】

5


【输出样例】

  1
 222
33333
 444
  5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=1;
bool flag=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if((i+j==n/2+2)||((i>n/2+1)&&(i+j==n/2+2*(i-n/2)))){
                for(int k=1;k<=sum;k++){
                    cout<<i;
                }
                if(sum<n&&flag==0){
                    sum+=2;
    }
    return 0;
}
}
```

---

# 打印菱形2

## 题目描述

打印菱形2

【问题描述】

用“*”打印一个美丽的菱形

【输入格式】

一个整数
𝑛
n表示菱形的行数。
𝑛
n为奇数。

【输出格式】

无

【输入样例】

5


【输出样例】

  *
 ***
*****
 ***
  *

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=1;
bool flag=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if((i+j==n/2+2)||((i>n/2+1)&&(i+j==n/2+2*(i-n/2)))){
                for(int k=1;k<=sum;k++){
                    cout<<"*";
                }
                if(sum<n&&flag==0){
                    sum+=2;
    }
    return 0;
}
}
```

---

# 打印菱形1

## 题目描述

打印菱形

【问题描述】

用“*”打印一个美丽的菱形

【输入格式】

无

【输出格式】

无

【输入样例】

无


【输出样例】

   *
  ***
 *****
  ***
   *

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<"   *"<<endl;
    cout<<"  ***"<<endl;
    cout<<" *****"<<endl;
    cout<<"  ***"<<endl;
    cout<<"   *";
    return 0;
}
}
```

---

# 查找2

## 题目描述

查找
1000ms/128mb

【问题描述】

输入 
𝑛
(
𝑛
≤
1
0
6
)
n(n≤10
6
) 个不超过 
1
0
9
10
9
 的单调不减的（就是后面的数字不小于前面的数字）非负整数 
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
a
1
	​

,a
2
	​

,…,a
n
	​

，然后进行 
𝑚
(
𝑚
≤
1
0
5
)
m(m≤10
5
) 次询问。

对于每次询问，给出一个整数 
𝑞
(
𝑞
≤
1
0
9
)
q(q≤10
9
)，要求输出这个数字在序列中最后一次出现的编号，如果没有找到的话输出 -1 。

【输入格式】

第一行 2 个整数 n 和 m，表示数字个数和询问次数。

第二行 n 个整数，表示这些待查询的数字。

第三行 m 个整数，表示询问这些数字的编号，从 1 开始编号。

【输出格式】

m 个整数表示答案。

【输入样例】

11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6


【输出样例】

1 4 -1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[1000005],b[100005];
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=q;i++){
        scanf("%d",&b[i]);
    }
    for(int i=1;i<=q;i++){
        int l=1,r=n,mid;
        while(l<r){
            cout<<l<<" ";
        }
        else{
            cout<<-1<<" ";
        }
    }
    return 0;
}
}
```

---

# 第k小数

## 题目描述

第k小数

1000
𝑚
𝑠
/
128
𝑚
𝑏
1000ms/128mb

【问题描述】

读入的 
𝑛
n 个数，输出其中的第 
𝑘
k 小数。

【输入格式】

第 
1
1 行两个正整数 
𝑛
,
𝑘
n,k。

第 
2
2 行包含 
𝑛
n 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

。
（
1
≤
𝑘
≤
𝑛
≤
1
0
7
，
1
≤
𝑎
𝑖
≤
1
0
9
)
（1≤k≤n≤10
7
，1≤a
i
	​

≤10
9
)

【输出格式】

输出其中的第 
𝑘
k 小数。

【输入样例】

5 1
4 2 4 5 1


【输出样例】

1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000005],k;
void qsort(int l,int r)
{
    int i=l;
    int j=r;
    int flag=a[(l+r)/2];
    while(i<=j)
    {
        while(a[i]<flag)
        {
            i++;
        }
        }
        while(a[j]>flag)
        {
            j--;
        }
        if(i<=j)
        {
            swap(a[i],a[j]);
            i++;
            j--;
        }
    }
    if(l<=k&&k<=j&&l<j)
    {
    {
        qsort(l,j);
    }
    if(i<=k&&k<=r&&i<r)
    {
        qsort(i,r);
    }
}
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    }
    qsort(1,n);
    cout<<a[k];
    return 0;
} 
}
```

---

# 排序3

## 题目描述

排序3

1000
𝑚
𝑠
/
128
𝑚
𝑏
1000ms/128mb

【问题描述】

读入的 
𝑁
N 个数从小到大排序后输出。

【输入格式】

第 
1
1 行为一个正整数 
𝑁
N，第 
2
2 行包含 
𝑁
N 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

，为你需要进行排序的数，数据保证了 
𝐴
𝑖
A
i
	​

 不超过 
1
0
9
10
9
。
(
1
≤
𝑁
≤
1
0
5
，
1
≤
𝑎
𝑖
≤
1
0
9
)
(1≤N≤10
5
，1≤a
i
	​

≤10
9
)

【输出格式】

将给定的 
𝑁
N 个数从小到大输出，数之间空格隔开，每个数之间都有一个空格。

【输入样例】

5
4 2 4 5 1


【输出样例】

1 2 4 4 5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
    {
        cout<<a[i]<<" ";
}
```

---

# 排序2

## 题目描述

排序2

1000
𝑚
𝑠
/
128
𝑚
𝑏
1000ms/128mb

【问题描述】

读入的 
𝑁
N 个数从小到大排序后输出。

【输入格式】

第 
1
1 行为一个正整数 
𝑁
N，第 
2
2 行包含 
𝑁
N 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

，为你需要进行排序的数，数据保证了 
𝐴
𝑖
A
i
	​

 不超过 
1
0
9
10
9
。
(
1
≤
𝑁
≤
1
0
3
，
1
≤
𝑎
𝑖
≤
1
0
9
)
(1≤N≤10
3
，1≤a
i
	​

≤10
9
)

【输出格式】

将给定的 
𝑁
N 个数从小到大输出，数之间空格隔开，每个数之间都有一个空格。

【输入样例】

5
4 2 4 5 1


【输出样例】

1 2 4 4 5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
    {
        cout<<a[i]<<" ";
}
```

---

# 排序1

## 题目描述

排序1

1000
𝑚
𝑠
/
128
𝑚
𝑏
1000ms/128mb

【问题描述】

读入的 
𝑁
N 个数从小到大排序后输出。

【输入格式】

第 
1
1 行为一个正整数 
𝑁
N，第 
2
2 行包含 
𝑁
N 个空格隔开的正整数 
𝑎
𝑖
a
i
	​

，为你需要进行排序的数，数据保证了 
𝐴
𝑖
A
i
	​

 不超过 
1000
1000。
(
1
≤
𝑁
≤
1
0
5
，
1
≤
𝑎
𝑖
≤
1000
)
(1≤N≤10
5
，1≤a
i
	​

≤1000)

【输出格式】

将给定的 
𝑁
N 个数从小到大输出，数之间空格隔开，每个数之间都有一个空格。

【输入样例】

5
4 2 4 5 1


【输出样例】

1 2 4 4 5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
    {
        cout<<a[i]<<" ";
}
```

---

# 参观

## 题目描述

未能提取到题目信息

### 代码

```cpp
未能提取到完整代码内容
```

---

# 导弹拦截

## 题目描述

【题目描述】

有个特殊的导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹。

导弹数量最多 
1
0
3
10
3
 个

【样例输入】

389 207 155 300 299 170 158 65


【样例输出】

6

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005],n,x,f[1005],ans=-1;
int main()
{
    while(cin>>x) 
    {
        a[++n]=x;
    }
    for(int i=1; i<=n; i++)
    {
        f[i]=1;
        for(int j=1; j<=i-1; j++) 
        {
        {
            if(a[j]>=a[i])
            {
                f[i]=max(f[i],f[j]+1);
            }
        }
        ans=max(ans,f[i]);
    }
    cout<<ans;
    return 0;
}
}
```

---

# 导弹拦截

## 题目描述

【题目描述】

有个特殊的导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹。

导弹数量最多 
1
0
3
10
3
 个

【样例输入】

389 207 155 300 299 170 158 65


【样例输出】

6

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005],n,x,f[1005],ans=-1;
int main() {
    while(cin>>x) {
        a[++n]=x;
    }
    for(int i=1; i<=n; i++) {
        f[i]=1;
        for(int j=1; j<=i-1; j++) {
            if(a[j]>=a[i]) {
                f[i]=max(f[i],f[j]+1);
            }
        }
        }
        ans=max(ans,f[i]);
    }
    cout<<ans;
    return 0;
}
}
```

---

# 麻将游戏

## 题目描述

【问题描述】

在一种"麻将"游戏中，游戏是在一个有 w*h 格子的矩形平板上进行的。每个格子可以放置一个麻将牌，也可以不放（如图所示）。玩家的目标是将平板上的所有可通过一条路径相连的两张相同的麻将牌，从平板上移去。最后如果能将所有牌移出平板，则算过关。 这个游戏中的一个关键问题是：两张牌之间是否可以被一条路径所连接，该路径满足以 下两个特性：

它由若干条线段组成，每条线段要么是水平方向，要么是垂直方向。

这条路径不能横穿任何一个麻将牌 (但允许路径暂时离开平板)。

这是一个例子：

在（1，3）的牌和在(4, 4)的牌可以被连接。(2, 3)和(3, 4)不能被连接。

你的任务是编一个程序，检测两张牌是否能被一条符合以上规定的路径所连接。

【输入格式】

输入文件的第一行有两个整数 w，h （1<=w，h<=75），表示平板的宽和高。接下来 h 行描述平板信息，每行包含 w 个字符，如果某格子有一张牌，则这个格子上有个'X'，否则是一个空格。平板上最左上角格子的坐标为（1，1），最右下角格子的坐标为（w,h）。接下来的若干行，每行有四个数 x1， y1， x2， y2 ，且满足 1<=x1,x2<=w，1<=y1,y2<=h，表示两张牌的坐标（这两张牌的坐标总是不同的）。如果出现连续四个 0，则表示输入结束。

【输出格式】

输出文件中，对于每一对牌输出占一行，为连接这一对牌的路径最少包含的线段数。如果不存在路径则输出 0。

【样例输入】(参照上图)：
5 4 
XXXXX
X   X
XXX X
 XXX 
2 3 5 3 
1 3 4 4 
2 3 3 4 
0 0 0 0 

【样例输出】
4 
3 
0

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAX_N 75
#define MAX_M 75
#define Min(x, y) (x <= y ? x : y)
using namespace std;
int n,m,a[MAX_N+3][MAX_M+3];
int BFS(int sx, int sy, int tx, int ty)
{
    queue<int> qx, qy;
    int f[MAX_N + 3][MAX_M + 3];
    memset(f, 0, sizeof f);
    qx.push(sx);
    qy.push(sy);
    qy.push(sy);
    int x, y;
    int ans = 0;
    while(!qx.empty())
    {
        ++ans;
        for( int I = qx.size(); I; --I)
        {
            x=qx.front();
            y=qy.front();
            qx.pop();
            qy.pop();
            for( int i=x-1;i;--i)
            {
            {
                if(f[i][y])
                {
                    continue;
                }
            if(a[i][y]){
            if(i==tx&&y==ty){
            return ans;
        }
        break;
    }
    f[i][y]=1;
    qx.push(i);
    qy.push(y);
    }
    }
    for( int i=x+1;i<=n;++i){
    if(f[i][y]){
    continue;
    }
    if(a[i][y]){
    if(i == tx && y == ty) return ans;
    break;
    }
    f[i][y] = 1;
    qx.push(i);
    qy.push(y);
    }
    for( int i = y-1;i;--i){
    for( int i = y-1;i;--i){
    if(f[x][i]){
    continue;
    }
    if(a[x][i]){
    if(x == tx && i == ty) return ans;
    break;
    }
    f[x][i] = 1;
    qx.push(x);
    qy.push(i);
    }
    for( int i = y + 1; i <= m; ++i)
    {
    if(f[x][i]) continue;
    if(f[x][i]) continue;
    if(a[x][i])
    {
    if(x == tx && i == ty) return ans;
    break;
    }
    f[x][i] = 1;
    qx.push(x);
    qy.push(i);
    }
    }
    }
    return 0;
    }
    }
int main(){
    scanf("%d%d", &m, &n);
    n+=2,m+=2;
    char ch;
    for(int i=2;i<n;++i)
    {
        if(ch!='\n')
        {
            getchar();
        }
        for(int j=2;j<m;++j)
        {
            ch=getchar();
            a[i][j]=(ch=='X');
            a[i][j]=(ch=='X');
            if(ch == '\n') 
            {
                break;
            }
        }
    }
    int sx, sy, tx, ty;
    while(scanf("%d%d%d%d", &sy, &sx, &ty, &tx) && (sx || sy || tx || ty))
    {
        ++sx;
        ++sy; 
        ++tx; 
        ++ty;
        ++ty;
        printf("%d\n", BFS(sx, sy, tx, ty));
    }
    return 0;
}
}
```

---

# 01迷宫

## 题目描述

01迷宫
1000ms/128mb

【问题描述】

有一个仅由数字
0
0与
1
1组成的
𝑛
×
𝑛
n×n格迷宫。若你位于一格
0
0上，那么你可以移动到相邻
4
4格中的某一格
1
1上，同样若你位于一格
1
1上，那么你可以移动到相邻
4
4格中的某一格
0
0上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

【输入格式】

第
1
1行为两个正整数
𝑛
,
𝑚
n,m。

下面
𝑛
n行，每行
𝑛
n个字符，字符只可能是
0
0或者
1
1，字符之间没有空格。

接下来
𝑚
m行，每行
2
2个用空格分隔的正整数
𝑖
,
𝑗
i,j，对应了迷宫中第
𝑖
i行第
𝑗
j​列的一个格子，询问从这一格开始能移动到多少格。

【输出格式】

𝑚
m行，对于每个询问输出相应答案。

【输入样例】

2 2
01
10
1 1
2 2


【输出样例】

4
4


【说明】

所有格子互相可达。

对于
100
%
100%的数据，
𝑛
≤
1000
,
𝑚
≤
100000
n≤1000,m≤100000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[100002],x,y,f[1002][1002]; 
char s[1002][1002]; 
void dfs(int r,int c,int z,int lll)
{
    if (r<0 || r>=n || c<0 || c>=n || f[r][c]!=-1 || s[r][c]-'0'!=z)
    {
        return; 
    }
    f[r][c]=lll;ans[lll]++; 
    dfs(r-1,c,!z,lll);dfs(r+1,c,!z,lll);dfs(r,c-1,!z,lll);dfs(r,c+1,!z,lll); 
}
int main()
int main()
{
    scanf("%d%d",&n,&m); 
    for (int i=0;i<n;i++)
    scanf("%s",s[i]); 
    memset(f,-1,sizeof(f)); 
    for (int i=0;i<m;i++)
    {
        scanf("%d%d",&x,&y);x--;y--; 
        if (f[x][y]==-1)
        {
            dfs(x,y,s[x][y]-'0',i); 
        }
        else
        else
        {
            ans[i]=ans[f[x][y]]; 
        } 
    }
    for (int i=0;i<m;i++)
    {
        printf("%d\n",ans[i]);
    }
    return 0;
}
}
```

---

# 分数查询

## 题目描述

分数查询

1000
𝑚
𝑠
/
256
𝑚
𝑏
1000ms/256mb

故事背景

作为一名功成名就的大师，odio 有很多弟子 
1
−
𝑁
1−N ，他经常想知道编号从 
𝐴
−
𝐵
A−B 的弟子中分数的最大值是多少，你能帮他吗？

当然，作为一名大师，odio 会根据弟子平时表现更改他的成绩。

作为他的助手，你得写一个程序来实现上述功能。

输入格式

第一行两个正整数 
𝑁
N 和 
𝑀
M ，分别代表弟子的数目和操作的数目。弟子ID编号分别从 1 编到 
𝑁
N 。

第二行包含 
𝑁
N 个整数，代表这 
𝑁
N 个弟子的初始成绩，其中第 
𝑖
i 个数代表ID为 
𝑖
i 的弟子的成绩。

接下来有 
𝑀
M 行。每一行有一个字符 
𝐶
C (只取 Q 或 U ) ，和两个正整数 
𝐴
,
𝐵
A,B。

当 
𝐶
C 为 Q 的时候，表示这是一条询问操作，它询问 ID 从 
𝐴
A 到 
𝐵
B (包括 
𝐴
,
𝐵
A,B)的弟子当中，成绩最高的是多少。
当 
𝐶
C 为 U 的时候，表示这是一条更新操作，要求把 ID 为 
𝐴
A 的弟子的成绩更改为
𝐵
B。
输出格式

对于每一次询问操作，在一行里面输出最高成绩。

样例 #1
样例输入 #1
5 6
1 2 3 4 5
Q 1 5
U 3 6
Q 3 4
Q 4 5
U 2 9
Q 1 5

样例输出 #1
5
6
5
9

数据范围及说明

对于 
30
%
30% 的数据： 
0
<
𝑁
≤
2000
,
0
<
𝑀
<
5000
0<N≤2000,0<M<5000。

对于 
100
%
100% 的数据： 
0
<
𝑁
≤
200000
,
0
<
𝑀
<
5000
0<N≤200000,0<M<5000。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long INF=(1<<31)-1;
const int maxn=2e6+100;
int n,m,x,y;
char op;
int sum[maxn],a[maxn];
void build(int o,int L,int R)
{
    if (L==R)
    {
        sum[o]=a[R];
        return;
    }
    }
    int M=(L+R)/2;
    build(o*2,L,M);
    build(o*2+1,M+1,R);
    sum[o]=max(sum[o*2],sum[o*2+1]);
}
void update(int o,int L,int R)
{
    if (L==R)
    {
        sum[o]=y;
        return;
    }
    int M=(L+R)/2;
    int M=(L+R)/2;
    if (x<=M) 
    {
        update(o*2,L,M);
    }
    else 
    {
        update(o*2+1,M+1,R);
    }
    sum[o]=max(sum[o*2],sum[o*2+1]);
}
int query(int o,int L,int R)
{
    if (x<=L&&R<=y)
    {
    {
        return sum[o];
    }
    int ans=INT_MIN;
    int M=(L+R)/2;
    if (x<=M) 
    {
        ans=max(ans,query(o*2,L,M));
    }
    if (y>M) 
    {
        ans=max(ans,query(o*2+1,M+1,R));
    }
    return ans;
    return ans;
}
int main()
{
    while (cin>>n>>m)
    {
        for (int i=1;i<=n;i++) 
        {
            cin>>a[i];
        }
        build(1,1,n);
        for (int i=1;i<=m;i++)
        {
            cin>>op>>x>>y;
            if (op=='U')
            if (op=='U')
            {
                update(1,1,n);
            }
            else 
            {
                cout<<query(1,1,n)<<endl;
            }
        }       
    }
    return 0; 
}
}
```

---

# 水灾

## 题目描述

1S/256M

【题目描述】

超市被突来的洪水淹没了>.<还好超市总部有在某些重要的地方起一些围墙，用 
∗
∗ 号表示，而一个封闭的 
∗
∗ 号区域洪水是进不去的，现在给出超市的围墙建设图，问超市没被淹到的重要区域（由"0"表示）有多少。

【输入格式】

第一行是两个数：x和y 
(
1
≤
𝑥
,
𝑦
≤
500
)
(1≤x,y≤500)

第二行及以下是一个由*和 0 组成的 x * y 的图。

【输出格式】

输出没被水淹没的超市的 0 的数量。

【输入样例1】

4 5
00000
00*00
0*0*0
00*00


【输出样例1】

1


【输入样例2】

5 5
*****
*0*0*
**0**
*0*0*
*****


【输出样例2】

5

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m;
char ch[505][505];
bool vis[505][505];
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
void dfs(int x,int y)
{
    if(vis[x][y]==true)
    {
        return;
    } 
    } 
    vis[x][y]=true;
    for(int i=0;i<4;i++)
    {
        int tx=x+dx[i];
        int ty=y+dy[i];
        if(tx<1||tx>n||ty<1||ty>m||ch[tx][ty]=='*' ) 
        {
            continue;
        }
        dfs(tx,ty);
    }
}
int main()
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>ch[i][j];
            if(ch[i][j]=='*') 
            {
                vis[i][j]=true;
            }
            }
        }
    }
    for(int j=1;j<=m;j++)
    {
        if(vis[1][j]==false&&ch[1][j]=='0') 
        {
            dfs(1,j);
        }
        if(vis[n][j]==false&&ch[n][j]=='0') 
        {
            dfs(n,j);
        }
    }
    }
    for(int i=1;i<=n;i++)
    {
        if(vis[i][1]==false&&ch[i][1]=='0')
        {
            dfs(i,1);
        } 
        if(vis[i][m]==false&&ch[i][m]=='0') 
        {
            dfs(i,m);
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
    {
        for(int j=1;j<=m;j++)
        {
            if(vis[i][j]==false&&ch[i][j]=='0')
            {
                ans++;
            }
    
        }
    }
    cout<<ans;
    return 0;
}
```

---

# 序列

## 题目描述

0.2s/128M

【题目描述】

有三种操作。 操作一：用一个大于 
0
0 的整数 
𝐴
A 来表示，表示在序列的开头增加一个数 
𝐴
A 操作二：用 
−
1
−1 来表示，表示输出序列开头的数，并删除。 操作三：用 
0
0 来表示，表示把整数序列复制一份，并接在末尾。

【输入格式】

第一行整数 
𝑁
N，表示操作的个数。 接下来 
𝑁
N 行每行一个整数表示每个操作。

【输出格式】

操作三对应的若干行输出

【样例输入】

9
5
4
3
-1
0
2
-1
0
-1


【样例输出】

3
2
4


【数据范围】

对于50%的数据，1<=N<=1000.
对于100%的数据，1<=N<=10^6，-1<=A<=10^9。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
// 定义全局变量
int _, n, a[4000005], l = 2000000, r = 1999999, ans[1000005], xb;
int main() {
scanf("%d", &_); // 读取操作数
while (_--) { // 循环处理每个操作
scanf("%d", &n);
if (n > 0) { // 操作一：在序列开头增加一个数
a[--l] = n; // 将数 n 放入数组 a 的开头（通过递减 l 实现）
} else if (n == 0) { // 操作三：复制序列并接在末尾
int z = r - l + 1; // 计算当前序列的长度
int y = r; // y 用于后续可能的调试或记录，但在此代码中未使用
if (z >= _) { // 如果当前序列长度已经大于等于剩余操作数，则无需复制（因为后续操作可能都是 -1）
if (z >= _) { // 如果当前序列长度已经大于等于剩余操作数，则无需复制（因为后续操作可能都是 -1）
continue;
}
// 复制序列
for (int i = r + 1; i <= r + z; ++i) {
a[i] = a[i - z];
}
r = r + z; // 更新 r 以指向新序列的末尾
} else { // 操作二：-1
if (l > r) { // 如果序列为空，则无需执行任何操作
continue;
}
ans[++xb] = a[l]; // 将序列开头的数存入 ans 数组
++l; // 删除序列开头的数（通过递增 l 实现）
++l; // 删除序列开头的数（通过递增 l 实现）
}
// 注释掉的代码段用于调试，可以打印出当前数组 a 的有效部分
/*for(int i = l; i <= r; ++i)
cout << a[i] << ' ';
cout << '\n';*/
}
// 输出所有由 -1 操作输出的值
for (int i = 1; i <= xb; ++i) {
printf("%d\n", ans[i]);
}
}
}
```

---

# 序列

## 题目描述

0.2s/128M

【题目描述】

有三种操作。 操作一：用一个大于 
0
0 的整数 
𝐴
A 来表示，表示在序列的开头增加一个数 
𝐴
A 操作二：用 
−
1
−1 来表示，表示输出序列开头的数，并删除。 操作三：用 
0
0 来表示，表示把整数序列复制一份，并接在末尾。

【输入格式】

第一行整数 
𝑁
N，表示操作的个数。 接下来 
𝑁
N 行每行一个整数表示每个操作。

【输出格式】

操作三对应的若干行输出

【样例输入】

9
5
4
3
-1
0
2
-1
0
-1


【样例输出】

3
2
4


【数据范围】

对于50%的数据，1<=N<=1000.
对于100%的数据，1<=N<=10^6，-1<=A<=10^9。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int _, n, a[4000005], l = 2000000, r = 1999999, ans[1000005], xb;
int main() 
{
    scanf("%d", &_);
    while (_--)
    {
        scanf("%d", &n);
        if (n > 0) 
        {
            a[--l] = n; 
        } 
        else if (n == 0)
        else if (n == 0)
        {
            int z = r - l + 1;
            int y = r; 
            if (z >= _) 
            { 
                continue;
            }
            for (int i = r + 1; i <= r + z; ++i) 
            {
                a[i] = a[i - z];
            }
            r = r + z; 
        }
        }
        else 
        { 
            if (l > r)
            { 
                continue;
            }
            ans[++xb] = a[l]; 
            ++l;
        }
        
    }
    for (int i = 1; i <= xb; ++i) 
    {
        printf("%d\n", ans[i]);
        printf("%d\n", ans[i]);
    }
}
}
```

---

# 买铅笔

## 题目描述

未能提取到题目信息

### 代码

```cpp
未能提取到完整代码内容
```

---

# 分苹果

## 题目描述

未能提取到题目信息

### 代码

```cpp
未能提取到完整代码内容
```

---

# 输出图形

## 题目描述

未能提取到题目信息

### 代码

```cpp
未能提取到完整代码内容
```

---

# 奇怪的电梯

## 题目描述

【题目描述】

大楼的每一层楼都可以停电梯，而且第 
𝑖
i 层楼（
1
≤
𝑖
≤
𝑁
1≤i≤N）上有一个数字
𝐾
𝑖
(
0
≤
𝐾
𝑖
≤
𝑁
)
K
i
	​

(0≤K
i
	​

≤N)。

电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。

例如：3 3 1 2 5代表了
𝐾
𝑖
(
𝐾
1
=
3
,
𝐾
2
=
3
,
…
…
)
K
i
	​

(K
1
	​

=3,K
2
	​

=3,……)，从一楼开始。在一楼，按“上”可以到4楼，按“下”是不起作用的，因为没有-2楼。

那么，从 
𝐴
A 楼到 
𝐵
B 楼至少要按几次按钮呢？

【数据输入】

共有二行，第一行为三个用空格隔开的正整数，表示 
𝑁
,
𝐴
,
𝐵
(
1
≤
𝑁
≤
200
,
1
≤
𝐴
,
𝐵
≤
𝑁
)
N,A,B(1≤N≤200,1≤A,B≤N)，第二行为 
𝑁
N 个用空格隔开的正整数，表示 
𝐾
𝑖
K
i
	​

。

【数据输出】

一行，即最少按键次数,若无法到达，则输出-1。

【输入样例】
5 1 5
3 3 1 2 5

【输出样例】
3

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a,b,tmp;
struct floors
{
    int up,down,step;
    bool visit;
}fs[205];
int main()
{
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++)
    {
        cin>>tmp;
        cin>>tmp;
        fs[i].up=i+tmp;
        fs[i].down=i-tmp;
        fs[i].step=-1;
        fs[i].visit=false;
    }
    queue<floors>q;
    fs[a].step=0;
    fs[a].visit=true;
    q.push(fs[a]);
    while(!q.empty())
    {
        floors f=q.front();
        q.pop();
        q.pop();
        int u=f.up,d=f.down;
        if(u>=1&&u<=n&&fs[u].visit==false)
        {
            fs[u].visit=true;
            fs[u].step=f.step+1;
            q.push(fs[u]);
        }
        if(d>=1&&d<=n&&fs[d].visit==false)
        {
            fs[d].visit=true;
            fs[d].step=f.step+1;
            q.push(fs[d]);
        }
        if(u==b||d==b)
        if(u==b||d==b)
        {
            break;
        }
    }
    cout<<fs[b].step;
}
}
```

---

# 砝码称重

## 题目描述

【问题描述】

设有 
1
𝑔
，
2
𝑔
，
3
𝑔
，
5
𝑔
，
10
𝑔
，
20
𝑔
1g，2g，3g，5g，10g，20g 的砝码各若干枚（其总重 
≤
1000
𝑔
≤1000g）。

【输入格式】

输入6个数，分别表示各种重量的砝码的数量。

𝑎
1
、
𝑎
2
、
𝑎
3
、
𝑎
4
、
𝑎
5
、
𝑎
6
a
1
	​

、a
2
	​

、a
3
	​

、a
4
	​

、a
5
	​

、a
6
	​

(表示 
1
𝑔
1g 砝码有 
𝑎
1
a
1
	​

 个，
2
𝑔
2g 砝码有 
𝑎
2
a
2
	​

 个，....
20
𝑔
20g 砝码有 
𝑎
6
a
6
	​

 个)

【输出格式】

𝑇
𝑜
𝑡
𝑎
𝑙
=
𝑁
Total=N(
𝑁
N 表示用这些砝码能称出的不同重量的个数，但不包括一个砝码也不用的情况)

【输入样例】

1 1 0 0 0 0


【输出样例】

Total=3 //表示可以称出 1g，2g，3g 三种不同的重量

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10],ans=0,f[1005],b[10]={0,1,2,3,5,10,20};
void dfs(int dep,int tot)
{
    if(dep>6)
    {
        f[tot]=1;
        return;
    }
    for(int i=0;i<=a[dep];i++)
    {
        dfs(dep+1,tot+i*b[dep]);
    }
    }
}
int main()
{
    for(int i=1;i<=6;i++)
    {
        cin>>a[i];
    }
    dfs(1,0);
    for(int i=1;i<=1000;i++)
    {
        if(f[i])
        {
            ans+=1;
            ans+=1;
        }
    }
    cout<<"Total="<<ans;
    return 0;
}
}
```

---

# 数字三角形

## 题目描述

【问题描述】

一个数字三角形。 请编一个程序计算从顶至底的某处的一条路 径，使该路径所经过的数字的总和最大。

每一步可沿左斜线向下或右斜线向下走；

1 < 三角形行数 < 25；

三角形中的数字为整数 < 1000；

【样例输入】

5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5


【样例输出】

30

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[30][30],n,d[110][110];
void fun()
{
    for(int j=1;j<=n;j++)
    {
        d[n][j]=a[n][j];
    }
    for(int i=n-1;i>=1;i--)
    {
        for(int j=1;j<=i;j++)
        {
            d[i][j]=a[i][j]+max(d[i+1][j],d[i+1][j+1]);
            d[i][j]=a[i][j]+max(d[i+1][j],d[i+1][j+1]);
        }
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cin>>a[i][j];
        }
    }
    }
    fun();
    cout<<d[1][1]<<endl;
    return 0;
}
}
```

---

# 数字三角形

## 题目描述

【问题描述】

一个数字三角形。 请编一个程序计算从顶至底的某处的一条路 径，使该路径所经过的数字的总和最大。

每一步可沿左斜线向下或右斜线向下走；

1 < 三角形行数 < 25；

三角形中的数字为整数 < 1000；

【样例输入】

5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5


【样例输出】

30

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[30][30],n,s,maxn;
void dfs(int x,int y,int sum)
{
    maxn=max(sum,maxn);
    if(x+1<=n)
    {
        dfs(x+1,y,sum+a[x+1][y]);
        dfs(x+1,y+1,sum+a[x+1][y+1]);
    }
}
int main()
{
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cin>>a[i][j];
        }
    }
    dfs(1,1,a[1][1]);
    cout<<maxn<<endl;
    return 0;
}
}
```

---

# 合唱队形

## 题目描述

题目描述

𝑛
n 位同学站成一排, 音乐老师要请其中的 
𝑛
−
𝑘
n−k 位同学出列, 使得剩下的 
𝑘
k 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 
𝑘
k 位同学从左到右依次编号为 $1, 2, $ … 
,
𝑘
,k, 他们的身高分别为 $t_1, t_2, $ … 
,
𝑡
𝑘
,t
k
	​

, 则他们的身高满足 
𝑡
1
<
⋯
<
𝑡
𝑖
>
𝑡
𝑖
+
1
>
t
1
	​

<⋯<t
i
	​

>t
i+1
	​

> … 
>
𝑡
𝑘
(
1
≤
𝑖
≤
𝑘
)
>t
k
	​

(1≤i≤k)。

你的任务是, 已知所有 
𝑛
n 位同学的身高, 计算最少需要几位同学出列, 可以使得剩下的同学排成合唱队形。

输入格式

共二行。

第一行是一个整数 
𝑛
n, 表示同学的总数。

第二行有 
𝑛
n 个整数, 用空格分隔, 第 
𝑖
i 个整数 
𝑡
𝑖
t
i
	​

 是第 
𝑖
i 位同学的身高 (P.S. 单位是厘米)。

输出格式

一个整数, 最少需要几位同学出列。

样例输入 #1
8
186 186 150 200 160 130 197 220

样例输出 #1
4

数据范围和提示

对于 
50
%
50% 的数据, 保证有 
2
≤
𝑛
≤
20
2≤n≤20。

对于全部的数据, 保证有 
2
≤
𝑛
≤
100
2≤n≤100, 
130
≤
𝑡
𝑖
≤
230
130≤t
i
	​

≤230。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,j,a[110],dpa[110],dpb[110],ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        dpa[i]=1;
        for(int j=1;j<i;j++)
        for(int j=1;j<i;j++)
        {
            if(a[j]<a[i])
            {
                dpa[i]=max(dpa[i],dpa[j]+1);
            }
        }
    }
    for(int i=n;i>=1;i--)
    {
        dpb[i]=1;
        for(int j=n;j>i;j--)
        {
            if(a[j]<a[i])
            if(a[j]<a[i])
            {
                dpb[i]=max(dpb[i],dpb[j]+1);
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        ans=max(ans,dpa[i]+dpb[i]-1);
    }
    cout<<n-ans;
    return 0;
}
}
```

---

# 矩阵

## 题目描述

1S/256M

【问题描述】

给定一个n∗m的矩阵，每次你可以选择前进一格或转弯（90度），求在不出这个矩阵的情况下遍历全部格点所需最少转弯次数。有多组数据

【输入格式】

第一行一个整数k，表示数据组数(1<=k<=50000) 以下k行，每行两个整数n,m，表示矩阵大小(1<=n,m<=1000000)

【输出格式】

输出一个整数，即最少转弯次数

【输入样例1】

2
1 10
10 1


【输出样例1】

0
0


【输入样例2】

3
1 1
3 3
3 4


【输出样例2】

0
4
4


【输入样例3】

2
5 8
6 4


【输出样例3】

8
6

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,x;
int main()
{
    cin>>k;
    for(int i=1;i<=k;i++)
    {
        n=0,m=0;
        cin>>n>>m;
        if(n==1||m==1)
        {
            cout<<0<<endl;
        }
        }
        else 
        {   
            x=min(n,m);
            cout<<(x-1)*2<<endl;
        }
    }
    return 0;
}
}
```

---

# 导游

## 题目描述

宁波市的中小学生们在镇海中学参加程序设计比赛之余，热情的主办方邀请同学们参观镇海中学内的各处景点，已知镇海中学内共有
𝑛
n处景点。现在有
𝑛
n位该校的学生志愿承担导游和讲解任务。每个学生志愿者对各个景点的熟悉程度是不同的，如何将n位导游分配至
𝑛
n处景点，使得总的熟悉程度最大呢？要求每个景点处都有一个学生导游。

【输 入】

输入文件中有若干行：

第一行只有一个正整数
𝑛
n，表示有
𝑛
n个景点和
𝑛
n个学生导游。

第二行至第
𝑛
+
1
n+1行共
𝑛
n行，每行有
𝑛
n个以空格分隔的正整数。第
𝑖
+
1
i+1行的第
𝑗
j个数
𝑘
(
1
≤
𝑘
≤
1000
)
k(1≤k≤1000)，表示第
𝑖
i个学生导游对景点
𝑗
j的熟悉程度为
𝑘
k。

【输 出】

输出文件只有一行，该行只有一个正整数，表示求得的熟悉程度之和的最大值。

【样例输入】
3
10 6 8
9 2 3
1 7 2

【样例输出】
24

【样例说明】

第1个学生负责第3个景点，第2个学生负责第1个景点，第3个学生负责第2个景点时，熟悉程度总和为24，达到最大值。

【数据限制】

50%的数据，
1
≤
𝑛
≤
9
1≤n≤9；

100%的数据
1
≤
𝑛
≤
17
1≤n≤17。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200][200],vis[200],sum[200],ans=10000,m[200];
void dfs(int dep,int tot)
{
    if(dep>n)
    {
        ans=min(ans,tot);
        return;
    }
    if(tot>ans)
    {
        return;
    }
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            vis[i]=1;
            dfs(dep+1,tot+a[dep][i]);
            vis[i]=0;
        }
    }
}
int main()
{
    cin>>n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
            a[i][j]=1001-a[i][j];
        }
    }
    dfs(1,0);
    cout<<1001*n-ans;
    return 0;
} 
}
```

---

# 导游

## 题目描述

宁波市的中小学生们在镇海中学参加程序设计比赛之余，热情的主办方邀请同学们参观镇海中学内的各处景点，已知镇海中学内共有
𝑛
n处景点。现在有
𝑛
n位该校的学生志愿承担导游和讲解任务。每个学生志愿者对各个景点的熟悉程度是不同的，如何将n位导游分配至
𝑛
n处景点，使得总的熟悉程度最大呢？要求每个景点处都有一个学生导游。

【输 入】

输入文件中有若干行：

第一行只有一个正整数
𝑛
n，表示有
𝑛
n个景点和
𝑛
n个学生导游。

第二行至第
𝑛
+
1
n+1行共
𝑛
n行，每行有
𝑛
n个以空格分隔的正整数。第
𝑖
+
1
i+1行的第
𝑗
j个数
𝑘
(
1
≤
𝑘
≤
1000
)
k(1≤k≤1000)，表示第
𝑖
i个学生导游对景点
𝑗
j的熟悉程度为
𝑘
k。

【输 出】

输出文件只有一行，该行只有一个正整数，表示求得的熟悉程度之和的最大值。

【样例输入】
3
10 6 8
9 2 3
1 7 2

【样例输出】
24

【样例说明】

第1个学生负责第3个景点，第2个学生负责第1个景点，第3个学生负责第2个景点时，熟悉程度总和为24，达到最大值。

【数据限制】

50%的数据，
1
≤
𝑛
≤
9
1≤n≤9；

100%的数据
1
≤
𝑛
≤
17
1≤n≤17。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200][200],vis[200],sum[200],ans,m[200];
void dfs(int dep,int tot)
{
    if(dep>n)
    {
        ans=max(ans,tot);
        return;
    }
    if(tot+sum[n]-sum[dep-1]<ans)
    {
        return;
    }
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            vis[i]=1;
            dfs(dep+1,tot+a[dep][i]);
            vis[i]=0;
        }
    }
}
int main()
{
    cin>>n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
            m[i]=max(m[i],a[i][j]);
        }
        sum[i]=sum[i-1]+m[i];
    }
    dfs(1,0);
    cout<<ans;
    return 0;
} 
}
```

---

# A + B Problem

## 题目描述

1S/16M

给你两个数 
𝑎
a 和 
𝑏
b，请输出他们的和哦。

输入格式

一行，两个用空格隔开的整数 
𝑎
a 和 
𝑏
b。

输出格式

一个整数，表示 
𝑎
+
𝑏
a+b。

样例一
input
2 3

output
5

数据范围

对于
100
%
100%的数据，
−
10000
≤
𝑎
,
𝑏
≤
10000
−10000≤a,b≤10000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b;
    cin>>a>>b;
    cout<<a+b<<endl;
    return 0;
} 
}
```

---

# 砝码称重

## 题目描述

【问题描述】

设有 
1
𝑔
，
2
𝑔
，
3
𝑔
，
5
𝑔
，
10
𝑔
，
20
𝑔
1g，2g，3g，5g，10g，20g 的砝码各若干枚（其总重 
≤
1000
𝑔
≤1000g）。

【输入格式】

输入6个数，分别表示各种重量的砝码的数量。

𝑎
1
、
𝑎
2
、
𝑎
3
、
𝑎
4
、
𝑎
5
、
𝑎
6
a
1
	​

、a
2
	​

、a
3
	​

、a
4
	​

、a
5
	​

、a
6
	​

(表示 
1
𝑔
1g 砝码有 
𝑎
1
a
1
	​

 个，
2
𝑔
2g 砝码有 
𝑎
2
a
2
	​

 个，....
20
𝑔
20g 砝码有 
𝑎
6
a
6
	​

 个)

【输出格式】

𝑇
𝑜
𝑡
𝑎
𝑙
=
𝑁
Total=N(
𝑁
N 表示用这些砝码能称出的不同重量的个数，但不包括一个砝码也不用的情况)

【输入样例】

1 1 0 0 0 0


【输出样例】

Total=3 //表示可以称出 1g，2g，3g 三种不同的重量

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[20],f[1100],b[10]={0,1,2,3,5,10,20};
void dfs(int dep,int tot)
{
    if(dep>6)
    {
        f[tot]=1;
        return;
    }
    for(int i=0;i<=a[dep];i++)
    {
        dfs(dep+1,tot+i*b[dep]);
    }
    }
}
int main()
{
    for(int i=1;i<=6;i++)
    {
        cin>>a[i];
    }
    dfs(1,0);
    int ans=0;
    for(int i=1;i<=1000;i++)
    {
        if(f[i])
        {
        {
            ans++;
        }
    }
    cout<<"Total="<<ans<<endl;
    return 0;
} 
}
```

---

# 全排列

## 题目描述

题目描述

输出自然数 1 到 
𝑛
n 所有不重复的排列，即 
𝑛
n 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。

输入格式：

𝑛
(
1
≤
𝑛
≤
9
)
n(1≤n≤9)

输出格式：

由 
1
1 ～ 
𝑛
n 组成的所有不重复的数字序列，每行一个序列。每个数字间用空格隔开。

输入输出样例
输入样例#1：
3
输出样例#1：
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[20],vis[20];
void dfs(int dep)
{
    if(dep>n)
    {
        for(int i=1;i<=n;i++)
        {
            cout<<a[i]<<" ";
        }
        cout<<endl;
        return;
    }
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            vis[i]=1;
            a[dep]=i;
            dfs(dep+1);
            vis[i]=0;
        }
    }
}
int main()
{
{
    cin>>n;
    dfs(1);
    return 0;
} 
}
```

---

# 线段游戏

## 题目描述

1S/256M

题目描述

小 Y 给了小 Z 共 
𝑛
n 条线段，左右端点为 
[
𝑥
,
𝑦
]
[x,y] 的线段可以覆盖长度为 
𝑦
−
𝑥
y−x 的区间。例如，线段左端点为 
3
3 右端点为 
7
7，那么它可以覆盖 
4
4 个单位长度（线段中 
5
5 个点）。

小 Z 现在要拿走这 
𝑛
n 条线段中的某一条，使得剩余的 
𝑛
−
1
n−1 条线段覆盖到的长度最大。所谓覆盖，指的是某一个单位长度，至少有一条线段包含了它，那么它就是被覆盖的。

每条线段可能有重叠，现在小 Z 请你来帮助他解决这个问题。

输入格式

第一行一个正整数 
𝑛
n 表示线段的数量。

接下来 
𝑛
n 行，每行两个整数 
𝑥
,
𝑦
x,y 分别表示线段的左右端点。

输出格式

输出一个整数，表示小 Z 移走一条线段后，剩余线段能够覆盖的最大单位长度。

样例 #1
样例输入 #1
3
5 9
1 4
3 7

样例输出 #1
7

提示

【样例解释】

移走线段 
[
3
,
7
]
[3,7]，剩余线段 
[
5
,
9
]
,
[
1
,
4
]
[5,9],[1,4] 可以覆盖的长度为 
9
−
5
+
4
−
1
=
7
9−5+4−1=7。

【数据范围】

1
≤
𝑛
≤
100
,
0
≤
𝑥
,
𝑦
≤
1000
1≤n≤100,0≤x,y≤1000。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, l[105], r[105], cnt[1005];
int main() 
{
    cin>>n;
    for(int i = 1; i <= n; i++) 
    {
        cin>>l[i]>>r[i];
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = l[i]; j <= r[i] - 1; j++)
        {
        {
            cnt[j]++;
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) 
    {
        for(int j = l[i]; j <= r[i] - 1; j++) 
        {
            cnt[j]--;
        } 
        int tmp = 0;
        for(int j = 0; j < 1000; j++) 
        { 
        { 
            if(cnt[j])
            {
                tmp++;
            } 
        }
        ans = max(ans, tmp);
        for(int j = l[i]; j <= r[i] - 1; j++) 
        {
            cnt[j]++;
        } 
    }
    cout<<ans;
    return 0;
}
}
```

---

# 判断 6 的倍数

## 题目描述

1S/256M

题目描述

小 Z 现在给你一个巧算 
6
6 的倍数的方法，设 
𝑛
n 代表被判断的数，步骤如下:

当 
𝑛
n 是一位数时，若 
𝑛
n 是 
0
0 或 
6
6，那么它是 
6
6 的倍数。

当 
𝑛
n 是多位数时，若 
𝑛
n 的个位数是奇数，那么 
𝑛
n 不是 
6
6 的倍数；若 
𝑛
n 的个位数是偶数，则计算 
𝑛
n 的各位数字和，若各位数字之和仍是多位数，则继续计算各位数字和，直到数字和是一位数，如果该一位数是 
3
3 的倍数，则 
𝑛
n 是 
6
6 的倍数。

请编写程序模拟以上判断规则并完成以下功能:

根据输入的任意数，首先输出此数的末尾数字

当需要计算各位数字和时，输出每次计算的结果，为了加快计算的速度，每次计算各位数字之和时不累加 
3
3 的倍数的数字。

根据以上判断规则，若 
𝑛
n 是 
6
6 的倍数输出 Yes，否则输出 No。

输入格式

输入一个自然数 
𝑛
n。

输出格式

一行，若干个整数，用英文半角逗号分隔。

第一个数是 
𝑛
n 的末尾数字，后面为若干个按规则计算出的各位数字和，最后为 Yes 或 No。

样例 #1
样例输入 #1
6

样例输出 #1
6,Yes

样例 #2
样例输入 #2
371

样例输出 #2
1,No

样例 #3
样例输入 #3
8786888

样例输出 #3
8,47,11,2,No

提示

【样例 3 解释】

在样例 
3
3 中，
𝑛
n 是 
8786888
8786888，首先输出末尾数字 
8
8，然后输出不含 
3
3 的倍数的各位数字和 
47
47，同理输出 
11
,
2
11,2，最后输出判断结果 No。

【数据范围】

30
%
30% 的数据满足 
1
≤
𝑛
≤
1
0
9
1≤n≤10
9
；

50
%
50% 的数据满足 
1
≤
𝑛
≤
1
0
18
1≤n≤10
18
；

100
%
100% 的数据满足 
1
≤
𝑛
≤
1
0
100
1≤n≤10
100
。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    cin >> s;
    int len = s.size();
    cout << s[len - 1]<<",";
    if (len == 1)
    {
        if (s[0] == '0' || s[0] == '6')
        {
            cout << "Yes";
            return 0;
            return 0;
        }
        else
        {
            cout << "No";
            return 0;
        }
    }
    int tmp = s[len - 1] - '0';
    if (tmp % 2 == 1)
    {
        cout << "No";
        return 0;
    }
    }
    int sum = 0;
    for (int i = 0; i < len; i++)
    {
        tmp = s[i] - '0';
        if (tmp % 3 != 0)
        {
            sum += tmp;
        }
    }
    cout << sum << ",";
    while (sum >= 10)
    {
        tmp = sum;
        sum = 0;
        sum = 0;
        while (tmp)
        {
            int num = tmp % 10;
            if (num % 3 != 0)
            {
                sum += num;
            }
            tmp /= 10;
        }
        cout<<sum<<",";
    }
    if (sum % 3 == 0)
    {
    {
        cout << "Yes";
    }
    else
    {
        cout << "No";
    }
    return 0;
}
}
```

---

# 判断闰年

## 题目描述

未能提取到题目信息

### 代码

```cpp
未能提取到完整代码内容
```

---

# 四则运算

## 题目描述

未能提取到题目信息

### 代码

```cpp
未能提取到完整代码内容
```

---

# 钻石广场

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

提起宁波名校，不得不说蛟川书院。一进蛟川书院就是一个喷泉钻石广场映入眼帘。为了迎接新年，蛟川书院准备在钻石广场（可看成是一个环形广场）四周安装 
𝑛
n 个喷泉，这些喷泉喷水高度分为三种，分别为 5,8,10 米。同时广场四周每个位置如果喷的高度不一样，那么美观度也不一样。

蛟川书院希望这一圈喷泉喷水时要有层次感，换句话说就是任何一个位置的喷泉喷的高度都要比它相邻的两个喷泉喷的高度都高或者都低，在此条件下，想要提供一套方案使得美观度和最高。

输入格式

第 1 行为一个正整数 
𝑛
n，表示需要安装 
𝑛
n 个喷泉（
𝑛
n 为大于等于 4 的偶数）。

接下来 
𝑛
n 行，每行 3 个正整数 
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
x
i
	​

，y
i
	​

，z
i
	​

，表示了第 
𝑖
i 个位置分别安装高度为 5，8，10 的喷泉能获得的美观度。（
0
≤
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
≤
10000
0≤x
i
	​

，y
i
	​

，z
i
	​

≤10000）

其中第 
𝑖
i 个位置与第 
𝑖
+
1
i+1 个位置相邻，温馨提醒由于是环，第 1 个位置与第 
𝑛
n 个位置相邻。

输出格式

输出一个整数，为最大的美观度和。

样例输入
4
1 3 2
3 1 2
3 1 2
3 1 2

样例输出
11

样例说明

第一个位置安装喷水高度为 8，第二个为 5 ，第三个为 10 ，第四个为 5 。价值=（3+3+2+3）

数据规模

对于 
20
%
20% 的数据，
𝑛
≤
10
n≤10；

对于 
60
%
60% 的数据，
𝑛
≤
1000
n≤1000；

对于 
100
%
100% 的数据，
𝑛
≤
100000
n≤100000；

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100010][3][2],a[100010][3],n,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    }
    for(int t=0;t<3;t++)
    {
        for(int i=0;i<3;i++)
        {
        {
            for(int k=0;k<2;k++)
            {
                dp[1][i][k]=0;
            }
        }
        dp[1][t][0]=dp[1][t][1]=a[1][t];
        for(int i=2;i<=n;i++)
        {
            dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];
            dp[i][1][0]=dp[i-1][2][1]+a[i][1];
            dp[i][1][1]=dp[i-1][0][0]+a[i][1];
            dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];
        }
        }
        for(int i=0;i<t;i++)
        {
            ans=max(ans,dp[n][i][0]);
        }
        for(int i=2;i>t;i--)
        {
            ans=max(ans,dp[n][i][1]);
        }
    }
    cout<<ans;
    return 0;
} 
}
```

---

# 矩阵转置

## 题目描述

####【题目描述】

输入一个n行m列的矩阵A，输出它的转置 ，即矩阵A的行和列对应互换 ，具体看样例

####【输入】 第一行包含两个整数n和m，表示矩阵A的行数和列数(1≤n≤100，1≤m≤100)。

接下来n行，每行m个整数，表示矩阵A的元素。相邻两个整数之间用单个空格隔开，每个元素均在1~1000之间。

####【输出】

m行，每行n个整数，为矩阵A的转置。相邻两个整数之间用单个空格隔开。

####【输入样例】

3 3
1 2 3
4 5 6
7 8 9 


####【输出样例】

1 4 7
2 5 8
3 6 9


####【输入样例2】

3 4
1 2 3 4
5 6 7 8
9 10 11 12


####【输出样例2】

1 5 9
2 6 10
3 7 11
4 8 12

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105][105],b[105][105],n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            b[i][j]=a[i][j];
        }
    }
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            b[i][j]=a[j][i];
        }
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cout<<b[i][j]<<" ";
        }
        }
        cout<<endl;
    }
    return 0; 
}
}
```

---

# 钻石广场

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

提起宁波名校，不得不说蛟川书院。一进蛟川书院就是一个喷泉钻石广场映入眼帘。为了迎接新年，蛟川书院准备在钻石广场（可看成是一个环形广场）四周安装 
𝑛
n 个喷泉，这些喷泉喷水高度分为三种，分别为 5,8,10 米。同时广场四周每个位置如果喷的高度不一样，那么美观度也不一样。

蛟川书院希望这一圈喷泉喷水时要有层次感，换句话说就是任何一个位置的喷泉喷的高度都要比它相邻的两个喷泉喷的高度都高或者都低，在此条件下，想要提供一套方案使得美观度和最高。

输入格式

第 1 行为一个正整数 
𝑛
n，表示需要安装 
𝑛
n 个喷泉（
𝑛
n 为大于等于 4 的偶数）。

接下来 
𝑛
n 行，每行 3 个正整数 
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
x
i
	​

，y
i
	​

，z
i
	​

，表示了第 
𝑖
i 个位置分别安装高度为 5，8，10 的喷泉能获得的美观度。（
0
≤
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
≤
10000
0≤x
i
	​

，y
i
	​

，z
i
	​

≤10000）

其中第 
𝑖
i 个位置与第 
𝑖
+
1
i+1 个位置相邻，温馨提醒由于是环，第 1 个位置与第 
𝑛
n 个位置相邻。

输出格式

输出一个整数，为最大的美观度和。

样例输入
4
1 3 2
3 1 2
3 1 2
3 1 2

样例输出
11

样例说明

第一个位置安装喷水高度为 8，第二个为 5 ，第三个为 10 ，第四个为 5 。价值=（3+3+2+3）

数据规模

对于 
20
%
20% 的数据，
𝑛
≤
10
n≤10；

对于 
60
%
60% 的数据，
𝑛
≤
1000
n≤1000；

对于 
100
%
100% 的数据，
𝑛
≤
100000
n≤100000；

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100010][3][2],a[100010][3],n,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    }
    for(int t=0;t<3;t++)
    {
        for(int i=0;i<3;i++)
        {
        {
            for(int k=0;k<2;k++)
            {
                dp[1][i][k]=0;
            }
            dp[1][t][0]=dp[1][t][1]=a[1][t];
            for(int i=2;i<=n;i++)
            {
                dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];
                dp[i][1][0]=dp[i-1][2][1]+a[i][1];
                dp[i][1][1]=dp[i-1][0][0]+a[i][1];
                dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];
            }
            for(int i=0;i<t;i++)
            for(int i=0;i<t;i++)
            {
                ans=max(ans,dp[n][i][0]);
            }
            for(int i=2;i>t;i--)
            {
                ans=max(ans,dp[n][i][1]);
            }
        }
    }
    cout<<ans;
    return 0;
} 
}
```

---

# 钻石广场

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

提起宁波名校，不得不说蛟川书院。一进蛟川书院就是一个喷泉钻石广场映入眼帘。为了迎接新年，蛟川书院准备在钻石广场（可看成是一个环形广场）四周安装 
𝑛
n 个喷泉，这些喷泉喷水高度分为三种，分别为 5,8,10 米。同时广场四周每个位置如果喷的高度不一样，那么美观度也不一样。

蛟川书院希望这一圈喷泉喷水时要有层次感，换句话说就是任何一个位置的喷泉喷的高度都要比它相邻的两个喷泉喷的高度都高或者都低，在此条件下，想要提供一套方案使得美观度和最高。

输入格式

第 1 行为一个正整数 
𝑛
n，表示需要安装 
𝑛
n 个喷泉（
𝑛
n 为大于等于 4 的偶数）。

接下来 
𝑛
n 行，每行 3 个正整数 
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
x
i
	​

，y
i
	​

，z
i
	​

，表示了第 
𝑖
i 个位置分别安装高度为 5，8，10 的喷泉能获得的美观度。（
0
≤
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
≤
10000
0≤x
i
	​

，y
i
	​

，z
i
	​

≤10000）

其中第 
𝑖
i 个位置与第 
𝑖
+
1
i+1 个位置相邻，温馨提醒由于是环，第 1 个位置与第 
𝑛
n 个位置相邻。

输出格式

输出一个整数，为最大的美观度和。

样例输入
4
1 3 2
3 1 2
3 1 2
3 1 2

样例输出
11

样例说明

第一个位置安装喷水高度为 8，第二个为 5 ，第三个为 10 ，第四个为 5 。价值=（3+3+2+3）

数据规模

对于 
20
%
20% 的数据，
𝑛
≤
10
n≤10；

对于 
60
%
60% 的数据，
𝑛
≤
1000
n≤1000；

对于 
100
%
100% 的数据，
𝑛
≤
100000
n≤100000；

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100010][3][2],a[100010][3],n,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    }
    for(int t=0;t<3;t++)
    {
        for(int i=0;i<3;i++)
        {
        {
            for(int k=0;k<2;k++)
            {
                dp[1][i][k]=0;
                dp[1][t][0]=dp[1][t][1]=a[1][t];
                for(int i=2;i<=n;i++)
                {
                    dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];
                    dp[i][1][0]=dp[i-1][2][1]+a[i][1];
                    dp[i][1][1]=dp[i-1][0][0]+a[i][1];
                    dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];
                }
                for(int i=0;i<t;i++)
                {
                {
                    ans=max(ans,dp[n][i][0]);
                }
                for(int i=2;i>t;i--)
                {
                    ans=max(ans,dp[n][i][1]);
                }
            }
        }
    }
    cout<<ans;
    return 0;
} 
}
```

---

# 钻石广场

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

提起宁波名校，不得不说蛟川书院。一进蛟川书院就是一个喷泉钻石广场映入眼帘。为了迎接新年，蛟川书院准备在钻石广场（可看成是一个环形广场）四周安装 
𝑛
n 个喷泉，这些喷泉喷水高度分为三种，分别为 5,8,10 米。同时广场四周每个位置如果喷的高度不一样，那么美观度也不一样。

蛟川书院希望这一圈喷泉喷水时要有层次感，换句话说就是任何一个位置的喷泉喷的高度都要比它相邻的两个喷泉喷的高度都高或者都低，在此条件下，想要提供一套方案使得美观度和最高。

输入格式

第 1 行为一个正整数 
𝑛
n，表示需要安装 
𝑛
n 个喷泉（
𝑛
n 为大于等于 4 的偶数）。

接下来 
𝑛
n 行，每行 3 个正整数 
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
x
i
	​

，y
i
	​

，z
i
	​

，表示了第 
𝑖
i 个位置分别安装高度为 5，8，10 的喷泉能获得的美观度。（
0
≤
𝑥
𝑖
，
𝑦
𝑖
，
𝑧
𝑖
≤
10000
0≤x
i
	​

，y
i
	​

，z
i
	​

≤10000）

其中第 
𝑖
i 个位置与第 
𝑖
+
1
i+1 个位置相邻，温馨提醒由于是环，第 1 个位置与第 
𝑛
n 个位置相邻。

输出格式

输出一个整数，为最大的美观度和。

样例输入
4
1 3 2
3 1 2
3 1 2
3 1 2

样例输出
11

样例说明

第一个位置安装喷水高度为 8，第二个为 5 ，第三个为 10 ，第四个为 5 。价值=（3+3+2+3）

数据规模

对于 
20
%
20% 的数据，
𝑛
≤
10
n≤10；

对于 
60
%
60% 的数据，
𝑛
≤
1000
n≤1000；

对于 
100
%
100% 的数据，
𝑛
≤
100000
n≤100000；

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100010][3][2],a[100010][3],n,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    }
    for(int t=0;t<3;t++)
    {
        for(int i=1;i<3;i++)
        {
        {
            for(int k=0;k<2;k++)
            {
                dp[1][i][k]=0;
                dp[1][t][0]=dp[1][t][1]=a[1][t];
                for(int i=2;i<=n;i++)
                {
                    dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];
                    dp[i][1][0]=dp[i-1][2][1]+a[i][1];
                    dp[i][1][1]=dp[i-1][0][0]+a[i][1];
                    dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];
                }
                for(int i=0;i<t;i++)
                {
                {
                    ans=max(ans,dp[n][i][0]);
                }
                for(int i=2;i>t;i--)
                {
                    ans=max(ans,dp[n][i][1]);
                }
            }
        }
    }
    cout<<ans;
    return 0;
} 
}
```

---

# 特殊的队列

## 题目描述

题目描述

小智刚学习了数组，小码准备测试一下小智是否真的掌握，小码给出一个含
𝑛
n个元素的整数数组，让小智判断数组中的数是不是都相等，小智觉得太简单可了。因此小智把题目改了，让小智判断数组中两个连续元素之间差的绝对值是否都相等，如果相等则称之为“特殊的队列”，如数组
141
−
2
141−2符合“特殊的队列”，因为差的绝对值分别为：
3
,
3
,
3
3,3,3。

给定一个数组，判断该数组是否为“特殊的队列”。

输入格式

每组测试数据第一行以一个整数
𝑛
(
1
≤
𝑛
≤
1000
)
n(1≤n≤1000)开始，接下来
𝑛
n个空格隔开的在[
−
1
0
4
−10
4
,
1
0
4
10
4
]之间的整数。

输出格式

对于每组测试数据，输出一行若该数组符合“特殊的队列”则输出"YES"，否则输出"NO"。

样例 #1
样例输入 #1
4 1 4 1 -2

样例输出 #1
YES

样例 #2
样例输入 #2
5 1 4 2 -1 6

样例输出 #2
NO

提示

1
≤
𝑛
≤
1000
1≤n≤1000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a[1005],ans;
    bool flag=1;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ans=abs(a[1]-a[2]);
    for(int i=2;i<=n-1;i++)
    {
    {
        if(abs(a[i]-a[i+1])!=ans)
        {
            flag=0;
            break;
        }
    }
    if(flag==0)
    {
        cout<<"NO";
    }
    else
    {
        cout<<"YES";
        cout<<"YES";
    }
}
}
```

---

# 成绩转换

## 题目描述

【问题描述】

输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下： 90~100为A; 80~89为B; 70~79为C; 60~69为D; 0~59为E;

【输入格式】

由一个整数组成

【输出格式】

输出一行。如果输入数据不在0~100范围内，请输出一行：“Score is error!”。

【输入样例】

100


【输出样例】

A

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
int main()
{
    int n;
    cin>>n;
    if(n>100||n<0)
    {
        cout<<"Score is error!";
    }
    else if(n>=90&&n<100)
    {
        cout<<"A";
    }
    }
    else if(n>=80&&n<90)
    {
        cout<<"B";
    }
    else if(n>=70&&n<80)
    {
        cout<<"C";
    }
    else if(n>=60&&n<70)
    {
        cout<<"D";
    }
    else
    else
    {
        cout<<"E";
    }
    return 0; 
}
}
```

---

# 成绩转换

## 题目描述

【问题描述】

输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下： 90~100为A; 80~89为B; 70~79为C; 60~69为D; 0~59为E;

【输入格式】

由一个整数组成

【输出格式】

输出一行。如果输入数据不在0~100范围内，请输出一行：“Score is error!”。

【输入样例】

100


【输出样例】

A

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
int main()
{
    int n;
    cin>>n;
    if(n>100&&n<0)
    {
        cout<<"Score is error!";
    }
    else if(n>=90&&n<100)
    {
        cout<<"A";
    }
    }
    else if(n>=80&&n<90)
    {
        cout<<"B";
    }
    else if(n>=70&&n<80)
    {
        cout<<"C";
    }
    else if(n>=60&&n<70)
    {
        cout<<"D";
    }
    else
    else
    {
        cout<<"E";
    }
    return 0; 
}
}
```

---

# 成绩转换

## 题目描述

【问题描述】

输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下： 90~100为A; 80~89为B; 70~79为C; 60~69为D; 0~59为E;

【输入格式】

由一个整数组成

【输出格式】

输出一行。如果输入数据不在0~100范围内，请输出一行：“Score is error!”。

【输入样例】

100


【输出样例】

A

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
int main()
{
    int n;
    cin>>n;
    if(n>100)
    {
        cout<<"Score is error!";
    }
    else if(n>=90&&n<100)
    {
        cout<<"A";
    }
    }
    else if(n>=80&&n<90)
    {
        cout<<"B";
    }
    else if(n>=70&&n<80)
    {
        cout<<"C";
    }
    else if(n>=60&&n<70)
    {
        cout<<"D";
    }
    else
    else
    {
        cout<<"E";
    }
    return 0; 
}
}
```

---

# 成绩转换

## 题目描述

【问题描述】

输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下： 90~100为A; 80~89为B; 70~79为C; 60~69为D; 0~59为E;

【输入格式】

由一个整数组成

【输出格式】

输出一行。如果输入数据不在0~100范围内，请输出一行：“Score is error!”。

【输入样例】

100


【输出样例】

A

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
int main()
{
    int n;
    cin>>n;
    if(n>100)
    {
        cout<<"Score is error!";
    }
    else if(n>=90)
    {
        cout<<"A";
    }
    }
    else if(n>=80)
    {
        cout<<"B";
    }
    else if(n>=70)
    {
        cout<<"C";
    }
    else if(n>=60)
    {
        cout<<"D";
    }
    else
    else
    {
        cout<<"E";
    }
    return 0; 
}
}
```

---

# 成绩转换

## 题目描述

【问题描述】

输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下： 90~100为A; 80~89为B; 70~79为C; 60~69为D; 0~59为E;

【输入格式】

由一个整数组成

【输出格式】

输出一行。如果输入数据不在0~100范围内，请输出一行：“Score is error!”。

【输入样例】

100


【输出样例】

A

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
int main()
{
    int n;
    cin>>n;
    if(n>100)
    {
        cout<<"Score is error!";
    }
    else if(n>=90)
    {
        cout<<"A";
    }
    }
    else if(n>=80)
    {
        cout<<"B";
    }
    else if(n>=70)
    {
        cout<<"C";
    }
    else if(n>=60)
    {
        cout<<"D";
    }
    else
    else
    {
        cout<<"E";
    }
    return 0; 
}
}
```

---

# 数的拆分

## 题目描述

1S/256M

【题目描述】

任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。

当n=7共14种拆分方法：

7=1+1+1+1+1+1+1
7=1+1+1+1+1+2
7=1+1+1+1+3
7=1+1+1+2+2
7=1+1+1+4
7=1+1+2+3
7=1+1+5
7=1+2+2+2
7=1+2+4
7=1+3+3
7=1+6
7=2+2+3
7=2+5
7=3+4
total=14


【输入】

输入n。 
(
1
≤
𝑛
≤
8
)
(1≤n≤8)

【输出】

按字典序输出具体的方案。

【输入样例】

7


【输出样例】

7=1+1+1+1+1+1+1
7=1+1+1+1+1+2
7=1+1+1+1+3
7=1+1+1+2+2
7=1+1+1+4
7=1+1+2+3
7=1+1+5
7=1+2+2+2
7=1+2+4
7=1+3+3
7=1+6
7=2+2+3
7=2+5
7=3+4
total=14

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[20],ans;
void dfs(int dep,int left)
{
    if(left<0)
    {
        return;
    }
    if(left==0)
    {
        cout<<n<<"=";
        for(int i=1;i<=dep-2;i++)
        {
        {
            cout<<a[i]<<"+";
        }
        cout<<a[dep-1]<<endl;
        ans+=1;
        return;
    }
    for(int i=max(a[dep-1],1);i<=min(left,n-1);i++)
    {
        a[dep]=i;
        dfs(dep+1,left-i);
    }
} 
int main()
int main()
{
    cin>>n;
    dfs(1,n);
    cout<<"total=" <<ans;
    return 0;
} 
}
```

---

# 外星生命

## 题目描述

####【问题描述】 在外太空航行的飞船拍到了某种外星生命的图像。科学家在研究该图像时，把该图像分为n行m列, 共n*m个格子，每格给出了一个以整数表示的相似度的值。现在请你帮助统计该图像可以分成几部分？ 给定一个正整数的灵敏度值x, 如果某格与某相邻格子的相似度值的差值小于或等于x时，该格与该相邻格子属于同一个部件（所谓相邻，是指上、下、左、右之一）。如下图所示，当灵敏度值分别为10和5时，可以分为3个部件和5个部件。

10 15 13 252 250 235

28 25 10 250 245 240

100 105 11 12 91 89

99 104 102 100 90 88

####【输 入】 输入文件live.in中有若干行： 第一行有三个整数n、m和x,表示图像有n行m列,设定的灵敏度为x。 第二行起至第n+1行，每行有m个整数，互相间以一个空格分隔。 第k+1行的第j个整数，表示图像中第k行第j列的相似度值。 ####【输 出】 输出文件live.out中只有一行，该行只有一个整数，表示可以划分出的部件数。 ####【样例输入1】

4  6  10
10 15 13 252 250 235
28 25 10 250 245 240
100 105 11 12 91 89
99 104 102 100 90 88


####【样例输出1】

3


####数据限制 1≤n,m≤1000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans=0;
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,1,-1};
int a[1005][1005],vis[1005][1005];
void dfs(int x,int y)
{
    for(int i=1;i<=4;i++)
    {
        int tx=x+dx[i];
        int ty=y+dy[i];
        if(tx>=1&&ty>=1&&tx<=n&&ty<=m&&!vis[tx][ty]&&abs(a[tx][ty]-a[x][y])<=k)
        {
        {
            vis[tx][ty]=1;
            dfs(tx,ty);
        }
    }
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(!vis[i][j])
            {
                vis[i][j]=1;
                ans+=1;
                dfs(i,j);
            }
        }
    }
    }
    cout<<ans;
    return 0;
} 
}
```

---

# 特殊的队列

## 题目描述

题目描述

小智刚学习了数组，小码准备测试一下小智是否真的掌握，小码给出一个含
𝑛
n个元素的整数数组，让小智判断数组中的数是不是都相等，小智觉得太简单可了。因此小智把题目改了，让小智判断数组中两个连续元素之间差的绝对值是否都相等，如果相等则称之为“特殊的队列”，如数组
141
−
2
141−2符合“特殊的队列”，因为差的绝对值分别为：
3
,
3
,
3
3,3,3。

给定一个数组，判断该数组是否为“特殊的队列”。

输入格式

每组测试数据第一行以一个整数
𝑛
(
1
≤
𝑛
≤
1000
)
n(1≤n≤1000)开始，接下来
𝑛
n个空格隔开的在[
−
1
0
4
−10
4
,
1
0
4
10
4
]之间的整数。

输出格式

对于每组测试数据，输出一行若该数组符合“特殊的队列”则输出"YES"，否则输出"NO"。

样例 #1
样例输入 #1
4 1 4 1 -2

样例输出 #1
YES

样例 #2
样例输入 #2
5 1 4 2 -1 6

样例输出 #2
NO

提示

1
≤
𝑛
≤
1000
1≤n≤1000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a[1005],ans;
    bool flag=1;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ans=abs(a[1]-a[2]);
    for(int i=2;i<=n-1;i++)
    {
    {
        if(abs(a[i]-a[i+1])!=ans)
        {
            flag=0;
            break;
        }
    }
    if(flag==0)
    {
        cout<<"NO";
    }
    else
    {
        cout<<"YES";
        cout<<"YES";
    }
}
}
```

---

# 元素（Element）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

给定一个长度为 
𝑛
n 的字符串 
𝑆
S，可以划分为若干个不相交的子串，形为一个大写字母加一个数（若为 
1
1，则省略），表示一个物质含有元素的个数。

求这个物质含有 O 的个数。

输入格式

第一行一个正整数 
𝑛
n。

第二行一个字符串 
𝑆
S。

输出格式

一个整数，表示含有 O 的个数。

样例 #1
样例输入 #1
2
CO

样例输出 #1
1

样例 #2
样例输入 #2
2
O2

样例输出 #2
2

样例 #3
样例输入 #3
1
C

样例输出 #3
0

提示

对于 
100
%
100% 的数据，
1
≤
𝑛
≤
100
1≤n≤100，保证答案小于等于 
100
100。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    int n;
    bool flag = 1;
    cin >> n;
    char str[10000];
    cin >> str;
    for (int j = 0; str[j] != '\0'; j++)
    {
        if (str[j] == 'O')
        {
            if (((str[j + 1] >= '1' && str[j + 1] <= '9') && (str[j + 2] >= '2' && str[j + 1] <= '9')) || (str[j + 1] >= '2' && str[j + 1] <= '9'))
            else
            {
                cout << 1;
                flag = 0;
            }
        }
    }
    if (flag == 1)
    {
        cout << 0;
    }
    return 0;
}
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    long a[10000000],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a[50000005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 质因数分解

## 题目描述

已知正整数
𝑛
n是两个不同的质数的乘积，试求出两者中较大的那个质数。

输入格式：

输入只有一行，包含一个正整数
𝑛
n。

输出格式：

输出只有一行，包含一个正整数
𝑝
p，即较大的那个质数。

样例1
input
21

output
7

限制与约定

对于
100
%
100%的数据，满足
6
≤
𝑛
≤
1
0
10
6≤n≤10
10

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,maxx=0;
    cin>>n;
    for(int i=2;i<=sqrt(n);i++)
    {
        if(n%i==0&&i>maxx)
        {
            maxx=i;
        }
    }
    cout<<n/maxx;
}
```

---

# 质因数分解

## 题目描述

已知正整数
𝑛
n是两个不同的质数的乘积，试求出两者中较大的那个质数。

输入格式：

输入只有一行，包含一个正整数
𝑛
n。

输出格式：

输出只有一行，包含一个正整数
𝑝
p，即较大的那个质数。

样例1
input
21

output
7

限制与约定

对于
100
%
100%的数据，满足
6
≤
𝑛
≤
1
0
10
6≤n≤10
10

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,maxx=0;
    cin>>n;
    for(int i=2;i<=n-1;i++)
    {
        if(n%i==0&&i>maxx)
        {
            maxx=i;
        }
    }
    cout<<maxx;
}
```

---

# 幕布

## 题目描述

【题目描述】

水平地面上有
𝑛
n根高度不一样的立柱，相邻两个立柱之间相距1米。现在要在两个立柱之间挂一块长方形的幕布。如图所示阴影部分表示幕布挂装的一种方案。幕布两侧需要挂在立柱上并且幕布要保持水平。现在想知道能挂的幕布的最大面积是多少。

如果立柱损坏则无法挂装幕布，损坏的立柱用-1表示。

【输入格式】

第一行输入一个数
𝑛
n，表示立柱的数量。

第二行输入
𝑛
n个数，表示立柱的高度
ℎ
𝑖
h
i
	​

。若为-1表示该立柱损坏。

【输出格式】

输出一个数表示最大的面积。

【输入样例】
5
2 4 2 6 4

【输出样例】
12

【数据范围】

80%的数据保证，
1
≤
𝑛
≤
1000
1≤n≤1000

100%的数据保证，
1
≤
𝑛
≤
1
0
5
1≤n≤10
5
，
1
≤
ℎ
𝑖
≤
1
0
5
1≤h
i
	​

≤10
5

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a[100005],maxx=-100000,x;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
}
```

---

# 喜报连连

## 题目描述

题目描述

2024年浙江省高考成绩揭晓，智码信息学竞赛（信竞）生全部获得了浙江大学及以上高校的预录取，这一辉煌成就不仅彰显了镇中在信息学竞赛方面的卓越培养能力，更展现了镇中在文化课教育上的雄厚实力。 在信息学竞赛的培养中，始终秉承“励志、进取、勤奋、健美”的校训，为学生提供了一流的教学资源和丰富的竞赛经验。我们的信竞生不仅在各类竞赛中屡创佳绩，也在高考中展示出卓越的综合素质和过硬的学术能力。 众所周知，拿到NOI金牌即可报送清华北大，例如施同学。当然没有金牌也没关系，银牌和铜牌也会有相应的降分政策，一般来说铜牌即可降分30。 比如2023年，北大的分数线为703分。2024年随着成绩的公布，
𝑛
n名信竞生的成绩也都知晓，假设这些人全部获得铜牌，请问如果按照2023年的录取分数线能上北大的有几人？

样例输入
6
706 702 692 686 673 670

样例输出
5

数据范围
0<=n<=100

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a[105],sum=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]>=703-30)
        {
            sum+=1;
        }
    }
}
```

---

# 宝石合成

## 题目描述

题目描述

在魔法世界里,两颗红宝石可以合成一颗蓝宝石,两颗蓝宝石可以合成一颗绿宝石,两颗绿宝石可以合成一颗黄宝石,现在给你n颗红宝石,请问最少可以合成几颗黄宝石.

输入格式

一个整数代表红宝石

输出格式

一个整数代表合成的黄宝石数量

样例输入
140

样例输出
17

数据范围
0<=n<=10000

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n;
    cin>>n;
    n/=2;
    n/=2;
    n/=2;
    cout<<n;
    return 0;
}
}
```

---

# 移植灌木

## 题目描述

灌木移植是园艺学中一项重要的技术，可以改变植物的栽植位置并保证其生长的良好发展。但是并不是所有高度的灌木都适合移植。经过前段时间小实的培育，实获后花园已经有n株灌木，现在需要统计出大灌木，中灌木，小灌木。其中大灌木高度要达到145cm及以上，中灌木则是135cm-144cm（包括135和144），小灌木就是135cm以下的灌木。

现给出所有灌木的高度（均为整数），请你帮忙统计出大灌木，中灌木，小灌木的数量。

输入格式：

第一行，一个整数n。(n<=60)

第二行，n个整数，为每株灌木的高度。

输出格式：

一行，三个整数，分别为大灌木，中灌木，小灌木的数量。

输入样例：

10

130 140 142 145 136 137 125 150 131 137

输出样例：

2 5 3

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a[65],x=0,y=0,z=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]>=145)
        {
            x+=1;
        }
        else if(a[i]>=135)
}
```

---

# 培育灌木

## 题目描述

【题目描述】

小实精心栽培了 
3
3 颗灌木丛，它们分别栽培在 
1
1 号、
2
2 号、
3
3 号位置。一开始的时候 
3
3 颗灌木丛的高度是一样高的，但是随着时间的流逝，小实发现灌木丛的生长速度不一样。经过几天的细心观察，小实记录了每颗灌木丛的生长速度。现在小实想要知道，经过 
𝑛
n 天以后，哪颗灌木丛的高度最高。

【输入格式】

输入 
5
5 个数，分别为 
𝑛
n，
ℎ
h，
𝑎
a，
𝑏
b，
𝑐
c，
ℎ
h 表示三颗灌木丛的初始高度，
𝑎
、
𝑏
、
𝑐
a、b、c 分别表示三颗灌木丛的生长速度。输入保证灌木的生长速度都不一样。

【输出格式】

输出一个数，表示最高的那颗灌木丛的位置。

【输入样例】
3 4 1 2 3

【输出样例】
3

【样例解释】

经过 
3
3 天后，
1
1 号灌木丛高度为 
4
+
3
=
7
4+3=7，
2
2 号灌木丛高度为 
4
+
6
=
10
4+6=10，
3
3 号灌木丛高度为 
4
+
9
=
13
4+9=13，因此高度最高的灌木丛为 
3
3 号。

【数据范围】

1
≤
𝑛
,
ℎ
,
𝑎
,
𝑏
,
𝑐
≤
100
1≤n,h,a,b,c≤100

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,h,a,b,c;
    cin>>n>>h>>a>>b>>c;
    a=h+n*a;
    b=h+n*b;
    c=h+n*c;
    if(a>b&&a>c)
    {
        cout<<1;
    }
    if(b>a&&b>c)
}
```

---

# 元素（Element）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

给定一个长度为 
𝑛
n 的字符串 
𝑆
S，可以划分为若干个不相交的子串，形为一个大写字母加一个数（若为 
1
1，则省略），表示一个物质含有元素的个数。

求这个物质含有 O 的个数。

输入格式

第一行一个正整数 
𝑛
n。

第二行一个字符串 
𝑆
S。

输出格式

一个整数，表示含有 O 的个数。

样例 #1
样例输入 #1
2
CO

样例输出 #1
1

样例 #2
样例输入 #2
2
O2

样例输出 #2
2

样例 #3
样例输入 #3
1
C

样例输出 #3
0

提示

对于 
100
%
100% 的数据，
1
≤
𝑛
≤
100
1≤n≤100，保证答案小于等于 
100
100。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    int n;
    bool flag = 1;
    cin >> n;
    char str[10000];
    cin >> str;
    for (int j = 0; str[j] != '\0'; j++)
    {
        if (str[j] == 'O')
        {
            if (((str[j + 1] >= '1' && str[j + 1] <= '9') && (str[j + 2] >= '2' && str[j + 1] <= '9')) || (str[j + 1] >= '2' && str[j + 1] <= '9')||(str[j+1]=='1'&&str[j+2]=='0'&&str[j+3]=='0'))
                }
                flag = 0;
            }
            else
            {
                cout << 1;
                flag = 0;
            }
        }
    }
    if (flag == 1)
    {
        cout << 0;
    }
    return 0;
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a[30000005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
        {
            cout<<1<<endl;
        }
        else
        {
            cout<<-1<<endl;
        }
    }
    return 0;
}
}
}
            cout<<-1<<endl;
        }
    }
    return 0;
            cout<<1<<endl;
        }
        else
        {
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    long a[20000005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    long a[10000005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    long long a[10000005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    long long a[100005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a[100005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a[100005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 图案（Pattern）

## 题目描述

1000
𝑚
𝑠
/
256
𝑀
𝐵
1000ms/256MB

题目描述

小 L 喜欢形状为 “L” 的图案，其中他尤其喜欢 
4
5
∘
45
∘
 对称的 “L” 形的图案（即以左下角为原点，沿 
𝑦
=
𝑥
y=x 对称）。

例如：

我们定义一个长方形为一个不为正方形的矩形，即对于给定 
𝑎
,
𝑏
∈
𝑁
∗
a,b∈N
∗
，存在唯一的长方形

𝑆
=
{
(
𝑥
,
𝑦
)
∣
0
≤
𝑥
≤
𝑎
∧
0
≤
𝑦
≤
𝑏
}
S={(x,y)∣0≤x≤a∧0≤y≤b}

定义两个图形的并为它们点集的并，交为它们点集的交。定义两个集合 
𝑆
,
𝑇
S,T 不相互包含当且仅当 
𝑆
⊄
𝑇
∧
𝑇
⊄
𝑆
S

⊂T∧T

⊂S。

定义一个“L”形为两个不相互包含的长方形的并。

除此以外，小 L 希望这个图形是“规整”的——即它能够划分成若干个边长为 
1
1 的正方形。

并且他要尤其喜欢这个 “L” 形。

我们称这种 “L” 形的图案为可爱的 “L” 形。

小 L 希望知道是否存在面积为 
𝑥
x 的可爱的 “L” 形。

输入格式

本题有多组测试数据。

第一行输入一个正整数 
𝑇
T，表示数据组数。

每组数据包含一个正整数 
𝑥
x，表示可爱的 “L” 形的面积。

输出格式

对于每一组数据。

如果存在，请输出 1；否则输出 -1。

样例 #1
样例输入 #1
4
1
2
3
4

样例输出 #1
-1
-1
1
-1

提示
样例解释

对于面积为 
1
1 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-1。

对于面积为 
2
2 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。可枚举的图案为图1-2。

对于面积为 
3
3 的可爱的“L”形。我们可以发现这样的是可以的（图1-3）。

对于面积为 
4
4 的可爱的“L”形。我们通过枚举发现不存在这样的可爱的“L”形。部分枚举的图案为图1-4，图1-5。

数据范围

对于 
20
%
20% 的数据，保证 
𝑥
≤
1
0
2
x≤10
2
。

对于 
50
%
50% 的数据，保证 
𝑥
≤
1
0
4
x≤10
4
。

对于 
100
%
100% 的数据，保证 
𝑇
≤
1
0
5
,
𝑥
≤
1
0
8
T≤10
5
,x≤10
8
。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a[100005],n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        if((a[i]!=1&&a[i]%2==1)||(a[i]!=4&&a[i]%4==0))
        {
}
```

---

# 砍树（tree）

## 题目描述

【题目描述】 伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。 米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。 例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。 米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。 【输入】 第1行：2个整数N和M，N表示树木的数量（1<=N<=1000000）,M表示需要的木材总长度（1<=M<=2000000000） 第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。 【输出】 第1行：1个整数，表示砍树的最高高度。 【样例输入】  5 20 4 42 40 26 46 【样例输出】 36

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        if(x<=a[i]){
            sum+=(a[i]-x);
        }
    }
    if(sum>=m){
        return true;
    }
    return false;
    return false;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int l=0,r=2000000000;
    while(l<r){
        int mid=(l+r+1)/2;
        if(check(mid)){
            l=mid;
        }
        else{
        else{
            r=mid-1;
        }
    }
    cout<<l<<endl;
    return 0;
}
}
```

---

# 统计人口（people）

## 题目描述

【问题描述】 第七次全国人口普查开始了，小B要去“幸福村”统计人口数量。“幸福村”里住着n户人家，呈线性排列，从左到右的编号为1到n。通过电脑平台，小B统计到了每户人家的人口数量ai​。当小B去“幸福村”核查数据时，如果编号为x到y的都不在家（无法核查不在家的人口数量），求小B能核查到多少人口数量？ 【输入格式】 第一行2个整数n,m。 第二行n个数a1​,a2​,a3​…an​ 表示每户人家的人口数。 接下来m行，每行两个数x,y，表示编号为x到y的不在家。 【输出格式】 共m行，每行一个数，表示当编号为x到y的不在家时，小B能核查到多少人口数量。 【输入样例1】 4 2 3 1 5 6 1 3 3 3 【输出样例1】 6 10 【样例解释】 有4户，每户分别有3人，1人，5人，6人。当编号为1∼3的不在家时，只能统计到第4户的人口数量，有6人；当编号为3∼3，也就是只有编号为3的在家时，能统计到第1,2,4户的人口数量，共有10人。 【数据范围约定】 对于30%的数据，1≤n≤100，1≤m≤100； 对于50%的数据，1≤n≤1000，1≤m≤10000； 对于100%的数据，1≤n≤50000，1≤m≤50000，1≤x≤y≤n，保证输出的所有答案不超231-1 范围。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[50005],b[50005],sum,x,y;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=a[i]+b[i-1];
        sum+=a[i];
    }
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        cout<<sum-(b[y]-b[x-1])<<endl;
    }
    }
    return 0;
}
}
```

---

# 奖学金

## 题目描述

【问题描述】

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。

期末，每个学生都有3门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面。这样，每个学生的排序是唯一确定的。

任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:

7 279

5 279

这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是:

5 279

7 279

否则按输出错误处理，不能得分。

【输入格式】

第 1 行一个正整数 
𝑛
n，表示该校参加评选的学生人数。

第 2 到 
𝑛
+
1
n+1 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到 100 之间，每行的 3 个数字依次表示学号为 
𝑗
−
1
j−1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 
1
−
𝑛
1−n (恰好是输入数据的行号减 1 )。

【输出格式】

每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。

【输入样例1】
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98	

【输出样例1】
6 265
4 264
3 258
2 244
1 237

【输入样例2】
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98	

【输出样例2】
8 265
2 264
6 264
1 258
5 258

【数据限制】

对于 
50
%
50% 的数据满足：各学生的总成绩各不相同。

对于 
100
%
100% 的数据满足：
6
≤
𝑛
≤
300
6≤n≤300。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct student{
    int c,m,e,sum,num;
}a[305];
bool cmp(student x,student y){
    if(x.sum>y.sum){
        return true;
    }
    else if(x.sum==y.sum&&x.c>y.c){
        return true;
    }
    else if(x.sum==y.sum&&x.c==y.c&&x.num<y.num){
    else if(x.sum==y.sum&&x.c==y.c&&x.num<y.num){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].c>>a[i].m>>a[i].e;
        a[i].sum=a[i].c+a[i].m+a[i].e;
        a[i].num=i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=5;i++){
    for(int i=1;i<=5;i++){
        cout<<a[i].num<<" "<<a[i].sum<<endl;
    }
    return 0;
} 
}
```

---

# 补码

## 题目描述

题目描述

计算机的处理器是电路做的，电路只能做加法，如何能让电脑做减法呢？这就需要用到补码。减去一个数就等于加上它的补码，于是减法就转换为机器能执行的加法，计算机就能算减法了。

对于任意一个十进制整数 
𝑛
(
−
127
≤
𝑛
≤
127
)
n(−127≤n≤127) 可以用八位的二进制数表示，其中最高位是符号位，0 表示正数，1 表示负数。

我们可以按以下规则将任意一个十进制数x 转换为它对应的补码；正数的补码等于它对应的二进数本身，如[127]补=01111111；负数的补码等于对应的二进制数按位取反（0 变成1，1 变成0）再加上1。

如[-10]补 = 11110110。

求 -10 的补码的具体步骤是这样的：

(1) 转换成二进制数：1010；

(2) 扩充为8 位二进制最高位为1：10001010；

(3) 最高位保持不变，其余按位取反：11110101；

(4) 加1：11110101+1=11110110。

请编写一个程序求二进制整数的补码。

【输入格式】

一个十进制整数n（
−
127
≤
𝑛
≤
127
−127≤n≤127）。

样例输入1
-10

样例输出1
11110110  

样例输入2
127

样例输出2
01111111

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[10],cnt=7,c;
bool flag=1;
int main(){
    cin>>n;
    if(n<=0){
        cout<<1;
    }
    else{
        cout<<0;
    }
    x=abs(n);
    while(x!=0){
    while(x!=0){
        c=x%2;
        a[cnt]=c;
        x/=2;
        cnt-=1;
    }
    for(int i=1;i<=7;i++){
        if(a[i]==1){
            a[i]=0;
        }
        else{
            a[i]=1;
        }
    }
    }
    a[7]+=1;
    for(int i=1;i<=7;i++){
        if(a[i]>1){
            a[i]-=2;
            a[i-1]+=1;
            flag=0;
        }
    }
    while(flag==0){
        flag=1;
        for(int i=1;i<=7;i++){
            if(a[i]>1){
                a[i]-=2;
                a[i-1]+=1;
                a[i-1]+=1;
                flag=0;
            }
        }
    }
    for(int i=1;i<=7;i++){
        cout<<a[i];
    }
    return 0;
} 
}
```

---

# 补码

## 题目描述

题目描述

计算机的处理器是电路做的，电路只能做加法，如何能让电脑做减法呢？这就需要用到补码。减去一个数就等于加上它的补码，于是减法就转换为机器能执行的加法，计算机就能算减法了。

对于任意一个十进制整数 
𝑛
(
−
127
≤
𝑛
≤
127
)
n(−127≤n≤127) 可以用八位的二进制数表示，其中最高位是符号位，0 表示正数，1 表示负数。

我们可以按以下规则将任意一个十进制数x 转换为它对应的补码；正数的补码等于它对应的二进数本身，如[127]补=01111111；负数的补码等于对应的二进制数按位取反（0 变成1，1 变成0）再加上1。

如[-10]补 = 11110110。

求 -10 的补码的具体步骤是这样的：

(1) 转换成二进制数：1010；

(2) 扩充为8 位二进制最高位为1：10001010；

(3) 最高位保持不变，其余按位取反：11110101；

(4) 加1：11110101+1=11110110。

请编写一个程序求二进制整数的补码。

【输入格式】

一个十进制整数n（
−
127
≤
𝑛
≤
127
−127≤n≤127）。

样例输入1
-10

样例输出1
11110110  

样例输入2
127

样例输出2
01111111

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[10],cnt=7,c;
bool flag=1;
int main(){
    cin>>n;
    if(n<0){
        cout<<1;
    }
    else{
        cout<<0;
    }
    x=abs(n);
    while(x!=0){
    while(x!=0){
        c=x%2;
        a[cnt]=c;
        x/=2;
        cnt-=1;
    }
    for(int i=1;i<=7;i++){
        if(a[i]==1){
            a[i]=0;
        }
        else{
            a[i]=1;
        }
    }
    }
    a[7]+=1;
    for(int i=1;i<=7;i++){
        if(a[i]>1){
            a[i]-=2;
            a[i-1]+=1;
            flag=0;
        }
    }
    while(flag==0){
        flag=1;
        for(int i=1;i<=7;i++){
            if(a[i]>1){
                a[i]-=2;
                a[i-1]+=1;
                a[i-1]+=1;
                flag=0;
            }
        }
    }
    for(int i=1;i<=7;i++){
        cout<<a[i];
    }
    return 0;
} 
}
```

---

# 小鱼的游泳时间

## 题目描述

题目描述

伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。

这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 24 小时制计算），它发现自己从 
𝑎
a 时 
𝑏
b 分一直游泳到当天的 
𝑐
c 时 
𝑑
d 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？

小鱼游的好辛苦呀，你可不要算错了哦。

输入格式

一行内输入 4 个整数，分别表示 
𝑎
,
𝑏
,
𝑐
,
𝑑
a,b,c,d。

输出格式

一行内输出 2 个整数 
𝑒
e 和 
𝑓
f，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。

其中表示分钟的整数 
𝑓
f 应该小于60。

输入样例

12 50 19 10


输出样例

6 20


说明/提示

对于全部测试数据，
0
≤
𝑎
,
𝑐
≤
240
≤
𝑎
,
𝑐
≤
24
，
0
≤
𝑏
,
𝑑
≤
600
≤
𝑏
,
𝑑
≤
60
0≤a,c≤240≤a,c≤24，0≤b,d≤600≤b,d≤60，且结束时间一定晚于开始时间。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,sum=0;
int main(){
    cin>>a>>b>>c>>d;
    sum+=c*60+d-a*60-b;
    cout<<sum/60<<" "<<sum%60;
    return 0;
} 
}
```

---

# 画矩形4

## 题目描述

题目描述

画出一个 
𝑚
∗
𝑛
m∗n 的矩形，第一行都是 1 ，第二行都是 2 ，以此类推。

输入描述

输入两个整数 
𝑚
m 和 
𝑛
n 。（
1
≤
𝑚
,
𝑛
≤
20
1≤m,n≤20）

输出描述

输出 
𝑚
∗
𝑛
m∗n 的矩形。

输入样例
5 4

输出样例
1111
2222
3333
4444
5555

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int main(){
    cin>>m>>n;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            cout<<i;
        }
        cout<<endl;
    }
    return 0;
} 
}
```

---

# 促销

## 题目描述

促销

【问题描述】

一文具店为了回馈广大顾客，推出买圆珠笔芯送圆珠笔芯促销活动，顾客每写完一支圆珠笔芯存起来，
𝑀
(
1
<
𝑀
)
M(1<M) 支用完的圆珠笔芯可以换一支新的圆珠笔芯，一定是用完的 
𝑀
M 支才能换一支。小 A 买了 
𝑁
N 支圆珠笔芯，问最多可以用多少支圆珠笔芯？

【输入格式】

共一行，两个整数 
𝑁
,
𝑀
N,M 。

【输出格式】

输出只有一个整数，表示最多可用圆珠笔芯支数。

【输入样例 1】

12 4


【输出样例 1】

15


【数据规模与约定】

对于 
100
%
100% 的数据：
1
≤
𝑁
≤
1
0
16
，
1
<
𝑀
≤
100
1≤N≤10
16
，1<M≤100。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,sum,sy,x;
int main(){
    cin>>n>>m;
    sum=n,sy=n;
    while(sy>=m){
        x=sy;
        sum+=x/m;
        sy=x%m;
        sy+=x/m;
    }
    cout<<sum;
    return 0;
}
```

---

# 分组(group)

## 题目描述

分组(group)

【问题描述】

一市共有 
𝑁
N 位学生报名参加中考跳绳项目，已知每位学生最好的跳绳成绩 
𝑎
𝑖
a
i
	​

。为了增强跳绳的观赏度，提高测试成绩，组委会将学生分成 
𝑥
x 组进行，每组最多由 2 位学生组成，同组学生之间最好的成绩差的绝对值必须小于或等于 
𝐾
(
0
≤
𝐾
≤
500
)
K(0≤K≤500)。求 
𝑥
x 的最小值。

【输入格式】

第一行两个整数 
𝑁
,
𝐾
N,K 。

第二行输入 
𝑁
N 个整数，表示每位学生跳绳的最好成绩。

【输出格式】

输出一行一个整数，
𝑥
x 的最小值。

【输入样例 1】

6 20
120 130 140 145 150 170


【输出样例 1】

3


【输入样例 2】

6 0
100 150 150 150 160 160


【输出样例 2】

4


【数据规模与约定】

对于 
100
%
100% 的数据：
1
≤
𝑁
≤
1000
，
0
≤
𝑎
𝑖
≤
500000
,
0
≤
𝐾
≤
500
1≤N≤1000，0≤a
i
	​

≤500000,0≤K≤500。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1005],vis[1005],sum;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<n;i++){
        if(!vis[i]){
            if(a[i+1]-a[i]<=k){
                sum+=1;
                vis[i]=1;
}
```

---

# 分组(group)

## 题目描述

分组(group)

【问题描述】

一市共有 
𝑁
N 位学生报名参加中考跳绳项目，已知每位学生最好的跳绳成绩 
𝑎
𝑖
a
i
	​

。为了增强跳绳的观赏度，提高测试成绩，组委会将学生分成 
𝑥
x 组进行，每组最多由 2 位学生组成，同组学生之间最好的成绩差的绝对值必须小于或等于 
𝐾
(
0
≤
𝐾
≤
500
)
K(0≤K≤500)。求 
𝑥
x 的最小值。

【输入格式】

第一行两个整数 
𝑁
,
𝐾
N,K 。

第二行输入 
𝑁
N 个整数，表示每位学生跳绳的最好成绩。

【输出格式】

输出一行一个整数，
𝑥
x 的最小值。

【输入样例 1】

6 20
120 130 140 145 150 170


【输出样例 1】

3


【输入样例 2】

6 0
100 150 150 150 160 160


【输出样例 2】

4


【数据规模与约定】

对于 
100
%
100% 的数据：
1
≤
𝑁
≤
1000
，
0
≤
𝑎
𝑖
≤
500000
,
0
≤
𝐾
≤
500
1≤N≤1000，0≤a
i
	​

≤500000,0≤K≤500。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1005],vis[1005],sum;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i<n;i++){
        if(!vis[i]){
            if(a[i+1]-a[i]<=k){
                sum+=1;
                vis[i]=1;
}
```

---

# 裂变

## 题目描述

1S/256M

问题背景

在一个魔法世界中，有一种神奇的宝石，一对宝石可以用两种方法裂变成一对略有差异的宝石，初始时，你有两块大小相同的宝石，每块的大小都是1单位。现在，你希望通过一系列的列表操作，使得一对大小都是1单位的宝石，至少有一块宝石的大小等于目标大小n单位。

操作规则如下:

裂变操作一：你可以将一对大小为x,y的宝石裂变成一对大小为x+y,y的宝石。

裂变操作二：你可以将一对大小为x,y的宝石裂变成一对大小为x,x+y的宝石。

输入：

第一行输入一个正整数n，表示目标宝石的大小。

输出：

输出一个整数，表示达到目标所需的最少操作次数。

样例输入：

2


样例输出：

1


数据范围

对于40%的数据，1 ≤ n ≤ 1000
对于100%的数据，1 ≤ n ≤ 10^5

样例解释

1,1通过裂变一就达到1,2

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct gemstone{
    int gem1=1,gem2=1,step=0;
};
queue<gemstone>q;
int main(){
    cin>>n;
    q.push({1,1,0});
    while(!q.empty()){
        gemstone x=q.front();
        q.pop();
        int g1=x.gem1;
}
```

---

# 砍树（tree）

## 题目描述

【题目描述】 伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。 米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。 例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。 米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。 【输入】 第1行：2个整数N和M，N表示树木的数量（1<=N<=1000000）,M表示需要的木材总长度（1<=M<=2000000000） 第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。 【输出】 第1行：1个整数，表示砍树的最高高度。 【样例输入】  5 20 4 42 40 26 46 【样例输出】 36

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        if(x<a[i]){
            sum+=(a[i]-x);
        }
    }
    if(sum>=m){
        return true;
    }
    return false;
    return false;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int l=0,r=2000000000;
    while(l<r){
        int mid=(l+r+1)/2;
        if(check(mid)){
            l=mid;
        }
        else{
        else{
            r=mid-1;
        }
    }
    cout<<l<<endl;
    return 0;
}
}
```

---

# 裂变

## 题目描述

1S/256M

问题背景

在一个魔法世界中，有一种神奇的宝石，一对宝石可以用两种方法裂变成一对略有差异的宝石，初始时，你有两块大小相同的宝石，每块的大小都是1单位。现在，你希望通过一系列的列表操作，使得一对大小都是1单位的宝石，至少有一块宝石的大小等于目标大小n单位。

操作规则如下:

裂变操作一：你可以将一对大小为x,y的宝石裂变成一对大小为x+y,y的宝石。

裂变操作二：你可以将一对大小为x,y的宝石裂变成一对大小为x,x+y的宝石。

输入：

第一行输入一个正整数n，表示目标宝石的大小。

输出：

输出一个整数，表示达到目标所需的最少操作次数。

样例输入：

2


样例输出：

1


数据范围

对于40%的数据，1 ≤ n ≤ 1000
对于100%的数据，1 ≤ n ≤ 10^5

样例解释

1,1通过裂变一就达到1,2

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct gemstone{
    int gem1=1,gem2=1,step=0;
};
queue<gemstone>q;
int main(){
    cin>>n;
    q.push({1,1,0});
    while(!q.empty()){
        gemstone x=q.front();
        q.pop();
        int g1=x.gem1;
}
```

---

# 砍树（tree）

## 题目描述

【题目描述】 伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。 米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。 例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。 米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。 【输入】 第1行：2个整数N和M，N表示树木的数量（1<=N<=1000000）,M表示需要的木材总长度（1<=M<=2000000000） 第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。 【输出】 第1行：1个整数，表示砍树的最高高度。 【样例输入】  5 20 4 42 40 26 46 【样例输出】 36

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        if(x<a[i]){
            sum+=(a[i]-x);
        }
    }
    if(sum>=m){
        return true;
    }
    return false;
    return false;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int l=1,r=2000000000;
    while(l<r){
        int mid=(l+r+1)/2;
        if(check(mid)){
            l=mid;
        }
        else{
        else{
            r=mid-1;
        }
    }
    cout<<l<<endl;
    return 0;
}
}
```

---

# 蛋糕店(cake)

## 题目描述

【问题描述】 最近小G新开了一家蛋糕店。开业第一天，一共来了n位顾客。由于小G 非常懒，他每次只会接待一位顾客。每个顾客都想尽快的买到蛋糕，所以没有第一个买到蛋糕的顾客都会有一个愤怒值。最终排在第i个位置的顾客x的愤怒值为ia[x]。小 G想要排列队伍让所有顾客的愤怒值之和最小。求最小的愤怒值之和。 【输入格式】 第一行为一个整数n，表示顾客数。 第二行输入n个整数a[1]..a[n] ，含义见题面 【输出格式】 一行一个整数ans，表示最小的愤怒值之和。 【样例输入】 5 8 5 8 4 6 【样例输出】 51 【样例解释】 Ans=81+62+53+4*4=51 【数据规模和约定】 对于30%的数据，1 ≤ n ≤ 10。 对于60%的数据，1 ≤ n ≤ 1000。 对于100%的数据，1 ≤ n ≤ 1000000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000005],sum=1,ans=0;
bool cmp(long long x,long long y){
    if(x>y){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++){
        ans+=sum*a[i];
        sum++;
    }
    cout<<ans;
    return 0;
}
}
```

---

# 蛋糕店(cake)

## 题目描述

【问题描述】 最近小G新开了一家蛋糕店。开业第一天，一共来了n位顾客。由于小G 非常懒，他每次只会接待一位顾客。每个顾客都想尽快的买到蛋糕，所以没有第一个买到蛋糕的顾客都会有一个愤怒值。最终排在第i个位置的顾客x的愤怒值为ia[x]。小 G想要排列队伍让所有顾客的愤怒值之和最小。求最小的愤怒值之和。 【输入格式】 第一行为一个整数n，表示顾客数。 第二行输入n个整数a[1]..a[n] ，含义见题面 【输出格式】 一行一个整数ans，表示最小的愤怒值之和。 【样例输入】 5 8 5 8 4 6 【样例输出】 51 【样例解释】 Ans=81+62+53+4*4=51 【数据规模和约定】 对于30%的数据，1 ≤ n ≤ 10。 对于60%的数据，1 ≤ n ≤ 1000。 对于100%的数据，1 ≤ n ≤ 1000000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10000005],sum=1,ans=0;
bool cmp(long long x,long long y){
    if(x>=y){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++){
        ans+=sum*a[i];
        sum+=1;
    }
    cout<<ans<<endl;
    return 0;
}
}
```

---

# 蛋糕店(cake)

## 题目描述

【问题描述】 最近小G新开了一家蛋糕店。开业第一天，一共来了n位顾客。由于小G 非常懒，他每次只会接待一位顾客。每个顾客都想尽快的买到蛋糕，所以没有第一个买到蛋糕的顾客都会有一个愤怒值。最终排在第i个位置的顾客x的愤怒值为ia[x]。小 G想要排列队伍让所有顾客的愤怒值之和最小。求最小的愤怒值之和。 【输入格式】 第一行为一个整数n，表示顾客数。 第二行输入n个整数a[1]..a[n] ，含义见题面 【输出格式】 一行一个整数ans，表示最小的愤怒值之和。 【样例输入】 5 8 5 8 4 6 【样例输出】 51 【样例解释】 Ans=81+62+53+4*4=51 【数据规模和约定】 对于30%的数据，1 ≤ n ≤ 10。 对于60%的数据，1 ≤ n ≤ 1000。 对于100%的数据，1 ≤ n ≤ 1000000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10000005],sum=0,ans=0;
bool cmp(long long x,long long y){
    if(x>=y){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        ans+=sum*a[i];
        sum+=1;
    }
    cout<<ans<<endl;
    return 0;
}
}
```

---

# 蛋糕店(cake)

## 题目描述

【问题描述】 最近小G新开了一家蛋糕店。开业第一天，一共来了n位顾客。由于小G 非常懒，他每次只会接待一位顾客。每个顾客都想尽快的买到蛋糕，所以没有第一个买到蛋糕的顾客都会有一个愤怒值。最终排在第i个位置的顾客x的愤怒值为ia[x]。小 G想要排列队伍让所有顾客的愤怒值之和最小。求最小的愤怒值之和。 【输入格式】 第一行为一个整数n，表示顾客数。 第二行输入n个整数a[1]..a[n] ，含义见题面 【输出格式】 一行一个整数ans，表示最小的愤怒值之和。 【样例输入】 5 8 5 8 4 6 【样例输出】 51 【样例解释】 Ans=81+62+53+4*4=51 【数据规模和约定】 对于30%的数据，1 ≤ n ≤ 10。 对于60%的数据，1 ≤ n ≤ 1000。 对于100%的数据，1 ≤ n ≤ 1000000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10000005],sum=0,ans=0;
bool cmp(int x,int y){
    if(x>=y){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        ans+=sum*a[i];
        sum+=1;
    }
    cout<<ans<<endl;
    return 0;
}
}
```

---

# 蛋糕店(cake)

## 题目描述

【问题描述】 最近小G新开了一家蛋糕店。开业第一天，一共来了n位顾客。由于小G 非常懒，他每次只会接待一位顾客。每个顾客都想尽快的买到蛋糕，所以没有第一个买到蛋糕的顾客都会有一个愤怒值。最终排在第i个位置的顾客x的愤怒值为ia[x]。小 G想要排列队伍让所有顾客的愤怒值之和最小。求最小的愤怒值之和。 【输入格式】 第一行为一个整数n，表示顾客数。 第二行输入n个整数a[1]..a[n] ，含义见题面 【输出格式】 一行一个整数ans，表示最小的愤怒值之和。 【样例输入】 5 8 5 8 4 6 【样例输出】 51 【样例解释】 Ans=81+62+53+4*4=51 【数据规模和约定】 对于30%的数据，1 ≤ n ≤ 10。 对于60%的数据，1 ≤ n ≤ 1000。 对于100%的数据，1 ≤ n ≤ 1000000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000005],sum=0,ans=0;
bool cmp(int x,int y){
    if(x>=y){
        return true;
    }
    return false;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        ans+=sum*a[i];
        sum+=1;
    }
    cout<<ans<<endl;
    return 0;
}
}
```

---

# 求和(sum)

## 题目描述

【题目描述】 小明养了一条非常聪明的狗，这条狗居然能认识数字，而且还会进行加法运算。更神奇的是，这条狗不仅认识1位数，还认识多位数，并且能够在数字和字母夹杂的文章中找出所有的数字，并把他们的和算出来。例如 28sswwdd72sowweoi87ss2w,小狗可以发现这段内容包含了4个数字28、72、87、2，并能够算出他们的和189。 小明很想验证每次小狗算出来的是不是正确，但是这对他来说太难了，所以小明想找聪明的你帮忙，请你也来计算一遍。 【输入】    一行，一个字符串（只有数字和小写字母，长度<=100000）     【输出】 这些数字的和 (保证结果<2^31) 【样例输入 】 28sswwdd72sowweoi87ss2w 【样例输出】 189 【样例解释】 28+72+87+2=189 【数据范围】 60%的数据 字符串长度不超过255； 100%的数据 字符串长度不超过100000。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int sum,num,ans=0,x,c;
int main(){
    cin>>s;
    for(int i=0;i<s.length();i++){
        sum=0;
        c=i;
        x=0;
        while(s[c]>='0'&&s[c]<='9'){
            sum+=1;
            c+=1;
        }
        }
        num=pow(10,sum-1);
        for(int j=i;j<=i+sum-1;j++){
            x+=num*(s[j]-'0');
            num/=10;
        }
        i+=sum;
        ans+=x;
    }
    cout<<ans;
    return 0;
}
}
```

---


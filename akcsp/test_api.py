import os
from openai import OpenAI
import json

def test_api():
    try:
        # 读取配置文件
        config_path = os.path.join(os.path.dirname(__file__), 'config.json')
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)

        # 初始化客户端
        client = OpenAI(
            api_key=config.get('api_key'),
            base_url=config.get('base_url')
        )

        print("正在调用API...")
        
        # 测试API调用
        completion = client.chat.completions.create(
            model=config.get('model', 'deepseek-v3'),  # 从配置文件获取模型名称，默认使用 deepseek-r1
            messages=[
            {
                "role": "system",
                "content": "你是一位专业的C++算法助理，帮助用户分析给定的C++题目及多条题解。需要对各题解进行要点提炼、难点对比，并给出精炼结论。"
            },
            {
                "role": "user",
                "content": "【题目内容】\n# 硬币问题\n\n## 题目描述\n\n今有面值为 1、5、11 元的硬币各无限枚。\n\n想要凑出 $n$ 元，问需要的最少硬币数量。\n\n## 说明/提示\n\n#### 样例解释\n\n对于样例数据 1，最佳方案是 $15=5+5+5$，使用到 3 枚硬币。\n\n对于样例数据 2，最佳方案是 $12=11 + 1$，使用到 2 枚硬币。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $n\\leq 10^6$。\n\n## 样例 #1\n\n### 输入\n\n```\n15```\n\n### 输出\n\n```\n3```\n\n## 样例 #2\n\n### 输入\n\n```\n12```\n\n### 输出\n\n```\n2```\n\n【大神题解列表】\n# 题解## 作者：ShanCreeperPro (赞：130)\n\n# B3635 硬币问题 題解\n\n\n**管理员注：**\n\n阅读本文章前，请先阅读[$ \\ \\texttt{ShanCreeper}$ B 题库题解的声明](https://www.luogu.com.cn/blog/Ru19Free/AboutBProblem)，并了解由于课程需要不展示代码。\n\n**如需系统学习相关知识点请报名【[洛谷-基础算法计划](https://class.luogu.com.cn/)】**\n\n\n***\n\n究极无敌典中典之入门 dp 问题。\n\n有面值 1 5 11 的三种硬币，问凑出 $n$ 元钱要多少枚硬币。\n\n尝试贪心，尽可能先用大面额，不够再用小面额。\n\n但这是错误的，例如凑 15 元，贪心方法是 $11+1+1+1$，而最优却是 $5+5+5$。\n\n首先，假设我们知道：\n\n- 凑**14元**至少要**4枚**硬币；\n- 凑**10元**至少要**2枚**硬币；\n- 凑**4元**至少要**4枚**硬币。\n\n那么要凑 15 元的话：\n\n- 先拿 1 元，还要 14 元，即总共要 5 枚；\n- 先拿 5 元，还要 10 元，即总共要 3 枚；\n- 先拿 11 元，还要 4 元，即总共要 5 枚。\n\n所以，只要我们知道了**凑 14,10,4 元需要多少硬币**，我们不需要其他条件就能求出最少方案。\n\n所以，我们能得出：\n\n> 用小问题的解，求大问题的解。\n\n这是一个 dp 的基本思路。\n\n**结论**\n\n要解决凑 $n$ 元的问题，需要知道以下数据：\n\n**代价**：凑足 $n$ 元需要多少枚硬币：\n\n- $n-1$ 的代价是 $a$，加上 1 元可以凑到 $n$；\n- $n-5$ 的代价是 $b$，加上 5 元可以凑到 $n$；\n- $n-11$ 的代价是 $c$，加上 11 元可以凑到 $n$。\n\n所以，凑 $n$ 元的代价就是：\n\n$$ \\min (a + 1 , b + 1 , c + 1) + 1$$\n\n所以，求 $n$ 的问题我们可以分解成求 $n-1,n-5,n-11$ 这三个小问题，这个问题规模是在下降的。\n\n**表格法：**\n\n用 $f(n)$ 表示凑出 $n$ 元钱所需的硬币格数，按照刚才的方法，可以填出：\n\n|$n$|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n|$f(n)$|0|1|2|3|4|1|2|3|4|5|2|1|2|3|4|3||\n\n那么，代码实现就如下：\n\n- 首先开 $f$ 数组，存储 $f(n)$ 的结果；\n\n- $f_0$ 的初始值是 $0$ 哦；\n\n- 从 1 到 $n$ 循环，其中 $f_i$ 的值为 $\\min(f_{i-1},f_{i-5},f_{i-11})$。\n\n- 注意，$f_{i-5}$ 和 $f_{i-11}$ 可能会越界。\n\n\n当然，如果你觉得判断越界不好想的话，你可以把从 $f_0$ 到 $f_{11}$ 全部初始化（\n\n时间复杂度 $O(n)$。\n\n我们总结一下：\n\n- dp 问题，发现只要**解决几个更小规模的问题**，就能得到大问题的解；\n- 所以我们可以**设计一张表格**，每个格子代表一个问题的解；\n- 根据初始信息，一步步填表格；\n- 填完后，就得到了答案。\n\n---\n\n【需求】\n1. 整理并对比这些题解的思路、算法要点、以及解决难点。\n2. 对每条题解进行简要评分(1~5星)，依据质量(如思路清晰度、代码可读性、优化程度等)。\n3. 最多仅返回3条评分较高(≥4星)的题解，若全部不足4星，则不用返回具体题解。\n4. 提取或总结其中最优的关键思路或技巧(如数据结构、算法优化)。\n5. 若有可拓展之处，可简单说明同类型题或类似算法套路，以便后续举一反三。推荐3道考察相似知识点的洛谷题目（附题号）\n\n【输出要求】\n• 先给出对题解的综合分析与结论(无需复述题干)。\n• 列出所选的题解(若≥4星)\n  - 标注该题解的星级与关键亮点\n• 若所有题解<4星，则不列题解只给建议。\n• 不要全文粘贴题解代码，只需简述核心实现思想。\n• 逻辑简洁，条理清晰。\n"
            }]
                )
                

        # 打印响应
        print("\n=== API调用成功 ===")
        print("\n完整响应:")
        print(completion)
        
        print("\n消息内容:")
        print(completion.choices[0].message.content)

        # 尝试打印思考过程（如果有的话）
        try:
            reasoning = completion.choices[0].message.reasoning_content
            if reasoning:
                print("\n思考过程:")
                print(reasoning)
        except AttributeError:
            print("\n注: 该响应中没有思考过程(reasoning_content)")

    except Exception as e:
        print(f"\n错误: {type(e).__name__}")
        print(f"错误信息: {str(e)}")
        print("\n请检查:")
        print("1. config.json 文件是否存在且格式正确")
        print("2. API密钥是否正确")
        print("3. base_url 是否正确")
        print("4. 网络连接是否正常")

if __name__ == "__main__":
    test_api() 
